<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Counties (Hub Cache Viewer)</title>
<link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600;700;800&display=swap" rel="stylesheet">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/favicons/android-chrome-512x512.png">
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://d3js.org/topojson.v3.min.js"></script>
<style>
  :root { --bg:#ffffff; --fg:#eaf0ff; --muted:#9fb3d1; --card:#14233d; --ok:#a5f3a5; --warn:#ffd79a; }
  
  :root {
    --left-panel-extra-top: 14vh;  /* increase to move panel further down */
  }

    :root{
      --header-font: "URWDIN","URWDIN-SC",system-ui,sans-serif;
    }

    :root{
      --header-top-size: clamp(18px, 2.2vw, 34px);  /* NTD | 2026 | PRESIDENTIAL */
      --header-loc-size: clamp(28px, 3.2vw, 60px);  /* “UNITED STATES” / state */
    }

    
    /* URW DIN Demi (regular width) */
    @font-face{
      font-family: "URWDIN";
      src: url("../fonts/URWDIN-Demi.otf") format("opentype");
      font-weight: 600;            /* Demi = ~600 */
      font-style: normal;
      font-display: swap;
    }

    /* Optional: SemiCondensed Demi, if you decide to use it */
    @font-face{
      font-family: "URWDIN-SC";
      src: url("../fonts/URWDINSemiCond-Demi.otf") format("opentype");
      font-weight: 600;
      font-style: normal;
      font-display: swap;
    }


  /* viewport + box model */
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;               /* no page scrollbars */
    background: #ffffff url('../images/background.gif') center / cover no-repeat fixed;
    color: #ffffff;
    font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }

  /* fixed header height so stage can subtract it exactly */
  header{
    height: 48px;
    padding: 12px 16px;             /* keep your look */
    display:flex; align-items:center; gap:10px;
    font-weight:700;
    background:transparent;
    color: #000000;
    border-bottom:1px solid rgba(255,255,255,.12);
    justify-content: flex-start;
    border-bottom: none;
  }

  /* legacy utilities */
  .wrap{display:grid;grid-template-columns:1fr 420px;gap:14px;height:calc(100% - 48px)}
  svg{width:100%;height:100%;background:#ffffff}
  .panel{background:var(--card);border:1px solid rgba(255,255,255,.14);border-radius:14px;display:flex;flex-direction:column;min-height:0}
  .panel h2{margin:0;padding:10px 12px;font-size:14px;color:var(--muted);border-bottom:1px solid rgba(255,255,255,.08)}
  .controls{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{background:#1f2d50;color:var(--fg);border:1px solid rgba(255,255,255,.18);border-radius:8px;padding:6px 10px;cursor:pointer}
  button:hover{background:#213360}
  .badge{background:#17274a;padding:2px 8px;border-radius:999px;font-size:11px}
  .body{padding:10px;overflow:auto}   /* allow internal scrolling only */
  .logline{font-family:ui-monospace,monospace;font-size:12px;white-space:pre-wrap}
  .cand{font-family:ui-monospace,monospace;font-size:13px;margin:2px 0}
  .highlight{stroke:#fff;stroke-width:1.2px}
  .kv{font:12px ui-monospace,monospace}

  /* --- three-panel stage with a centered map --- */
  .stage{
    position: relative;
    width: 100vw;                          /* fill viewport width */
    height: calc(100svh - 48px);           /* fill viewport height minus header */
    display: flex;
    align-items: stretch;
    justify-content: center;
    overflow: hidden;                       /* clip anything that would spill */
    background: #ffffff;
  }

  /* the map lives in the middle, low z-index */
  .map-shell{
    position: relative;
    z-index: 0;                             /* LOW z */
    margin: 0 auto 0 4vw;
    width: min(1400px, 82vw);               /* preserve your sizing */
    flex: 1 1 auto;
    min-height: 0;
    background:#ffffff;                     /* same as your svg background */
    border-radius:14px;
    border:1px solid rgba(255,255,255,.08);
    overflow: hidden;
  }

    :root{
      /* pick any fixed height you like */
      --left-fixed-h: 64vh; /* e.g., ~2 candidate cards tall */
    }

    /* REPLACE your current .left-panel block with this */
    .left-panel{
      position: fixed;                      /* bolt it to the viewport */
      top: calc(var(--header-h) + 10vh);     /* sit just under the header */
      left: calc(var(--gap) + 10vw);
      width: var(--left-w);
      height: 56vh;          /* << fixed height */
      z-index: 30;
      background: transparent;
      color: #000;
      border: 0;
      border-radius: 14px;
      display: flex;
      flex-direction: column;
      overflow: hidden;                      /* contain the scroller */
    }

    /* make the inside actually scroll */
    .left-panel .body{
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .right-panel{
      position: fixed;            /* bolt to the viewport */
      top: 0;                     /* runs from very top... */
      right: 0;
      bottom: 0;                  /* ...to very bottom */
      width: var(--right-w);
      z-index: 1000;
      background: var(--card);
      border: 0;
      border-radius: 0;           /* squared edges since it spans full height */
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

  .left-panel{ left:100px; }
  .right-panel{ right:16px; }

  /* reuse your existing .panel styling for headings/sections */
  .right-panel .body, .left-panel .body{ padding:10px; overflow:auto; }
  .right-panel .body{ height: 100%; overflow: auto; }

  #raceControls{ display:flex; flex-direction: column; gap:10px; align-items:center; flex-wrap:wrap; }
  #allButtons button {
    margin: 2px;
    background:#1f2d50;
    border:1px solid rgba(255,255,255,.18);
    border-radius:6px;
    padding:6px 10px;
    cursor:pointer;
  }
  #allButtons button.active {
    background:#2980b9; /* highlight */
    color:#fff;
    width:100%;
  }

  .vertical-buttons { display:block; flex-direction:column; gap:6px; margin-bottom:10px; }
  .vertical-buttons button { width:100%; text-align:center; }

  /* Year group (stacked like your office/race stack) */
  #yearButtons { display:flex; flex-direction:column; gap:6px; margin-bottom:10px; }
  #yearButtons button { width:100%; text-align:center; }
  #yearButtons button.active { background:#2980b9; color:#fff; }
  
  /* Engraved/disabled look for unavailable offices (e.g., P in midterms) */
  #allButtons button[disabled]{
    opacity: .45;
    cursor: not-allowed;
    filter: saturate(.6);
    box-shadow:
      inset 0 2px 0 rgba(255,255,255,.06),
      inset 0 -2px 0 rgba(0,0,0,.35);
    border-color: rgba(255,255,255,.08);
  }

    /* Engraved/disabled look for unavailable years when P is selected */
    #yearButtons button[disabled]{
      opacity: .45;
      cursor: not-allowed;
      filter: saturate(.6);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.06),
        inset 0 -2px 0 rgba(0,0,0,.35);
      border-color: rgba(255,255,255,.08);
    }
    /* stack the map and the button vertically, centered */
    .map-stack{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      width:min(1400px, 82vw);
      height:100%;
    }

    /* the map fills the stack’s height */
    .map-controls{ text-align:center; }

    /* button look (optional, keeps your current style) */
    #zoomOutBtn{
      font-size:18px;
      background:transparent;
      border:0px solid #ccc;
      padding:6px 12px;
      cursor:pointer;
    }
    #raceControls {
      align-items: stretch;
    }#allButtons {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px;
      width: 100%;
    }#allButtons button {
      margin: 0;
    }

    /* Candidate headshot stack */
    .cand-list { display:flex; flex-direction:column; gap:20px; }
    .cand-item { text-align:center; }
    .cand-item img {
      width: auto;
      height: auto;
      max-width: 100%;   /* so it won’t overflow its column */
      max-height: 100%;  /* optional safeguard */
      object-fit: contain;   /* or just remove object-fit */
      border-radius: 0;  /* remove rounding if you want originals */
      border: none;      /* optional: remove the thin border */
    }

    .cand-votes { font: 600 14px/1.2 system-ui, sans-serif; margin-top:6px; }

    .stage { background: transparent; }
    .map-shell { background: transparent; }
    svg { background: transparent; }  /* you already had white here */
    
    .left-panel .body {
      overflow: auto;
      scrollbar-width: none;           /* Firefox */
    }

    
    .left-panel .body::-webkit-scrollbar{ /* Chrome/Safari/Edge */
      display: block;
      width: 10px;                        /* taste */
    }

    /* ---- Responsive tokens ---- */
    :root{
      /* type scales with viewport, but stays readable */
      --text: clamp(14px, 0.95vw, 18px);

      /* header height scales but never silly */
      --header-h: clamp(48px, 6svh, 72px);

      /* outer gap around panels */
      --gap: clamp(8px, 1.6svh, 20px);

      /* left panel width scales with viewport */
      --left-w: clamp(280px, 22vw, 420px);

      /* right rail width */
      --right-w: clamp(56px, 5vw, 96px);

      /* card corners & spacing in rem so they track font-size */
      --radius: 14px;
    }

    /* global type */
    html { font-size: var(--text); }

    /* header uses token instead of fixed px */
    header{
      height: var(--header-h);
      padding: clamp(8px, 1svh, 16px) clamp(12px, 1.6vw, 20px);
    }

    /* stage fills viewport minus header */
    .stage{
      width: 100vw;
      height: calc(100svh - var(--header-h));
    }

    /* map shell stays capped but fluid */
    .map-shell{
      width: min(1400px, 82vw);
      border-radius: var(--radius);
    }

    /* panels float using fluid sizes */
    .left-panel{
      top: calc(var(--header-h) + var(--gap) + var(--left-panel-extra-top));
      bottom: var(--gap);
      left: calc(var(--gap) + 10vw);    /* the “move right 1vw” you wanted */
      width: var(--left-w);
      border-radius: 0;
    }
    .right-panel{
      top: 0;
      bottom: 0vh;
      right: 0vw;
      width: 4.5vw;
      border-radius: 0;
    }

    /* inside panel spacing scales with type */
    .left-panel .body,
    .right-panel .body{
      padding: clamp(8px, 1.2svh, 14px);
    }

    /* icon/thumb sizes scale gently */
    .cand-item img{
      width: clamp(120px, 20vw, 1200px);
      height: clamp(120px, 20vw, 1200px);
      border-radius: clamp(8px, 0.8vw, 12px);
    }

    /* gutters = space reserved for panels */
    :root{
      /* left panel’s x + its width + an extra gap */
      --gutter-left:  calc( (var(--gap) - 0vw) + var(--left-w) + var(--gap) );
      /* right rail width + gap */
      --gutter-right: calc( var(--right-w) + var(--gap) - 1.5vw);
    }

    /* let the stack sit between the gutters */
    .map-stack{
      position: relative;
      width: min(1400px, calc(100vw - var(--gutter-left) - var(--gutter-right)));
      margin-left:  var(--gutter-left);
      margin-right: var(--gutter-right);
      margin-top: 5vh;
      height: calc(100% - 0vh);
     /* margin-bottom: 400px; */
    }

    /* the shell just fills the stack (no extra margins) */
    .map-shell{
      width: 100%;
      margin: 0;
        height: calc(100% - 0px);  /* trims 40px off the bottom */
      }
    
    :root {
      --fade-left: 15%;   /* how wide the left fade is */
      --fade-right: 0%;  /* how wide the right fade is */
      --fade-top: 8%;
    }

    .map-shell{
      /* two masks: 1) left/right  2) top */
      -webkit-mask-image:
        linear-gradient(to right,
          transparent 0,
          black var(--fade-left),
          black calc(100% - var(--fade-right)),
          transparent 100%),
        linear-gradient(to bottom,
          transparent 0,
          black var(--fade-top),
          black 100%);

      mask-image:
        linear-gradient(to right,
          transparent 0,
          black var(--fade-left),
          black calc(100% - var(--fade-right)),
          transparent 100%),
        linear-gradient(to bottom,
          transparent 0,
          black var(--fade-top),
          black 100%);

      /* make the two layers intersect (AND) */
      -webkit-mask-composite: source-in;
      mask-composite: intersect;

      /* size/repeat per layer */
      -webkit-mask-size: 100% 100%, 100% 100%;
      mask-size: 100% 100%, 100% 100%;

      -webkit-mask-repeat: no-repeat, no-repeat;
      mask-repeat: no-repeat, no-repeat;
    }

    /* Headshot card w/ clamped overlay */
    /* Headshot card — clean edges, no borders/shadows */
    .cand-item { position: relative; }

    .cand-card{
      position: relative;           /* overlay’s positioning context */
      display: inline-block;
      width: 100%;
      border: none;                 /* remove placeholder border */
      box-shadow: none;             /* remove drop shadow */
      border-radius: 0px;          /* keep the rounded feel like the mock */
      overflow: hidden;             /* clip to rounded corner */
      box-shadow: 8px -8px 5px .1px rgba(0,0,0,0.15) !important;
    }

    .leadline{
      /* placement */
      margin: 2px 0px 14px auto;   /* closer to leader card (top=4), more space before 2nd (bottom=14) */
      width: fit-content;
      text-align: right;

      /* typography */
      text-transform: uppercase;
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight: 700;
      letter-spacing: .08em;
      line-height: 1;
      font-size: clamp(16px, 1.6vw, 28px);

      /* color & depth */
      color: #6f7a86;               /* a bit darker than before */
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0));
    }


    
    .cand-card img{
      display:block;
      width:100%;
      height:auto;
      border:none;                  /* ensure no image border */
      border-radius: 0 !important;
      box-shadow: 8px -8px 18px rgba(0,0,0,0.35) !important;
    }

    /* Text “clamped” on the image — no black bar */
    /* Overlay lock-up: big digits, small percent, tabular numerals */
    /* Overlay lock-up: bigger digits, smaller %; tabular numerals */
    .cand-overlay{
      position:absolute;
      right:10px;              /* nudge to match the mock */
      bottom:28px;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:8px;
      color:#fff;
      text-align:right;
      text-shadow: 0 1px 2px rgba(0,0,0,.45), 0 0 2px rgba(0,0,0,0.0);
    }

    .cand-overlay .pct{
      display:flex;
      align-items:flex-end;
      gap:2px;
      line-height:.82;
      font-variant-numeric: tabular-nums lining-nums;
      letter-spacing:.1px;
    }

    /* BIG condensed numbers like the mock */
    .cand-overlay .pct .num{
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:700;
      font-size: clamp(36px, 3.0vw, 66px);
    }

    /* Smaller, tucked percent sign */
    .cand-overlay .pct .pct-sign {
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:700;
      font-size: clamp(18px, 2.2vw, 32px);
      transform: translateY(-50%);   /* use % so it scales with font size */
      opacity:.98;
    }


    /* Vote count directly underneath */
    .cand-overlay .votes{
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:600;
      font-variant-numeric: tabular-nums lining-nums;
      letter-spacing:.25px;
      line-height:1;
      font-size: clamp(18px, 2.3vw, 28px);
      opacity:.98;
    }
    
    /* === Candidate name lockup (top-right over the image) === */
    .cand-name {
      position:absolute;
      top:22px;
      right:10px;
      text-align:right;
      text-transform:uppercase;
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height:.9;
      filter: drop-shadow(0 2px 8px rgba(0,0,0,.30)) drop-shadow(0 0 2px rgba(0,0,0,.25));
      pointer-events:none;
      transform: translateY(30%);   /* 👈 manual downward nudge */
    }


    /* smaller first name, bigger last name */
    .cand-name .first{
      font-weight:600;
      letter-spacing:.06em;
      font-size: clamp(18px, 2.0vw, 36px);
      margin-bottom:5px;
    }
    .cand-name .last{
      font-weight:700;
      letter-spacing:.02em;
      font-size: clamp(34px, 2.4vw, 76px);
    }

    /* party-colored text (tweak to your palette) */
    .cand-name.party-REP .first,
    .cand-name.party-REP .last{ color:#d81e1e; }   /* GOP red */
    .cand-name.party-DEM .first,
    .cand-name.party-DEM .last{ color:#0a6fda; }   /* DEM blue */
    .cand-name.party-IND .first,
    .cand-name.party-IND .last{ color:#7a4fc8; }   /* IND/purple */

    .cand-name{ z-index:2; }
    .cand-overlay{ z-index:1; }

    .cand-name{ top:0px; right:10px; }  /* subtle nudge */
    .cand-name .last{ letter-spacing:.015em; }  /* a hair tighter */

    .cand-name .first,
    .cand-name .last {
      color: var(--party-color);
      -webkit-text-stroke: 2px #fff;
      paint-order: stroke fill;

      /* subtle drop shadow similar to the Trump sample */
      text-shadow: 1px 1px 2px rgba(0,0,0,0.0);
    }
    .cand-name .first,
    .cand-name .last {
      text-shadow: none !important;
    }
    /* put this after the existing cand-name styles */

    .cand-name .first,
    .cand-name .last {
      color: var(--party-color);
      -webkit-text-stroke: 2px #fff;
      paint-order: stroke fill;

      /* subtle drop shadow similar to the Trump sample */
      text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
      }

    /* --- Header bands (blue above, red below) --- */
    :root{
      /* if you already set these elsewhere, keep yours */
      --dem: #0067cb;   /* blue */
      --gop: #ec1d19;   /* red  */
      --ind: #8e44ad;
    }
    
    header{
      position: relative;   /* enable pseudo-element positioning */
      overflow: visible;
      margin-top: 2vh;
    }

    /* Use the text itself as the anchor so the bands sit tight to it */
  
    
    
   
    /* Bolt-on fixed box for the 6-star zoom-out */
    .zoom-box{
      position: fixed;         /* ignore parent layout; not clipped by overflow */
      /* pick your position — tweak these to taste */
      bottom: 0px;               /* <— move where you want */
      left: 56vw;              /* <— move where you want */
      z-index: 99999;          /* above everything */
      background: transparent;
      border: 0px solid rgba(255,255,255,.18);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 6px 22px rgba(0,0,0,0);
      pointer-events: auto;    /* clickable */
    }

    /* Optional: kill the old centered behavior if any remains */
    .map-controls{ display:none !important; }

    /* Make the button fill the box nicely */
    .zoom-btn{
      all: unset;
      display: block;
      cursor: pointer;
      font-size: 22px;         /* bigger = bigger stars */
      line-height: 1;
      padding: 6px 4px;
      user-select: none;
      -webkit-text-stroke: 0 !important;
      text-shadow: none !important;
      font-weight: normal;
    }
    .zoom-btn:active{ transform: translateY(0px); }

    /* %IN bolt — anchored under the left panel */
    .percentin-bolt{
      position: fixed;
      /* align x with the left panel */
      left: calc(var(--gap) + 9.65vw);

      /* sit just UNDER the left panel, which ends at bottom: var(--gap) */
      bottom: calc(var(--gap) + 16vh);

      /* optional: match the panel width (keeps the lockup visually tied to it) */
      width: var(--left-w);

      z-index: 100000;
      background: transparent;
      color:#000;
      border: 0;
      border-radius: 12px;
      padding: 6px 0;
      font-family: "Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight: 700;
      letter-spacing: .4px;
      text-transform: uppercase;
      pointer-events: none;  /* purely informational */
      /* keep your current size, or convert to clamp if you prefer */
      font-size: 28px;
    }

    /* keep helpers */
    .percentin-bolt.hidden{ display:none; }
    .percentin-bolt .wrap{
      display:flex;
      align-items: baseline;
      gap: 10px;
      justify-content: flex-end;
      /* optional: use right alignment instead
         text-align: right; justify-content: flex-end; */
    }



    /* Senate national tallies (left panel) */
    .party-tally{
      display:flex; flex-direction:column;
      gap: 90px;               /* space between parties */
      padding: 4px 2px;
    }
    .party-row{ text-align:left; }

    .party-name{
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.06em;
      line-height:1;
      font-size: clamp(28px, 2.6vw, 54px);
      margin-bottom: 6px;
    }

    .party-count{
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:700;
      line-height:.82;
      font-variant-numeric: tabular-nums lining-nums;
      letter-spacing:.02em;
      font-size: clamp(76px, 7.2vw, 148px);
      /* soft, down-right shadow like the comp */
      text-shadow:
        0 2px 0 rgba(0,0,0,.06),
        0 8px 16px rgba(0,0,0,.16);
    }

    /* party colors */
    .party-REP .party-name, .party-REP .party-count { color: var(--gop); }
    .party-DEM .party-name, .party-DEM .party-count { color: var(--dem); }
    /* tweak IND as you like */
    .party-IND .party-name, .party-IND .party-count { color: var(--ind); } /* or a purple/gray */

    /* Horseshoe button look */
    .horseshoe-btn{
      display:flex; align-items:center; justify-content:center; gap:6px;
      width:100%;
      padding:8px 10px;
      border-radius:6px;
      background:#11213d;
      color:#eaf0ff;
      border:1px solid rgba(255,255,255,.18);
      cursor:pointer;
    }
    .horseshoe-btn:hover{ background:#1a2c4d; }
    .bop-mode #bopBtn{ background:#2980b9; color:#fff; }
    .horseshoe-btn .horseshoe-label{ font-weight:700; letter-spacing:.06em; }

    #clearInkBtn { background:#f6e8ea; color:#b00020; border-color:#f0c8cd; }
    #clearInkBtn:hover { background:#f2d9dd; }

    
    /* BOP overlay text centered on stage */
    .bop-overlay{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 100000;     /* above everything */
      background: transparent;
      color:#0a0a0a;
      text-transform: uppercase;
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight: 700;
      letter-spacing: .06em;
      font-size: clamp(40px, 8vw, 140px);
      pointer-events: none;  /* pure display */
    }

    /* When in BOP mode: hide map and left panel, keep right rail visible */
    .bop-mode .map-shell,
    .bop-mode .left-panel { display: none !important; }

    .bop-mode .right-panel { filter: none; } /* stays */

    .bop-overlay[hidden]{ display:none !important; }
    
    .bop-mode #percentInBolt{ display:none !important; }

    .bop-chart{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 100001;      /* just above .bop-overlay text */
      pointer-events: none; /* purely visual */
      margin-top: 50vh;
    }
    .bop-chart[hidden]{ display:none !important; }
    /* Senate horseshoe size */
    .bop-chart.senate svg {
      width: 117vw;   /* smaller/larger as you prefer */
      height: auto;
    }

    /* House horseshoe size */
    .bop-chart.house svg {
      width: 140vw;   /* different scale for House */
      height: auto;
    }
    /* reset the global nudge */
    .bop-chart{ margin-top: 0; }

    /* per-office vertical offsets */
    .bop-chart.senate{ margin-top: 65vh; transform: translateX(-8.5vw); }  /* ↓ move Senate further down */
    .bop-chart.house { margin-top: 90vh; transform: translateX(-20vw); }  /* tweak House independently (optional) */


    .party-row { text-align:left; }
    .party-name  { display:block; margin:0 0 6px; }
    .party-count { display:block; font-size: clamp(88px, 8.6vw, 168px); }

    /* Fixed butted legend strip */
    .legend-strip{
      position: fixed;
      left: 55%;
      bottom: 5.5vh;
      transform: translateX(-30%);
      z-index: 100003;
      display: flex;
      gap: 0;                     /* butt together */
      border-radius: 0px;        /* rounded outer corners */
      overflow: hidden;           /* trims inner corners so blocks meet flush */
      /* box-shadow: 0 4px 18px rgba(0,0,0,.18); */
      pointer-events: none;       /* purely informational */
    }

    /* the whole legend: only space BETWEEN groups */
    .legend-strip{
      display:flex;
      gap: 8px;            /* controls the white space between parties */
      background: #fff;    /* makes the gaps pure white */
    }

    /* each party pair is butted together */
    .legend-group{
      display:flex;
      gap: 0;              /* no space inside a party pair */
      border-radius: 0px;  /* rounded outer corners for the pair */
      overflow: hidden;    /* trims inner edges so they meet flush */
    }

    /* if you previously added borders/shadows as separators, remove them */
    .legend-strip .cell + .cell{
      border-left: 0;
      box-shadow: none;
    }

    
    .bop-mode #statusLegend{
      left: 32.1vw;          /* e.g., park it low-left in BOP */
      bottom: 6vh;
      transform: none;    /* cancel the centering shift */
      gap: 6px;           /* (optional) a bit more spacing in BOP */
    }
    

    .legend-strip .cell{
      padding: 7px 12px;
      font-family: "Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight: 700;
      font-size: clamp(12px, 1.15vw, 16px);
      letter-spacing: .06em;
      text-transform: uppercase;
      color: #fff;
      line-height: 1;
      white-space: nowrap;
    }

    /* subtle vertical separators (optional) */
    .legend-strip{
      gap: 4px;                  /* visible white gaps */
      background: transparent;          /* the gap color */
      padding: 0 0;              /* optional */
    }
    .legend-strip .cell{
      background-clip: padding-box;   /* avoids anti-alias bleed at edges */
      border-left: 0;                 /* no rule when using gaps */
    }


    /* colors */
    .legend-strip .dem     { background: var(--dem); }
    .legend-strip .dem-dim { background: color-mix(in oklab, var(--dem) 55%, white); }

    .legend-strip .rep     { background: var(--gop); }
    .legend-strip .rep-dim { background: color-mix(in oklab, var(--gop) 55%, white); }

    .legend-strip .ind     { background: var(--ind, #4a47a3); }
    .legend-strip .ind-dim { background: color-mix(in oklab, var(--ind, #4a47a3) 55%, white); }

    .legend-strip .novotes { background: #7a7a7a; }

    
    /* BOP-only placement for the 6-star zoom control */
    body.bop-mode .zoom-box{
      left: 43.5vw;          /* pick a BOP position */
      bottom: 0vh;
      transform: none;    /* cancel any centering translate, if added later */
    }

    /* Percent-in lockup (number + % same size; label baseline-aligned) */
    .percentin-bolt .wrap{
      display:flex;
      align-items: baseline;   /* flush along the bottom */
      gap: 10px;
    }

    .percentin-bolt .big{
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:700;
      line-height:.85;
      font-variant-numeric: tabular-nums lining-nums;
      letter-spacing:.02em;
      font-size: clamp(32px, 2.4vw, 72px);  /* big number */
    }

    .percentin-bolt .big .pct-sign{
      font-size: 1em;          /* same size as digits */
      transform: none;         /* no vertical tuck */
      display:inline-block;
      margin-left: 2px;
    }

    .percentin-bolt .label{
      font-family:"Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight:700;
      text-transform: uppercase;
      letter-spacing:.12em;
      line-height:1;
      font-size: clamp(21px, 2.05vw, 28px);  /* small */
      opacity:.95;
    }

    /* Header layout: two rows */
    :root { --header-topline-h: 44px; }
    header{
      display:flex; flex-direction:column;
      height: calc(var(--header-h) + var(--header-topline-h));
      padding:0; background:transparent; border-bottom:none;
    }

    /* Top row */
    .header-topline{
      display:flex; align-items:center; gap:10px;
      padding: 6px var(--header-xpad) 6px var(--header-left-offset);
      font-family: var(--header-font);
      font-weight: 2800;
      text-transform: uppercase;
      letter-spacing: .06em;
      font-size: var(--header-top-size);   /* << added */
    }

    /* bump the logo up slightly relative to the text */
    .header-topline .brand{
      /* your size rules... */
      height: 36px;           /* or whatever you chose */
      width: auto;

      /* vertical nudge */
      transform: translateY(-3px);   /* try -2 to -4px */
    }

    /* make pipes exactly like the text */
    .header-topline .sep{
      opacity: 1;              /* was .55 */
      color: currentColor;     /* inherit the text color */
      font-family: inherit;    /* inherit URWDIN from .header-topline */
      font-weight: inherit;    /* same weight as the text */
      margin: 0 6px;
    }


    /* Location row (the text sits between the blue and red rules) */
    .header-location-wrap{
      position:relative;
      padding: 8px var(--header-xpad) 10px var(--header-left-offset);
    }
    #headerLocation{
      position:relative;
      font-family: var(--header-font);
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: .04em;
      line-height: 1;              /* tighter box so bands can sit closer */
      display: inline-block;
      font-size: var(--header-loc-size);   /* << added */
    }


    /* Expose pill spacing so RESET can match exactly */
    .legend-strip{
      --pill-pad-y: 8px;      /* match your pill's vertical padding */
      --pill-pad-x: 14px;     /* match your pill's horizontal padding */
      --pill-radius: 6px;     /* match your pill radius */
    }

    /* RESET = same font + size as the legend pills */
    .legend-reset{
      display: inline-flex;
      align-items: center;
      padding: var(--pill-pad-y) var(--pill-pad-x);
      border-radius: var(--pill-radius);

      /* inherit the pill typography */
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      line-height: inherit;
      letter-spacing: inherit;
      text-transform: inherit;
    }



    
    
    
    /* The blue line (above) and red line (below) */
    #headerLocation::before,
    #headerLocation::after{
      content:"";
      position:absolute;
      left: 0;                                 /* align with the text */
      right: auto;
      width: clamp(720px, 60vw, 1400px);       /* or 80–90vw if you want longer */
      height: 6px;
    }




    #headerLocation::before{ top:-0.38em;  background: var(--dem, #0067cb); }
    #headerLocation::after { bottom:-0.1em; background: var(--gop, #ec1d19); }

    /* Make the stage subtract the new two-row header height */
    .stage{ height: calc(100svh - (var(--header-h) + var(--header-topline-h))); }

    /* two-row header */
    :root { --header-topline-h: 44px; }
    header{
      display:flex; flex-direction:column;
      height: calc(var(--header-h) + var(--header-topline-h));
      padding: 0 16px;                /* small, even insets */
      background:transparent; border-bottom:none;
    }
    
    :root { --header-xpad: clamp(12px, 1.6vw, 24px); }

    header { padding: 0 var(--header-xpad); }               /* left-justified */
    .header-topline { justify-content: flex-start; }        /* explicit left */
    .header-location-wrap { padding: 8px var(--header-xpad) 10px var(--header-left-offset); }
        /* no extra x-pad */

        #headerLocation::before,
        #headerLocation::after{
          left: 0px;
          right: auto;
          width: clamp(720px, 77.5vw, 1400px);
        }


    /* make both header rows span the viewport */
    .header-topline,
    .header-location-wrap{
      width: 100%;
      justify-content: flex-start; /* be explicit */
    }

    
    :root{
      --header-left-offset: clamp(9.71vw, 2vw, 40px);
    }

    #penBtn.active {
      background:#0b5fff;
      color:#fff;
      border-color:#0b5fff;
    }

    /* Pen ink should never block map interactions */
    #inkLayer .pen-stroke { pointer-events: none; }
    
    
    /* City pills (above the counties, below ink) */
    .city-label { pointer-events: none; filter: drop-shadow(0 1px 2px rgba(0,0,0,.25)); }
    .city-label rect {
      fill: #97adc2;            /* badge fill */
      stroke: #5c7893;          /* hairline border */
      stroke-width: 1;
      rx: 8; ry: 8;             /* rounded pill */
    }
    .city-label text {
      font: 600 12px/1.1 system-ui, sans-serif;
      fill: #fff;
      text-shadow: 0 1px 0 rgba(0,0,0,.15);
    }

    #menuBtn { font-size: 18px; }

    
    
    /* Main menu overlay */
    #mainMenu {
      position: absolute; inset: 0;
      pointer-events: auto;
      z-index: 9999;                 /* above map, header, etc. */
      background: transparent;       /* keep the clean blank background you made */
    }

    /* Icon tiles */
    #mainMenu .menu-item {
      position: absolute;
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      cursor: pointer;
      user-select: none;
      /* responsive sizes */
      width: clamp(220px, 26vw, 380px);
      aspect-ratio: 16 / 11;         /* works well with your rounded badges */
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.15));
      transition: transform .15s ease;
    }


    /* Positions (match your screenshot) */
    #mainMenu .menu-tl { top: 64px;    left: 120px; }
    #mainMenu .menu-tr { top: 64px;    right: 120px; }
    #mainMenu .menu-bl { bottom: 140px; left: 80px; }
    #mainMenu .menu-br { bottom: 140px; right: 80px; }

    /* Center-bottom Exit Polls — wider */
    #mainMenu .menu-center {
      bottom: 36px; left: 50%; transform: translateX(-50%);
      width: clamp(260px, 32vw, 520px);
      aspect-ratio: 10 / 5.5;
    }

    
    /* When menu is open, hide chrome + layout underlay */
    body.menu-mode header,
    body.menu-mode #statusLegend,
    body.menu-mode #zoomBox,
    body.menu-mode .map-shell,
    body.menu-mode .left-panel,
    body.menu-mode .right-panel {
      display: none !important;
    }
    /* Also hide any BOP artifacts & party tallies while in menu */
    body.menu-mode #bopChart,
    body.menu-mode #bopOverlay,
    body.menu-mode .party-tally{
      display: none !important;
    }

    /* Path mode — hide map and left panel; keep right rail visible */
    .path-mode .map-shell,
    .path-mode .left-panel { display: none !important; }

    /* If PATH is on, suppress any BOP artifacts just in case */
    .path-mode #bopChart,
    .path-mode #bopOverlay,
    .path-mode #percentInBolt { display: none !important; }
    
    /* Path mode */
    .path-mode .left-panel { display: none !important; }

    /* Make sure the map remains visible in path mode */
    .path-mode .map-shell { display: block !important; }

    /* Extra safety: kill any BOP UI while in path mode */
    .path-mode #bopChart,
    .path-mode #bopOverlay,
    .path-mode #percentInBolt { display: none !important; }

    .path-mode .left-panel { display: none !important; }
    .path-mode .map-shell  { display: block !important; }

    .path-mode #bopChart,
    .path-mode #bopOverlay,
    .path-mode #percentInBolt { display: none !important; }
    
    body.path-mode #map {
      touch-action: none;
      overscroll-behavior: contain;
      cursor: default;
    }

    /* ---------- Path Panel ---------- */
    #pathPanel {
      position: absolute;
      left: 10vw;
      top: var(--left-panel-top, 84px);
      width: 380px;
      padding: 16px 14px 18px;
      background: transparent;          /* same dark as your app */
      border-right: 1px solid rgba(255,255,255,.08);
      display: none;                 /* shown only in path-mode */
      z-index: 50;
    }

    body.path-mode #pathPanel { display: block; }
    body.path-mode #leftPanel { display: none !important; }  /* keep old panel hidden in Path */

    .path-cards {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .path-card {
      background: transparent;
      border-radius: 0px;
      padding: 0;                         /* ← no inner padding so the image’s left edge is true */
      margin: 0;           /* ← keep the breathing room externally */
      box-shadow: 0 1px 0 rgba(255,255,255,.06) inset, 0 8px 24px rgba(0,0,0,.35);
      text-align: center;
    }

    /* Make both rows (headshots and barrels) left-align inside their grid cells */
    .path-cards,
    .path-ev-wrap { justify-items: start; }

    /* Barrels: don’t center with auto margins; let them sit flush left like the headshots */
    #pathPanel .ev-column{
        margin: 0;                    /* ← drop the auto centering */
      justify-self: start;
    }


    .path-card .headshot {
      width: 100%;
      aspect-ratio: 7/8;
      object-fit: cover;
      border-radius: 0px;
      background: transparent;
      display: block;
    }

    .path-card .name {
      margin-top: 8px;
      font-weight: 800;
      letter-spacing: .6px;
      font-size: 12px;
      text-transform: uppercase;
      opacity: .9;
    }

    .path-ev-wrap {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: end;
      margin-top: 14px;
    }

    .ev-column {
      background: #E0E0E0;           /* grey trough */
      border-radius: 0px;
      height: 30vh;                  /* adjust as you like */
      position: relative;
      overflow: hidden;
      display: grid;
      align-items: end;
    }

    .ev-fill {
      width: 100%;
      height: 0%;
      background: #999;               /* default, overridden by side */
      transition: height .25s ease-out;
    }

    .ev-readout {
      position: absolute;
      left: 0; right: 0;
      bottom: 8px;
      font-size: 28px;
      font-weight: 900;
      text-align: center;
      text-shadow: 0 2px 6px rgba(0,0,0,.45);
      color: #fff;
    }

    .ev-center {
      display: grid;
      place-items: center;
      height: 180px;
      grid-column: 1 / -1;    /* span both columns */
       grid-row: 1;
        place-self: center;
        z-index: 2;
        pointer-events: none;   /* optional: don’t block clicks */
    }

    .ev-center .to-win {
      font-size: 12px;
      letter-spacing: .4px;
      text-transform: uppercase;
      opacity: .7;
      margin-bottom: 6px;
    }

    .ev-center .target {
      font-size: 22px;
      font-weight: 800;
      padding: 4px 10px;
      border-radius: 999px;
      background: #1c2028;
      box-shadow: 0 1px 0 rgba(255,255,255,.0) inset;
    }

    /* party tints (use your existing vars if you have them) */
    .ev-column.dem .ev-fill { background: var(--dem-solid, #2576ff); }
    .ev-column.rep .ev-fill { background: var(--gop-solid, #d64545); }

    .path-card.dem .name { color: var(--dem-solid, #8fb8ff); }
    .path-card.rep .name { color: var(--gop-solid, #ff9f9f); }

    /* nudge both headshots a bit to the right */
    .candidate-card .photo img {
      object-fit: cover;          /* likely already set */
      object-position: 60% 50%;   /* 50% is center; 60% pushes the crop right */
      /* tweak 55–65% to taste */
    }
    
    /* Path mode: shift headshots a bit to the right (no effect elsewhere) */
    body.path-mode .path-card .headshot {
      object-fit: cover;        /* already set, keep it */
      object-position: 0% 50%; /* tweak 55–65% to taste */
    }

    
    /* ===== Path mode: image-only candidate card ===== */
    body.path-mode .path-card,
    body.path-mode .path-card *::before,
    body.path-mode .path-card *::after {
      background: transparent !important;
      box-shadow: none !important;
    }

    /* hide any inner plates/badges/labels inside the card */
    body.path-mode .path-card .name,
    body.path-mode .path-card .plate,
    body.path-mode .path-card .badge,
    body.path-mode .path-card .footer,
    body.path-mode .path-card .chrome,
    body.path-mode .path-card .card-bg {
      display: none !important;
    }

    /* keep only the photo with a thin party border */
    body.path-mode .path-card .photo,
    body.path-mode .path-card .headshot,
    body.path-mode .path-card img.headshot {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: transparent !important;      /* no white fill */
      border-radius: 0px;                      /* match your card radius */
      border: 2px solid var(--party-stroke);    /* thin colored frame */
    }

    /* if the image sits in a wrapper, make the wrapper transparent too */
    body.path-mode .path-card .photo-wrapper,
    body.path-mode .path-card .image-frame {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }

    /* Path mode: no center pill/number */
    body.path-mode .ev-center { background: transparent !important; }
    body.path-mode .ev-center > * { display: none !important; }

    /* Path brush: subtle light border around the armed pill */
    .legend-strip .cell.brush {
      position: relative;                 /* ensure the pseudo-border anchors correctly */
      box-shadow: 0 0 0 3px var(--brush-color);  /* outer border without shifting layout */
    }

    /* Light party tints for the border (no change to the pill's fill) */
    .legend-strip .cell.dem.brush,
    .legend-strip .cell.dem-dim.brush { --brush-color: #aecdff; }   /* light blue */

    .legend-strip .cell.rep.brush,
    .legend-strip .cell.rep-dim.brush { --brush-color: #ffc1c1; }   /* light red */

    .legend-strip .cell.ind.brush,
    .legend-strip .cell.ind-dim.brush { --brush-color: #d9ccff; }   /* light purple */

    /* Utility to fully hide a legend cell */
    .legend-strip .cell.is-hidden { display: none !important; }


    /* Legend is clickable when in Path mode (for brush) */
    .path-mode .legend-strip { pointer-events: auto !important; }
    .path-mode .legend-strip .cell { cursor: pointer; }

    /* Path RESET pill (transparent, black border/text) */
    .legend-reset {
      display: none;                 /* hidden by default */
      border: 1px solid #000;
      color: #000;
      background: transparent;
      padding: 6px 10px;
      font-family: "Oswald", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight: 700;
      letter-spacing: .06em;
      text-transform: uppercase;
      line-height: 1;
      border-radius: 0px;
      cursor: pointer;
    }

    /* Show it only in Path mode, alongside clickable legend pills */
    .path-mode .legend-reset { display: inline-block; }

    /* Keep RESET pill identical on hover/focus/active */
    .legend-reset,
    .legend-reset:hover,
    .legend-reset:focus,
    .legend-reset:active {
      background: transparent !important;
      color: #000 !important;
      border-color: #000 !important;
      box-shadow: none !important;
      filter: none !important;
      transform: none !important;
      text-decoration: none !important;
      transition: none !important;
      outline: none; /* remove if you want a focus ring */
    }

    
    /* Path mode: make the TOSSUP pill (left IND cell) yellow */
    .path-mode .legend-strip .cell.ind {
      background-color: #f2c744 !important; /* warm yellow */
      color: #fff;                           /* keep pill text white */
    }

    /* If you use the brush ring, tint it to a soft yellow in Path mode */
    .path-mode .legend-strip .cell.ind.brush::after {
      --brush-ring: #fff3b0; /* light yellow ring */
    }
    
    /* ME split tickers */
    .me-tickers{ display:none; gap:10px; align-items:center; margin-left:12px; }
    .path-mode .me-tickers{ display:inline-flex; }
    .me-ticker{ display:inline-flex; align-items:center; border:1px solid #000; border-radius:0; overflow:hidden; font:inherit; color:#000; background:transparent; }
    .me-ticker .lbl{ padding:6px 8px; }
    .me-ticker .btn{ border:0; background:transparent; padding:6px 10px; font-weight:700; cursor:pointer; }
    .me-ticker .count{ padding:6px 10px; border-left:2px solid #000; border-right:2px solid #000; min-width:1.5em; text-align:center; }
    .me-ticker .btn:hover, .me-ticker .btn:focus, .me-ticker .btn:active{ background:transparent; box-shadow:none; }


    /* NE split tickers */
    .ne-tickers{
      display:none;                 /* only show in Path mode */
      gap:10px;
      align-items:center;
      margin-left:12px;
    }
    .path-mode .ne-tickers{ display:inline-flex; }

    .ne-ticker{
      display:inline-flex;
      align-items:center;
      border: 1px solid #000;
      border-radius: 0px;
      overflow:hidden;
      font: inherit;                /* match pill typography */
      color:#000;
      background:transparent;
    }

    .ne-ticker .lbl{ padding:6px 8px; }
    .ne-ticker .btn{
      border:0;
      background:transparent;
      padding:6px 10px;
      font-weight:700;
      cursor:pointer;
    }
    .ne-ticker .count{
      padding:6px 10px;
      border-left:2px solid #000;
      border-right:2px solid #000;
      min-width:1.5em;
      text-align:center;
    }

    /* kill hover effects if you have globals */
    .ne-ticker .btn:hover,
    .ne-ticker .btn:focus,
    .ne-ticker .btn:active{ background:transparent; box-shadow:none; }

    /* Two-column legend layout */
    .path-mode #statusLegend{
      display:flex;
      align-items:center;
      justify-content:space-between;   /* left cluster ←→ right block */
      flex-wrap:nowrap;                /* left stays one row */
      width: min(92vw, 1280px);        /* keep it tidy */
    }

    /* Left cluster (existing pills + RESET) */
    .legend-left{
      display:flex;
      align-items:center;
      gap:8px;                         /* gap between party groups + RESET */
    }

    /* Right block = two rows (NE above ME), aligned to the right edge */
    .split-tickers-wrap{
      display:flex;
      flex-direction:column;           /* force 2 lines */
      align-items:flex-end;            /* right-aligned block */
      gap:10px;                        /* space between NE row and ME row */
      margin-left:24px;                /* breathing room from the pills */
    }

    /* Each state's row keeps its two mini-tickers on a single line */
    .split-tickers-wrap .ne-tickers,
    .split-tickers-wrap .me-tickers{
      display:inline-flex !important;
      gap:10px;
    }

    /* Keep RESET beside the pills; hover already neutralized elsewhere */
    .legend-reset{ margin-left:8px; }

    /* Move the entire legend closer to the bottom in Path mode */
    .path-mode #statusLegend{
      bottom: 1.6vh;           /* was ~5.5vh; smaller = lower on screen */
    }

    /* If you want the right tickers block nudged a hair lower than the pills */
    .path-mode #statusLegend .split-tickers-wrap{
      transform: translateY(6px);
      transform: translatex(-25vw);
    }

    /* Optional: tiny screens — sit right on the bottom edge */
    @media (max-height: 700px){
      .path-mode #statusLegend{ bottom: 0.6vh; }
    }

    /* Party colors for ME/NE split tickers */
    #neDem, #meDem{
      background: transparent;          /* blue */
      color:#000;
      border-color: var(--dem);
    }
    #neRep, #meRep{
      background: transparent;           /* red */
      color:#000;
      border-color: var(--gop);
    }

    /* Keep inner pieces readable on colored pills */
    #neDem .count, #meDem .count,
    #neRep .count, #meRep .count{
      border-left:2px solid rgba(255,255,255,.45);
      border-right:2px solid rgba(255,255,255,.45);
    }
    #neDem .btn, #meDem .btn,
    #neRep .btn, #meRep .btn{
      color:#fff;                       /* +/- inherits white */
    }
    #neDem .btn:hover, #meDem .btn:hover,
    #neRep .btn:hover, #meRep .btn:hover{
      background: rgba(255,255,255,.08); /* subtle hover without changing color */
    }

    /* Ticker fixes: make separators and +/- pure black */
    .ne-ticker .count,
    .me-ticker .count{
      border-left: 1px solid #000 !important;
      border-right: 1px solid #000 !important;
    }

    .ne-ticker .btn,
    .me-ticker .btn{
      color: #000 !important;
      background: transparent !important;
      filter: none !important;
      text-shadow: none !important;
    }

    /* If any faint white comes from a parent color, force the row to black text */
    .ne-tickers, .me-tickers { color: #000 !important; }

    /* Hide the right ticker block unless we're in Path mode */
    .split-tickers-wrap { display: none; }
    .path-mode .split-tickers-wrap { display: flex; }

    /* Tickers themselves already default to display:none and
       become inline-flex in .path-mode via your existing rules */

    /* NON-Path layout: pack the pills tightly and ignore the right stack */
    :not(.path-mode) #statusLegend{
      justify-content: flex-start;   /* cancel any space-between */
      gap: 4px;                      /* small gap between groups */
    }

    :not(.path-mode) #statusLegend .legend-left{
      display: flex;
      align-items: center;
      gap: 4px;                      /* tighten group spacing */
    }

    :not(.path-mode) #statusLegend .legend-group{
      margin: 0;                     /* no stray margins */
    }

    :not(.path-mode) #statusLegend .legend-group .cell{
      margin: 0;                     /* no stray margins on pills */
    }

    /* Hide the ticker block only when NOT in Path */
    :not(.path-mode) #statusLegend .split-tickers-wrap{
      display: none !important;
    }

    /* Keep Path layout exactly as before (left pills + right two-line tickers) */
    .path-mode #statusLegend{
      justify-content: space-between;
    }
    /* Path: force the right-hand NE/ME block to show */
    .path-mode #statusLegend .split-tickers-wrap{
      display: flex !important;      /* wins over the non-Path 'display:none' */
      flex-direction: column;        /* NE row, then ME row */
      align-items: flex-end;
      gap: 10px;
    }

    /* Path: legend stays clickable (your pills & tickers) */
    .path-mode #statusLegend{ justify-content: space-between; }
    .path-mode .legend-strip{ pointer-events: auto !important; }

    /* Optional: give the whole legend a fixed width & keep it centered low */
    .path-mode #statusLegend{
      width: min(92vw, 1280px);
      left: 80%;
      transform: translateX(-50%);
      bottom: 1.6vh;                 /* nudge lower if you like */
    }

    /* Nudge ONLY the tickers block left in Path mode */
    .path-mode #statusLegend .split-tickers-wrap{
      margin-right: calc(var(--right-w, 96px) + 17px); /* tweak the +12px as needed */
    }

    /* If you don't want it tied to --right-w, use a fixed nudge instead: */
    /* .path-mode #statusLegend .split-tickers-wrap{ margin-right: 28px; } */

    /* Path: use square headshots when we’re in Path mode */
    body.path-mode .path-card .headshot{
      aspect-ratio: 1 / 1;        /* square frame for -square.png art */
      object-position: 50% 50%;
    }

    /* Use the PNG as the barrel chrome */
    /* Barrel wrapper: just a box that clips the top if needed */
    /* Barrel wrapper: width set from JS; height derived from that width */
    #pathPanel .ev-column{
      position:relative;
      overflow:hidden;
      width: var(--bar-w, 220px);
      height: var(--bar-h, 352px);   /* JS will set this from the PNG’s true aspect */
    }

    /* The actual grey-bar artwork */
    #pathPanel .ev-column .ev-chrome{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;        /* was auto → causes mismatch */
      object-fit:contain; /* preserve the PNG aspect inside the box */
      z-index:1;
      pointer-events:none;
    }



    /* Make the colored fill use the exact PNG silhouette as a mask */
    #pathPanel .ev-column .ev-fill{
      position: absolute; left: 0; right: 0; bottom: 0;
    }

    /* Barrel width comes from a CSS var we set in JS */
    #pathPanel .ev-column{
      width: var(--bar-w, auto);
      margin: 12px auto 0;   /* centers under the headshot */
    }
    #pathPanel .ev-column .ev-chrome{
      width: 100%;
      height: auto;
    }
    #pathPanel .path-cards,
    #pathPanel .path-ev-wrap{
      padding-left: 0;
      justify-items: start; /* you already set this earlier */
    }
    /* add or replace existing rule */
    #pathPanel .path-ev-wrap{
      margin-top: 16px;          /* ← the only vertical gap between headshots & barrels */
      justify-items: start;      /* keep left edges aligned */
    }

    /* add */
    #pathHeadDEM,
    #pathHeadREP{
      display:block;   /* removes tiny baseline whitespace under images */
    }
    /* make sure cards don’t push extra space */
    .path-card{
      padding: 0;
      margin: 0;                 /* no bottom margin */
    }

    /* PATH: remove the 180px spacer that’s pushing barrels down */
    .path-mode #pathPanel .ev-center{
      display: none !important;    /* was consuming grid height */
    }

    /* tighten the barrel block spacing */
    #pathPanel .path-ev-wrap{
      margin-top: 6px !important;  /* was 14–16px in places */
    }

    /* drop the extra top margin on each barrel column */
    #pathPanel .ev-column{
      margin-top: 40px !important;    /* was 12px auto 0 */
    }

    /* PATH EV fill — sits on top of the grey barrel and is clipped to its exact shape */
    #pathPanel .ev-column{ position:relative; }

    /* keep this block you added, but add the two lines marked ⬅️ and the !important */
    #pathPanel .ev-column .ev-fill{
      position:absolute;
      inset:0;
      z-index:2;
      -webkit-mask-image: url("../images/grey-bar.png");
              mask-image: url("../images/grey-bar.png");
      -webkit-mask-size: 100% 100%;
              mask-size: 100% 100%;
      -webkit-mask-repeat: no-repeat;
              mask-repeat: no-repeat;
      -webkit-mask-position: bottom center;
              mask-position: bottom center;
      background: transparent !important;
    }

    /* the rising “ink” */
    #pathPanel .ev-column .ev-fill::before{
      content:"";
      position:absolute; left:0; right:0; bottom:0;
      height: var(--h, 0%);     /* set from JS */
      background: currentColor; /* DEM/REP color */
    }


    #pathPanel .ev-column.dem{ color: var(--dem-solid, #2576ff); }
    #pathPanel .ev-column.rep{ color: var(--gop-solid, #d64545); }

    /* Keep the chrome and the number above the color */
    #pathPanel .ev-column .ev-chrome{
      position:absolute;
      left:0; right:0; bottom:0;
      width:100%;
      height:auto;
      z-index:1;          /* was above the fill; move it below */
      pointer-events:none;
    }

    #pathPanel .ev-column .ev-readout{ z-index:3; }
    /* override the earlier base */
    #pathPanel .ev-column .ev-fill{
      background: transparent !important;   /* hide the old grey */
    }

    /* Ensure the mask container has a definite height equal to the barrel box */
    #pathPanel .ev-column .ev-fill{
      position:absolute;
      inset:0;                 /* top/left/right/bottom = 0 */
      height:100%;             /* <-- critical so the ::before % height can resolve */
      z-index:2;

      -webkit-mask-image: url("../images/grey-bar.png");
              mask-image: url("../images/grey-bar.png");
      -webkit-mask-size: 100% 100%;
              mask-size: 100% 100%;
      -webkit-mask-repeat: no-repeat;
              mask-repeat: no-repeat;
      -webkit-mask-position: bottom center;
              mask-position: bottom center;

      background: transparent !important;
    }
    #pathPanel .ev-column .ev-fill::before{
      content:"";
      position:absolute; left:0; right:0; bottom:0;
      height: var(--h, 0%);     /* now % works because parent has height:100% */
      background: currentColor; /* DEM/REP via .ev-column color */
    }

    /* Remove the grey tray behind the masked fill */
    #pathPanel .ev-column{
      background: transparent !important;   /* kill the column’s grey */
    }

    /* Keep the silhouette from the MASK, not the PNG */
    #pathPanel .ev-column .ev-chrome{
      z-index: 1;            /* under the color */
      opacity: .65 !important;   /* was 0 */
      mix-blend-mode: multiply;  /* optional: helps it feel “printed” */
      pointer-events: none;
    }
    
    #pathPanel .ev-column .ev-fill{ z-index: 2; }

    /* Smooth rise/fall of the ink inside the barrel */
    #pathPanel .ev-column .ev-fill::before{
      transition: height var(--ev-dur, .45s) var(--ev-ease, cubic-bezier(.22,.7,.2,1));
      will-change: height;
    }

    /* EV readout hugs the top of the fill (a few px *inside* the color) */
    #pathPanel .ev-column .ev-readout{
      position:absolute;
      left:0; right:0;
      bottom: var(--readout-bottom, 8px);  /* set from JS */
      color:#fff;
      text-shadow: 0 2px 6px rgba(0,0,0,.45);
      z-index:3;
      pointer-events:none;
    }
    /* Smoothly animate the readout as the fill moves */
    #pathPanel .ev-column .ev-readout{
      transition: bottom var(--ev-num-dur, .55s)
                  var(--ev-num-ease, cubic-bezier(.22,.7,.2,1));
    }

    /* Bigger EV number that scales with barrel width */
    /* Much larger EV number */
    #pathPanel .ev-column .ev-readout{
      font-weight: 900;
      font-size: clamp(40px, calc(var(--bar-w, 220px) * 0.26), 120px);
      letter-spacing: .8px;
      line-height: 1;
    }


</style>

</head>
<body>
    <header>
      <!-- Top line: logo | year | race -->
      <div class="header-topline">
        <img class="brand" src="../images/NTD_NEWS_HORIZONTAL_LOGO-2.png" alt="NTD News" />
        <span class="sep">|</span>
        <span id="headerYear"></span>
        <span class="sep">|</span>
        <span id="headerRace"></span>
      </div>

      <!-- Location line with blue (above) and red (below) rules -->
      <div class="header-location-wrap">
        <div id="headerLocation"></div>
      </div>
    </header>


  
  
  <!-- Race selectors (below header, left) -->
  <div class="stage">
    <!-- NEW: stack keeps button under the map -->
    <div class="map-stack">
      <div class="map-shell">
        <svg id="map">
          <defs>
            <filter id="outerShadow" x="-100%" y="-100%" width="300%" height="300%">
              <feMorphology in="SourceAlpha" operator="dilate" radius="4" result="dilated"/>
              <feGaussianBlur in="dilated" stdDeviation="18" result="blurred"/>
              <feComposite in="blurred" in2="SourceAlpha" operator="out" result="outer"/>
              <feColorMatrix in="outer" type="matrix"
                values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 .85 0" result="shadow"/>
              <feComponentTransfer in="shadow" result="shadowCurved">
                <feFuncA type="gamma" amplitude="1" exponent="1.8" offset="0"/>
              </feComponentTransfer>
              <feMerge><feMergeNode in="shadowCurved"/></feMerge>
            </filter>
          </defs>
          
        </svg>
      </div>
    </div>


    <aside class="left-panel">
      <div class="body">
        <div id="countyInfo"></div>
      </div>
    </aside>

    <!-- Path mode panel (hidden unless body.path-mode) -->
    <aside id="pathPanel" aria-label="Path mode leader board">
      <div class="path-cards">
        <div class="path-card dem">
          <img id="pathHeadDEM" class="headshot" alt="JB Pritzker" src="">
          <div class="name">PRITZKER</div>
        </div>
        <div class="path-card rep">
          <img id="pathHeadREP" class="headshot" alt="JD Vance" src="">
          <div class="name">VANCE</div>
        </div>
      </div>

      <div class="path-ev-wrap">
        <div class="ev-column dem" aria-label="Democratic electoral votes">
            <img class="ev-chrome" src="../images/grey-bar.png" alt="">
          <div class="ev-fill" id="evFillDEM"></div>
          <div class="ev-readout" id="evReadDEM">0</div>
        </div>
        <div class="ev-center">
          <div class="to-win">to win</div>
          <div class="target" id="evTarget">270</div>
        </div>
        <div class="ev-column rep" aria-label="Republican electoral votes">
            <img class="ev-chrome" src="../images/grey-bar.png" alt="">
          <div class="ev-fill" id="evFillREP"></div>
          <div class="ev-readout" id="evReadREP">0</div>
        </div>
      </div>
    </aside>


    <!-- Right: Office/Race controls (high z) -->

  </div>

  <aside class="right-panel">
    <div class="body">
        <div id="yearButtons" class="vertical-buttons">
          <button data-year="2026" class="active">2026</button>
          <button data-year="2024">2024</button>
          <button data-year="2022">2022</button>
          <button data-year="2020">2020</button>
          <button data-year="2018">2018</button>
          <button data-year="2016">2016</button>
        </div>

      <div id="raceControls">
          <div id="allButtons" class="vertical-buttons">
            <button id="pathBtn" class="horseshoe-btn" title="Path mode">PATH</button>
            <button data-office="P" class="active">P</button>
            <button data-office="S">S</button>
            <button data-office="G">G</button>
            <button data-office="H">H</button>

            <button data-race="G" class="active">GEN</button>
            <button data-race="D">DEM</button>
            <button data-race="R">GOP</button>
            <button id="menuBtn" class="horseshoe-btn" title="Menu / Clear">
              <span class="horseshoe-label">☰</span>
            </button>
            <!-- Balance of Power (horseshoe) -->
            <button id="bopBtn" class="horseshoe-btn" title="Balance of Power (S/H)">
              <!-- simple horseshoe glyph (inline SVG so it looks like an icon) -->
              <svg viewBox="0 0 64 64" width="22" height="16" aria-hidden="true" style="vertical-align:middle;">
                <path d="M32 6
                         a20 20 0 0 0 -20 20
                         v6 a6 6 0 0 0 12 0 v-6
                         a8 8 0 0 1 16 0 v6
                         a6 6 0 0 0 12 0 v-6
                         a20 20 0 0 0 -20 -20Z"
                      fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
              </svg>
            </button>
            <!-- NEW Pen button directly under BOP -->
            <button id="penBtn" class="horseshoe-btn">
              <span class="horseshoe-label">✏️</span>
            </button>
            <button id="clearInkBtn" class="horseshoe-btn">
              <span class="horseshoe-label">🧽</span>
            </button>


          </div>





        <div class="kv" id="activeCombo" style="opacity:.85;"></div>
      </div>
    </div>
  </aside>
  
    <!-- Fixed “bolt-on” zoom box -->
    <div class="zoom-box" id="zoomBox">
      <button id="zoomOutBtn" title="Go up one level" class="zoom-btn">
        <span style="color:blue;">★ ★ ★</span>
        <span style="color:red;">★ ★ ★</span>
      </button>
    </div>

    
    <div id="percentInBolt" class="percentin-bolt hidden" aria-live="polite"></div>

    <div id="statusLegend" class="legend-strip" aria-live="polite">
      <span class="legend-group">
        <span class="cell dem">DEM</span>
        <span class="cell dem-dim">LEADING DEM</span>
      </span>

      <span class="legend-group">
        <span class="cell rep">REP</span>
        <span class="cell rep-dim">LEADING REP</span>
      </span>

      <span class="legend-group">
        <span class="cell ind">IND</span>
        <span class="cell ind-dim">LEADING IND</span>
      </span>
    </div>

    
    <!-- Balance-of-Power overlay (hidden until BOP mode) -->
    <div id="bopOverlay" class="bop-overlay" aria-live="polite" hidden></div>

    <!-- Balance-of-Power horseshoe chart (shown only in BOP + H 2026) -->
    <div id="bopChart" class="bop-chart" hidden></div>

    
    
<script>
    


    
    // ----- Path brush (click pills to "arm" a color) -----
    let PATH_BRUSH = null; // 'DEM' | 'REP' | 'TOSSUP' | null

    function setPathBrush(party){
      PATH_BRUSH = party;                 // may be null to clear
      updateLegendBrushUI();
    }

    function updateLegendBrushUI(){
      const root = document.getElementById('statusLegend');
      if (!root) return;
      root.querySelectorAll('.cell').forEach(c => c.classList.remove('brush'));

      if (PATH_BRUSH === 'DEM'){
        root.querySelector('.cell.dem')?.classList.add('brush');
        root.querySelector('.cell.dem-dim')?.classList.add('brush');
      } else if (PATH_BRUSH === 'REP'){
        root.querySelector('.cell.rep')?.classList.add('brush');
        root.querySelector('.cell.rep-dim')?.classList.add('brush');
      } else if (PATH_BRUSH === 'TOSSUP'){
        root.querySelector('.cell.ind')?.classList.add('brush');
        root.querySelector('.cell.ind-dim')?.classList.add('brush');
      }
    }

    function wireLegendForPathBrush(enable){
      const root = document.getElementById('statusLegend');
      root.style.pointerEvents = enable ? 'auto' : '';

      if (!root) return;

      const wiring = [
        { sel: '.cell.dem',     party:'DEM' },
        { sel: '.cell.dem-dim', party:'DEM' },
        { sel: '.cell.rep',     party:'REP' },
        { sel: '.cell.rep-dim', party:'REP' },
        { sel: '.cell.ind',     party:'TOSSUP' } // ← left pill now arms Tossup
        // .cell.ind-dim is hidden in Path mode
      ];


      wiring.forEach(({sel, party})=>{
        const el = root.querySelector(sel);
        if (!el) return;
        // store handler so we can remove it cleanly
        if (enable){
          el.style.cursor = 'pointer';
          const h = (e)=>{ e.preventDefault(); e.stopPropagation(); setPathBrush(party); };
          el.addEventListener('click', h);
          el.__brushHandler = h;
        } else if (el.__brushHandler){
          el.style.cursor = '';
          el.removeEventListener('click', el.__brushHandler);
          delete el.__brushHandler;
        }
      });

      if (!enable) setPathBrush(null);
    }

    
    // ----- Path state picks & colors -----
    // ----- Path state picks & preset -----
    let PATH_STATE_ASSIGN = {};   // live, mutable in-session map

    // Paste your preset here (USPS -> 'DEM' | 'REP' | 'TOSSUP')
    // Replace your PATH_PRESET_ASSIGN with this:
    const PATH_PRESET_ASSIGN = {
      AL:'REP', AK:'REP', AZ:'TOSSUP', AR:'REP', CA:'DEM', CO:'DEM', CT:'DEM', DE:'DEM', DC:'DEM',
      FL:'REP', GA:'TOSSUP', HI:'DEM', ID:'REP', IL:'DEM', IN:'REP', IA:'REP', KS:'REP', KY:'REP',
      LA:'REP', ME:'DEM', MD:'DEM', MA:'DEM', MI:'TOSSUP', MN:'DEM', MS:'REP', MO:'REP', MT:'REP',
      NE:'REP', NV:'TOSSUP', NH:'DEM', NJ:'DEM', NM:'DEM', NY:'DEM', NC:'TOSSUP', ND:'REP', OH:'REP',
      OK:'REP', OR:'DEM', PA:'TOSSUP', RI:'DEM', SC:'REP', SD:'REP', TN:'REP', TX:'REP', UT:'REP',
      VT:'DEM', VA:'DEM', WA:'DEM', WV:'REP', WI:'TOSSUP', WY:'REP'
    };


    // Normalize + apply the preset once (or on demand with force=true)
    // Normalize + apply the preset (clone, don't alias). Force = always reset.
    function applyPathPreset(force = false){
      if (!force && window._pathPresetApplied) return;
      const next = {};
      for (const [usps, raw] of Object.entries(PATH_PRESET_ASSIGN)){
        const v = String(raw || '').toUpperCase();
        if (v === 'DEM' || v === 'REP' || v === 'TOSSUP') next[usps] = v;
      }
      PATH_STATE_ASSIGN = next;              // ← new object each time
      window._pathPresetApplied = true;
    }



    const PATH_COLOR_DEM    = getCssVar?.('--dem-solid') || '#2576ff';
    const PATH_COLOR_REP    = getCssVar?.('--gop-solid') || '#d64545';
    const PATH_COLOR_TOSSUP = '#f1c40f';      // yellow
    const PATH_COLOR_NEUTRAL= '#ffffff';      // base/neutral

    function getCssVar(name){
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      return v && v.trim() ? v.trim() : null;
    }

    // map feature -> USPS (reuses your mapping)
    function uspsFromFeature(d){
      return d.usps || d.properties?.usps || d.properties?.STUSPS ||
             USPS_BY_STATEFP?.[String(d.id).padStart(2,'0')];
    }

    // paint helper
    function paintPathState(sel, choice){
      let fill = PATH_COLOR_NEUTRAL;
      if (choice === 'DEM')    fill = PATH_COLOR_DEM;
      else if (choice === 'REP')    fill = PATH_COLOR_REP;
      else if (choice === 'TOSSUP') fill = PATH_COLOR_TOSSUP;
      sel.attr('fill', fill);
    }

    
    function syncBarrelWidths(){
      const panel = document.querySelector('#pathPanel');
      if (!panel) return;

      const pairs = [
        panel.querySelector('.ev-column.dem'),
        panel.querySelector('.ev-column.rep')
      ].filter(Boolean);

      for (const col of pairs){
        // width = width of the matching headshot card (unchanged logic)
        const card = col.closest('#pathPanel')?.querySelector(
          col.classList.contains('dem') ? '#pathHeadDEM' : '#pathHeadREP'
        )?.closest('.path-card');

        const w = card?.getBoundingClientRect().width || col.getBoundingClientRect().width || 0;

        // get the rendered aspect from the actual chrome image
        const chrome = col.querySelector('.ev-chrome');
        let ar = 1.6; // fallback
        if (chrome && chrome.naturalWidth && chrome.naturalHeight) {
          ar = chrome.naturalHeight / chrome.naturalWidth;  // true PNG aspect
        }
        const h = Math.max(1, Math.round(w * ar));

        col.style.setProperty('--bar-w', `${w}px`);
        col.style.setProperty('--bar-h', `${h}px`);
        requestAnimationFrame(repositionReadouts);
      }
    }




    // recompute EVs from current picks (ME/NE treated statewide here)
    // --- EV helpers -------------------------------------------------------------
    function getStateEV(usps){
      // Prefer your canonical map if present, otherwise fall back to any alt maps,
      // and finally 0 (so we never NaN the totals).
      return (window.ELECTORAL_VOTES && ELECTORAL_VOTES[usps])
          ?? (window.EV_BY_USPS && EV_BY_USPS[usps])
          ?? (typeof stateEv === 'function' ? stateEv(usps) : 0);
    }

    // --- Path: recompute EVs (DEM / REP / TOSSUP) -------------------------------
    function recomputePathEVs(){
      if (!window.PATH_STATE_ASSIGN) window.PATH_STATE_ASSIGN = {};

      let demTotal = 0;
      let repTotal = 0;
      let tossupTotal = 0;

      for (const [usps, assign] of Object.entries(PATH_STATE_ASSIGN)){
        const ev = getStateEV(usps);
        if (!ev) continue;

        if (assign === 'DEM')      demTotal   += ev;
        else if (assign === 'REP') repTotal   += ev;
        else                       tossupTotal+= ev; // includes 'TOSSUP' or unknown
      }

      // Nebraska split tickers (Path-mode only feature)
      // These globals are set/updated by the NE ticker buttons you added.
      const neDem = (typeof PATH_NE_DEM === 'number') ? PATH_NE_DEM : 0;
      const neRep = (typeof PATH_NE_REP === 'number') ? PATH_NE_REP : 0;

      // after computing demTotal and repTotal from states…
      demTotal += neDem;
      repTotal += neRep;

      const neToss = Math.max(0, NE_MAX_CDS - neDem - neRep);
      tossupTotal += neToss;

      // (optional) expose for future hatch logic
      window.PATH_NE_TOSSUP = neToss;
      
      // Maine split tickers
      const meDem = (typeof PATH_ME_DEM === 'number') ? PATH_ME_DEM : 0;
      const meRep = (typeof PATH_ME_REP === 'number') ? PATH_ME_REP : 0;

      demTotal += meDem;
      repTotal += meRep;

      const meToss = Math.max(0, ME_MAX_CDS - meDem - meRep);
      tossupTotal += meToss;
      window.PATH_ME_TOSSUP = meToss;

      
      // Optional: keep a grand total if you need it (usually 538)
      const TOTAL_EV = (typeof window.TOTAL_ELECTORAL_VOTES === 'number')
        ? window.TOTAL_ELECTORAL_VOTES
        : 538;
      const accounted = demTotal + repTotal + tossupTotal;
      const remaining = Math.max(0, TOTAL_EV - accounted);
      
      setPathEVs({ DEM: demTotal, REP: repTotal });

      // --- UI updates (use whatever hooks you already have) --------------------
      // 1) If you have a dedicated updater, call it:
      if (typeof updatePathBars === 'function') {
        // updatePathBars(demEV, repEV, tossupEV, remainingEV?)
        try { updatePathBars(demTotal, repTotal, tossupTotal, remaining); } catch{}
      }

      // 2) Also update any plain text counters if they exist:
      const demText = document.getElementById('demEvTotal');
      const repText = document.getElementById('repEvTotal');
      const tossText = document.getElementById('tossupEvTotal');
      const remText = document.getElementById('remainingEvTotal');
      if (demText)  demText.textContent  = String(demTotal);
      if (repText)  repText.textContent  = String(repTotal);
      if (tossText) tossText.textContent = String(tossupTotal);
      if (remText)  remText.textContent  = String(remaining);

      // 3) Expose totals globally if other components need them
      window.PATH_EV_TOTALS = { dem: demTotal, rep: repTotal, tossup: tossupTotal, remaining };
    }


    
    // Path headshots (replace with your asset paths; fall back to party icons if needed)
    const PATH_IMG_PRITZKER = "../images/jbpritzker-square.png";  // change to your path
    const PATH_IMG_VANCE    = "/../images/jdvance-square.png";     // change to your path
    const PATH_IMG_DEM_FALLBACK = "../images/party/dem.png";
    const PATH_IMG_REP_FALLBACK = "../images/party/rep.png";

    // Path EV target and live totals (we’ll count to 270; you can show 538 if you prefer)
    const PATH_EV_TARGET = 270;

    // Simple clamp helper
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    function initPathPanelOnce(){
      if (window._pathPanelInit) return;
      window._pathPanelInit = true;

      const demImg = document.getElementById('pathHeadDEM');
      const repImg = document.getElementById('pathHeadREP');
      if (demImg) {
        demImg.src = PATH_IMG_PRITZKER;
        demImg.onerror = () => { demImg.onerror = null; demImg.src = PATH_IMG_DEM_FALLBACK; };
      }
      if (repImg) {
        repImg.src = PATH_IMG_VANCE;
        repImg.onerror = () => { repImg.onerror = null; repImg.src = PATH_IMG_REP_FALLBACK; };
      }
      const tgt = document.getElementById('evTarget');
      if (tgt) tgt.textContent = PATH_EV_TARGET;
      setTimeout(syncBarrelWidths, 0);   // after the headshots paint, size the barrels

    }

    function repositionReadouts(){
      const t = window.PATH_EV_TOTALS || {};
      if (t && (t.dem != null) && (t.rep != null)) {
        setPathEVs({ DEM: t.dem, REP: t.rep });
      }
    }
    /**
     * Update the Path EV bars.
     * Pass raw totals (0..538). We map fill height to the 270 target (caps at 100%).
     */
    // normalize and paint the EV barrels
    function setPathEVs({ DEM, REP }, maxBarEV = 370){
      const clamp01 = v => Math.max(0, Math.min(v, 1));
      const d = clamp01(DEM / maxBarEV) * 100;
      const r = clamp01(REP / maxBarEV) * 100;

      const demCol = document.querySelector('#pathPanel .ev-column.dem');
      const repCol = document.querySelector('#pathPanel .ev-column.rep');

      const apply = (col, pct, valText) => {
        if (!col) return;

        const fill = col.querySelector('.ev-fill');
        const prev = parseFloat((fill?.style.getPropertyValue('--h') || '0').replace('%','')) || 0;

        // directional easing (fill)
        const rising = pct > prev;
        fill?.style.setProperty('--ev-dur',  rising ? '.60s' : '.28s');
        fill?.style.setProperty('--ev-ease', rising ? 'cubic-bezier(.12,.8,.12,1)'
                                                    : 'cubic-bezier(.25,.1,.3,1)');
        fill?.style.setProperty('--h', pct + '%');

        // --- readout placement & easing ---
        const h = col.getBoundingClientRect().height || 0;
        const OFFSET = 48;                                 // pixels below the ink edge
        const pxFromBottom = (h * (pct/100)) - OFFSET;     // “hug” the ink top
        const clamped = Math.max(8, Math.min(h - 28, pxFromBottom));

        // ease numbers a touch slower on rises, snappier on drops
        col.style.setProperty('--ev-num-dur',  rising ? '.70s' : '.32s');
        col.style.setProperty('--ev-num-ease', rising ? 'cubic-bezier(.12,.8,.12,1)'
                                                      : 'cubic-bezier(.25,.1,.3,1)');
        col.style.setProperty('--readout-bottom', clamped + 'px');

        col.querySelector('.ev-readout').textContent = valText;
      };



      apply(demCol, d, DEM);
      apply(repCol, r, REP);
    }




    // Expose for console/manual testing now; the Path map logic can call this later.
    window.setPathEVs = setPathEVs;

    
    
    // --- Electoral Votes (2024–2028 apportionment) ------------------------------
    // Source: current allocation (total 538; 270 to win)
    const ELECTORAL_VOTES = {
      AL: 9,  AK: 3,  AZ:11, AR: 6,  CA:54, CO:10, CT: 7, DE: 3, DC: 3, FL:30,
      GA:16, HI: 4,  ID: 4,  IL:19, IN:11, IA: 6,  KS: 6, KY: 8, LA: 8,  ME: 2,
      MD:10, MA:11, MI:15, MN:10, MS: 6, MO:10, MT: 4, NE: 2, NV: 6, NH: 4,
      NJ:14, NM: 5, NY:28, NC:16, ND: 3, OH:17, OK: 7, OR: 8, PA:19, RI: 4,
      SC: 9, SD: 3, TN:11, TX:40, UT: 6, VT: 3, VA:13, WA:12, WV: 4, WI:10, WY: 3
    };

    // States that can split EVs by congressional district
    const SPLIT_VOTE_STATES = new Set(['ME','NE']);

    // Per-district breakdown for split states (1 EV per district + 2 statewide)
    const SPLIT_VOTE_DISTRICTS = {
      ME: {
        statewide: 2,
        districts: { 'ME-01': 1, 'ME-02': 1 }
      },
      NE: {
        statewide: 2,
        districts: { 'NE-01': 1, 'NE-02': 1, 'NE-03': 1 }
      }
    };

    // --- Small sanity check (kept in dev; safe in prod too) ---------------------
    (function verifyEVTotal(){
      const total = Object.values(ELECTORAL_VOTES).reduce((a,b)=>a+b,0);
      if (total !== 538) {
        console.warn(`[EV] Expected 538 total, got ${total}. Check allocation map.`);
      }
    })();

    
    function ensureLegendClusters(){
      const legend = document.getElementById('statusLegend');
      if (!legend) return;

      let left = legend.querySelector('.legend-left');
      if (!left){
        left = document.createElement('span');
        left.className = 'legend-left';
        // move existing groups into the left cluster
        [...legend.querySelectorAll('.legend-group')].forEach(g => left.appendChild(g));
        legend.prepend(left);
      }

      let right = legend.querySelector('.split-tickers-wrap');
      if (!right){
        right = document.createElement('span');
        right.className = 'split-tickers-wrap';  // Path rule shows it
        legend.appendChild(right);
      }
    }

    
    // --- Helpers you can call from your future leader bar logic -----------------
    function isSplitState(usps){ return SPLIT_VOTE_STATES.has(usps); }
    function evForState(usps){ return ELECTORAL_VOTES[usps] || 0; }

    /**
     * Returns a normalized EV breakdown for a state.
     * For non-split states, everything is in `statewide`.
     * For split states (ME/NE), you get { statewide:2, districts:{'ME-01':1,...} } etc.
     */
    function evBreakdown(usps){
      if (!isSplitState(usps)) {
        return { statewide: evForState(usps), districts: {} };
      }
      return SPLIT_VOTE_DISTRICTS[usps];
    }

    /**
     * Example tally helper.
     * Pass winners like:
     * {
     *   CA: 'DEM',
     *   TX: 'REP',
     *   ME: { statewide: 'DEM', districts: { 'ME-01':'DEM', 'ME-02':'REP' } },
     *   NE: { statewide: 'REP', districts: { 'NE-01':'REP','NE-02':'DEM','NE-03':'REP' } }
     * }
     */
    function tallyEVs(winners){
      const tally = { DEM:0, REP:0, OTHER:0 };

      for (const usps of Object.keys(winners)) {
        const w = winners[usps];
        if (!isSplitState(usps)) {
          const party = w; // 'DEM' | 'REP' | 'OTHER'
          tally[party] = (tally[party]||0) + evForState(usps);
          continue;
        }

        // split state
        const breakdown = evBreakdown(usps);
        if (w.statewide) {
          tally[w.statewide] = (tally[w.statewide]||0) + breakdown.statewide;
        }
        if (w.districts) {
          for (const [cd, party] of Object.entries(w.districts)) {
            const ev = breakdown.districts[cd] || 0; // 1 each
            tally[party] = (tally[party]||0) + ev;
          }
        }
      }
      return tally;
    }

    // Export to global if you prefer to call from elsewhere
    window.ELECTORAL_VOTES = ELECTORAL_VOTES;
    window.SPLIT_VOTE_STATES = SPLIT_VOTE_STATES;
    window.SPLIT_VOTE_DISTRICTS = SPLIT_VOTE_DISTRICTS;
    window.isSplitState = isSplitState;
    window.evForState = evForState;
    window.evBreakdown = evBreakdown;
    window.tallyEVs = tallyEVs;

    
    if (typeof updateActiveBadge !== "function") {
      window.updateActiveBadge = function(){};
    }
    
    
    // Ink (telestration) layer above map shapes
  
    let currentZoomK = 1;       // track zoom for inverse-width
    let inkMode = "pan";        // "pan" | "pen"
    let drawing = false;
    let currentStroke = null;
    let currentPoints = [];
    const strokes = [];         // (optional) if you later add undo
    const lineGen = d3.line().curve(d3.curveBasis);


    // PRELOAD: congressional districts for current YEAR (needed for H drilldown)

    // --- Manual "no election" list for S 2026 ---
    // --- Manual "no election" list for S 2026 (idempotent) ---
    window.SENATE_2026_NO_RACE = window.SENATE_2026_NO_RACE || new Set([
      'NM','AZ','CA','TX','FL','NY','IL','PA','OH','MI',
      'GA','NC','VA','WA','CO'
    ]);

    // helper: true if a state's USPS is on the no-race list (idempotent)
    window.isNoSenate2026 = window.isNoSenate2026 || (usps =>
      window.SENATE_2026_NO_RACE.has(String(usps))
    );
    
    window.__forceSenate2026GenAtNational = window.__forceSenate2026GenAtNational ?? false;


    
    window.GOVERNOR_2026_NO_RACE = window.GOVERNOR_2026_NO_RACE || new Set([
        'ME','AL','TX','NV','OR',
        'KY','WI','AZ','GA','NC',
        'CO','AR','IL','OK','MI',
        'WA','TN','PA','LA','NM'
      ]);
                                                                            
    window.isNoGovernor2026 = window.isNoGovernor2026 || (usps =>
      window.GOVERNOR_2026_NO_RACE.has(String(usps))
    );

    // Unified gate used by coloring + rollups for 2026 S/G
    window.isNoRace2026 = window.isNoRace2026 || function(usps){
      if (String(YEAR) !== '2026') return false;
      const s = String(usps);
      if (OFFICE === 'S') return isNoSenate2026(s);
      if (OFFICE === 'G') return isNoGovernor2026(s);
      return false;
    };
    
    // Single place to control the grey you want:
    const NO_RACE_GREY = '#bfc3c8'; // pick your grey

    
    // near: let countiesSel = null;
    let districtsSel = null;

    let selectedDistrict = null;
    
    let BOP_MODE = false;

    // Manual fixed seats that aren't up this cycle (adjust as needed)
    const SENATE_HOLDOVERS_2026 = { DEM: 31, REP: 33, IND: 1 };

    
    function resetBopChart(el){
      if (!el) return;
      // remove both office classes so CSS can't conflict
      el.classList.remove('senate', 'house');
      // hard reset: nuke old SVGs (and any stale inline styles/transforms)
      el.innerHTML = '';
      // just in case: clear inline style on the container
      el.removeAttribute('style');
    }

    function isStateClickable(sd){
      const usps =
        sd.usps || sd.properties?.STUSPS ||
        USPS_BY_STATEFP?.[String(sd.id).padStart(2,"0")];
      if (OFFICE === 'S' && String(YEAR) === '2026' && isNoSenate2026(usps)) {
        return false; // not clickable this cycle
      }
      if (OFFICE === 'G' && String(YEAR) === '2026' && isNoGovernor2026(usps)) {
         return false; // not clickable this cycle
       }
      return true;
    }
    
    
    
    // Icon paths (PNG; change to .svg if that's what you exported)
    const MENU_ICONS = {
      race270:   "../images/menu-icons/raceto270-icon.png",
      path:      "../images/menu-icons/path-icon.png",
      senate:    "../images/menu-icons/senate-icon.png",
      house:     "../images/menu-icons/house-icon.png",
      exitpolls: "../images/menu-icons/exitpolls-icon.png",
    };

    function hideMainMenu(){
      document.getElementById('mainMenu')?.remove();
    }

    function showMainMenu(){
      hideMainMenu(); // reset

      const menu = document.createElement('div');
      menu.id = 'mainMenu';

      // Build five tiles
      const mk = (cls, bg, action) => {
        const div = document.createElement('div');
        div.className = `menu-item ${cls}`;
        div.style.backgroundImage = `url("${bg}")`;
        div.addEventListener('click', action);
        return div;
      };


      
      const onRace270   = () => { goToOfficeYear('P','2026'); };
      // AFTER: Path menu → leave menu and enter Path mode
      const onPath = () => {
        // if BOP was on, turn it off cleanly
        if (document.body.classList.contains('bop-mode') || window.BOP_MODE) {
          try { exitBopMode?.(); } catch {}
          document.body.classList.remove('bop-mode');
        }

        // close the menu overlay + CSS state that hides UI
        document.body.classList.remove('menu-mode');
        hideMainMenu?.();

        // go straight into Path
        enterPathMode?.();
      };

      const onSenate = () => {
        // set context
        goToOfficeYear('S','2026');
        // leave menu UI if open
        document.body.classList.remove('menu-mode');
        hideMainMenu?.();
        // enter BOP (will use current OFFICE='S')
        enterBopMode?.();
      };

      const onHouse = () => {
        // set context
        goToOfficeYear('H','2026');
        // leave menu UI if open
        document.body.classList.remove('menu-mode');
        hideMainMenu?.();
        // enter BOP (will render the House horseshoe for 2026)
        enterBopMode?.();
      };

      const onExitPolls = () => { /* do nothing */ };

        
        
      menu.append(
        mk('menu-tl',     MENU_ICONS.race270,   onRace270),
        mk('menu-tr',     MENU_ICONS.path,      onPath),
        mk('menu-bl',     MENU_ICONS.senate,    onSenate),
        mk('menu-br',     MENU_ICONS.house,     onHouse),
        mk('menu-center', MENU_ICONS.exitpolls, onExitPolls),
      );

      // Attach to your main app container so it layers above map
      (document.getElementById('app') || document.body).appendChild(menu);
    }

    
    // helper to add them only when we explicitly opt in
    function addSenateHoldovers(counts) {
      return {
        DEM: (counts.DEM || 0) + (SENATE_HOLDOVERS_2026.DEM || 0),
        REP: (counts.REP || 0) + (SENATE_HOLDOVERS_2026.REP || 0),
        IND: (counts.IND || 0) + (SENATE_HOLDOVERS_2026.IND || 0),
      };
    }

    if (!window.__bopModeObserver) {
      window.__bopModeObserver = new MutationObserver(() => {
        if (!document.body.classList.contains('bop-mode')) {
          window.ensureMapRendered?.({ force: true });
        }
      });
      window.__bopModeObserver.observe(
        document.body,
        { attributes: true, attributeFilter: ['class'] }
      );
    }
    
    const COLOR_NO_DATA = "#9aa0a6"; // light grey for zero-total “no data”
    function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    
    const partyRowHTML = (r) => `
      <div class="party-row party-${String(r.party).toUpperCase()}">
        <div class="party-name">${r.label.toUpperCase()}</div>
        <div class="party-count">${Number(r.count || 0).toLocaleString('en-US')}</div>
      </div>`;

    
    // Years where we only ship historic GEN results
    const HIST_YEARS_SET = new Set(["2016","2018","2020","2022","2024"]);

    const HIST_P_YEARS = new Set(["2016","2020","2024"]);
    
    // Historic general-election years you have data for
    const HIST_GEN_YEARS = new Set(["2016","2018","2020","2022","2024"]);

    document.addEventListener('DOMContentLoaded', () => {
      document.body.classList.remove('bop-mode');
      document.getElementById('bopOverlay')?.setAttribute('hidden','');
    });
    
    
    
    
    // --- Senate 2026 topline cache (USPS → { status, winnerParty, percentIn, epoch }) ---
    window.STATE_TOPLINE = Object.create(null);

    // 50 state USPS codes (exclude DC/PR/territories)
    const USPS_50_STATES = [
      "AL","AK","AZ","AR","CA","CO","CT","DE","FL","GA",
      "HI","ID","IL","IN","IA","KS","KY","LA","ME","MD",
      "MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ",
      "NM","NY","NC","ND","OH","OK","OR","PA","RI","SC",
      "SD","TN","TX","UT","VT","VA","WA","WV","WI","WY"
    ];

    
    // --- Governor 2026 topline cache (USPS → { status, winnerParty, percentIn, epoch }) ---
    window.GOV_TOPLINE = Object.create(null);



    // Convenience getter
    function getGovernor2026Topline(usps) {
      return GOV_TOPLINE[usps] || { status: null, winnerParty: null, percentIn: null, epoch: null };
    }


    // Treat only explicit calls as "called" (your map logic can use this if needed)
    function isRaceCalled(status) {
      if (!status) return false;
      const s = String(status).toLowerCase();
      if (/no decision|too early|too close|no call/.test(s)) return false;
      return /call/.test(s); // e.g., "Called", "Race Called"
    }

    // Fetch and parse one state's topline for S 2026 G
    async function fetchSenate2026ToplineForState(usps, { apiBase = API_BASE } = {}) {
      const url = `${apiBase}/v2/elections/2026-11-03?statepostal=${usps}&officeId=S&raceTypeId=G`;
      try {
        const resp = await fetch(url, { mode: "cors", cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const xml = await resp.text();

        // Parse the XML and read the *topline* attributes
        const doc = new DOMParser().parseFromString(xml, "text/xml");
        const root = doc.querySelector("ElectionResults");
        if (!root) throw new Error("Missing <ElectionResults>");

        const status     = root.getAttribute("RaceCallStatus") || null;
        const winnerRaw  = root.getAttribute("WinnerParty") || null;
        const winnerParty = normalizeParty(winnerRaw) || null;
        const percentIn  = Number(root.getAttribute("PercentIn") || 0);
        const epoch      = root.getAttribute("Epoch") || null;

        return { status, winnerParty, percentIn, epoch };
      } catch (err) {
        console.warn(`[topline:S-2026] ${usps} →`, err);
        return { status: null, winnerParty: null, percentIn: null, epoch: null, error: String(err) };
      }
    }

    // Convenience getter
    function getSenate2026Topline(usps) {
      return STATE_TOPLINE[usps] || { status: null, winnerParty: null, percentIn: null, epoch: null };
    }
    
    
    // --- SENATE (2026) national tallies ---
    function countSenateCalled2026(){
      // Count called winners by winnerParty from STATE_TOPLINE
      const out = { DEM:0, REP:0, IND:0 };
      const fps = Array.from(VALID_SENATE_STATEFPS || []);
      for (const fp of fps){
        const usps = USPS_BY_STATEFP?.[fp];
        if (isNoRace2026(usps)) continue;              // ⟵ exclude no-race states
        const { status, winnerParty } = getStateCall(fp) || {};

        if (isRaceCalled(status)) {
          const P = (winnerParty || 'IND').toUpperCase();
          if (P === 'DEM') out.DEM++;
          else if (P === 'REP') out.REP++;
          else out.IND++;
        }
      }
      return out;
    }

    function countSenateLeaders2026(){
      // Prefer the rollup-based leader counter if present
      const viaRollup =
        (typeof aggregateSenateUncalledLeaderCountsFromRollup === 'function'
          ? aggregateSenateUncalledLeaderCountsFromRollup()
          : null)
        || (typeof aggregateSenateUncalledLeaderCounts2026 === 'function'
          ? aggregateSenateUncalledLeaderCounts2026()
          : null);

      // Normalize output to { DEM, REP, IND }
      if (viaRollup && (viaRollup.DEM!=null || viaRollup.REP!=null || viaRollup.IND!=null)) {
        return {
          DEM: Number(viaRollup.DEM||0),
          REP: Number(viaRollup.REP||0),
          IND: Number(viaRollup.IND||0),
        };
      }
      // Fallback: no leaders known
      return { DEM:0, REP:0, IND:0 };
    }

    
    // Senate 2026 — "uncalled leaders" using the SAME logic as national rollup/map paint
    function aggregateSenateUncalledLeaderCountsFromRollup(){
      const out = { DEM:0, REP:0, IND:0 };

      for (const usps of USPS_50_STATES){
        if (isNoRace2026(usps)) continue;              // ⟵ exclude no-race states
        const fp = STATEFP_BY_USPS?.[usps];

        if (!fp) continue;

        // Use the same call test the rollup/map uses
        const { status } = getStateCall(fp);
        if (isRaceCalled(status)) continue; // only count states NOT called

        // Collapse multiple same-party candidates to one party bucket
        const tallies = { DEM:0, REP:0, IND:0 };
        for (const [fips, row] of Object.entries(countyData || {})) {
          if (String(fips).length !== 5 || !String(fips).startsWith(fp)) continue;
          const cs = Array.isArray(row.candidates) ? row.candidates : [];
          for (const c of cs){
            const P = normalizeParty(c.party);
            const v = Number(c.votes ?? c.VoteCount ?? 0);
            if (!Number.isFinite(v) || v <= 0) continue;
            tallies[P] = (tallies[P] || 0) + v;
          }
        }

        // Pick a single leader (ties don't count)
        let leader = null, max = -1;
        for (const [p,v] of Object.entries(tallies)){
          if (v > max){ max = v; leader = p; }
          else if (v === max){ leader = null; }
        }
        if (leader) out[leader] += 1;
      }
      return out;
    }


    // Senate 2026 — count uncalled leaders by party (DEM/REP/IND) from county rows
    function aggregateSenateUncalledLeaderCounts2026(){
      const out = { DEM:0, REP:0, IND:0 };

      // scan the 50 states
      for (const usps of USPS_50_STATES){
        if (isNoRace2026(usps)) continue;              // ⟵ exclude no-race states
        const { status, winnerParty } = getSenate2026Topline(usps);

        const called = isRaceCalled(status);

        if (called) continue;

        // derive leader from county totals (sum by party; multiple candidates per party collapse to one bucket)
        const statefp = STATEFP_BY_USPS?.[usps] || null;
        if (!statefp) continue;

        const tallies = { DEM:0, REP:0, IND:0 };
        for (const [fips, row] of Object.entries(countyData || {})) {
          if (String(fips).length !== 5 || !String(fips).startsWith(statefp)) continue;
          const cs = Array.isArray(row.candidates) ? row.candidates : [];
          for (const c of cs){
            const P = normalizeParty(c.party);
            const v = Number(c.votes || c.VoteCount || 0);
            if (!Number.isFinite(v)) continue;
            tallies[P] = (tallies[P] || 0) + v;
          }
        }

        // who leads?
        const entries = Object.entries(tallies);
        let leader = null, max = -1;
        for (const [p,v] of entries){
          if (v > max){ max = v; leader = p; }
          else if (v === max){ leader = null; } // tie → no leader
        }
        if (leader) out[leader] += 1;
      }
      return out;
    }


    
    
    
    function showLegend(){ document.getElementById('statusLegend')?.removeAttribute('hidden'); }
    function hideLegend(){ document.getElementById('statusLegend')?.setAttribute('hidden',''); }


    // Example: keep legend visible in both map and BOP modes
    document.addEventListener('DOMContentLoaded', showLegend);

    // If you want to dim the pills when showing BOP (to suggest “leaders not calls”):
    function setLegendDimmed(isDim){
      const el = document.getElementById('statusLegend'); if (!el) return;
      el.querySelectorAll('.pill').forEach(p => p.classList.toggle('dim', !!isDim));
    }

    // Hook into your BOP flow:
    const _enterBop = enterBopMode;
    enterBopMode = function(){
      _enterBop();
      setLegendDimmed(true);   // optional
      showLegend();
    };

    const _exitBop = exitBopMode;
    exitBopMode = function(){
      _exitBop();
      setLegendDimmed(false);
      showLegend();
    };

    
    function showBopHouseChart(){
      const el = document.getElementById('bopChart');
      if (!el) return;
      resetBopChart(el);
      el.classList.remove('senate');
       el.classList.add('house');
      el.removeAttribute('hidden');
      el.querySelectorAll("svg").forEach(svg => {
          svg.removeAttribute("width");
          svg.removeAttribute("height");
        });
      renderHouseHorseshoe2026(el);
    }
    function hideBopChart(){
      document.getElementById('bopChart')?.setAttribute('hidden','');
      // optional: clear contents so old arcs don’t linger
      const el = document.getElementById('bopChart');
      if (el) el.innerHTML = '';
    }
    
    // Re-render the House BOP horseshoe if we are in the right mode
    function renderBopIfActive(){
      if (!(BOP_MODE && OFFICE === 'H' && YEAR === '2026')) return;
      const el = document.getElementById('bopChart');
      if (!el) return;
      el.removeAttribute('hidden');
      renderHouseHorseshoe2026(el);
    }

    // One polling tick: refresh data, then repaint BOP if needed
    async function pollAndRefresh(){
      try {
        await getDataFromCache();

        // --- No-flash panel refresh (reuses in-place guards you added) ---
        if (YEAR === '2026') {
          if (NAV_LEVEL === 2 && (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G') && selectedFips) {
            // County view for P/S/G
            renderCountyPanel(selectedFips);
          } else if (NAV_LEVEL === 1 && (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G') && selectedStateFP) {
            // State view for P/S/G
            renderStatePanel(selectedStateFP);
          } else if (NAV_LEVEL === 0) {
                  // National view — hit your renderNationalPanel() so it updates in place
                  renderNationalPanel();
          } else if (NAV_LEVEL === 2 && OFFICE === 'H' && selectedDistrict) {
            // House district view
            renderDistrictPanel(selectedDistrict);
          }
        }
        // --- end no-flash block ---

      } finally {
        renderBopIfActive();
        if (!BOP_MODE) ensureMapRendered();
        syncPercentBolt();
      }
    }




    function districtLabel(did){
      const s = String(did || "");
      const statefp = s.slice(0, 2);
      const num = s.slice(2);
      const n = parseInt(num, 10);
      const label = (num === "00" || !Number.isFinite(n) || n === 0)
        ? "At-Large"
        : `District ${n}`;
      return { statefp, label };
    }

    
    
    function stateNameFromFP(fp){
      const f = (statesFeatures || []).find(s => String(s.id).padStart(2,"0") === String(fp).padStart(2,"0"));
      return f?.properties?.name || (USPS_BY_STATEFP[fp] || fp);
    }
    function countyNameFromFips(fips){
      return countyData?.[fips]?.name || "";
    }

    function updateBopOverlay(){
      const el = document.getElementById('bopOverlay');
      if (!el) return;
      // el.textContent = (OFFICE === 'H') ? 'House' : 'Senate';
    }

    async function enterBopMode(){
      // Decide the office we want to show in BOP
      let target = (OFFICE === 'S' || OFFICE === 'H') ? OFFICE : 'S';
      if (target === 'S' && OFFICE !== 'S'){
        // If we were not on S/H, move to Senate by default
        document.querySelector('#allButtons button[data-office="S"]')?.click();
      }

      BOP_MODE = true;
      setHeaderForBop(true);
      renderBopIfActive();
      document.body.classList.add('bop-mode');
      const ov = document.getElementById('bopOverlay');
      // ov?.removeAttribute('hidden');

      // Set label immediately using the target, so we don't race OFFICE updates
      // if (ov) ov.textContent = (target === 'H') ? 'House' : 'Senate';
      hidePercentInBolt();      // NEW: ensure %IN bolt is hidden
      updateHeaderTitle();      // NEW: set "— Balance of Power"
      if (target === 'H' && YEAR === '2026') {
        showBopHouseChart();
        renderBopIfActive();    // immediate draw
        startLivePolling();     // ensure polling is on while in BOP
      } else {
        hideBopChart();
      }
    }
    
    let IN_PATH_MODE = false;
    
    function setLegendTossupLabel(on){
      const root  = document.getElementById('statusLegend');
      if (!root) return;

      const solid = root.querySelector('.cell.ind');      // dark purple (left)
      const dim   = root.querySelector('.cell.ind-dim');  // light purple (right)

      if (on){
        if (solid){
          if (!solid.__origText) solid.__origText = solid.textContent;
          solid.textContent = 'TOSSUP';                  // left pill now says TOSSUP
        }
        if (dim){
          if (!dim.__origText) dim.__origText = dim.textContent;
          dim.classList.add('is-hidden');                // remove the light-purple pill
        }
      } else {
        if (solid && solid.__origText) solid.textContent = solid.__origText; // restore "IND"
        if (dim){
          dim.classList.remove('is-hidden');             // show again
          if (dim.__origText) dim.textContent = dim.__origText; // restore "LEADING IND"
        }
      }
    }

    
    function ensurePathResetButton(){
      const legend = document.getElementById('statusLegend');
      if (!legend) return;

      const left = legend.querySelector('.legend-left') || legend;
      let btn = document.getElementById('pathResetBtn');
      if (!btn){
        btn = document.createElement('button');
        btn.id = 'pathResetBtn';
        btn.className = 'legend-reset';
        btn.type = 'button';
        btn.textContent = 'RESET';
      }
      left.appendChild(btn);  // ⟵ ensure it lives with the pills

      if (btn.__handler) btn.removeEventListener('click', btn.__handler);
      btn.__handler = (e)=>{ e.preventDefault(); e.stopPropagation(); resetPathToPreset(); };
      btn.addEventListener('click', btn.__handler);
    }



    function resetPathToPreset(){
      applyPathPreset(true);   // rebuild PATH_STATE_ASSIGN from preset
      renderPathMap();

      // NE preset: REP +2, DEM 0
      PATH_NE_DEM = 1;
      PATH_NE_REP = 2;
      updateNeTickerUI();

      PATH_ME_DEM = ME_PRESET.DEM;
      PATH_ME_REP = ME_PRESET.REP;
      updateMeTickerUI();
      updateMaineHatch();

      recomputePathEVs();
      updateNebraskaHatch();
      setPathBrush(null);
      updateLegendBrushUI();
    }


    
    // ---- Nebraska split EVs (Path mode only) ----
    let PATH_NE_DEM = 0;  // extra EVs to DEM (0..3)
    let PATH_NE_REP = 0;  // extra EVs to REP (0..3)

    function clampNeTotals(){
      // keep each 0..3 and combined <= 3
      PATH_NE_DEM = Math.max(0, Math.min(3, PATH_NE_DEM));
      PATH_NE_REP = Math.max(0, Math.min(3, PATH_NE_REP));
      if (PATH_NE_DEM + PATH_NE_REP > 3){
        // trim the one we just overflowed; prefer preserving the one that changed
        const overflow = PATH_NE_DEM + PATH_NE_REP - 3;
        if (clampNeTotals._last === 'DEM') PATH_NE_DEM -= overflow;
        else PATH_NE_REP -= overflow;
      }
    }

    const NE_MAX_CDS = 3;
    const NE_PRESET  = { DEM: 1, REP: 2 };   // <— reset/entry preset

    function clampNeTotals(){
      PATH_NE_DEM = Math.max(0, Math.min(NE_MAX_CDS, PATH_NE_DEM));
      PATH_NE_REP = Math.max(0, Math.min(NE_MAX_CDS, PATH_NE_REP));
      if (PATH_NE_DEM + PATH_NE_REP > NE_MAX_CDS){
        const overflow = PATH_NE_DEM + PATH_NE_REP - NE_MAX_CDS;
        if (clampNeTotals._last === 'DEM') PATH_NE_DEM -= overflow;
        else PATH_NE_REP -= overflow;
      }
    }
    
    
    // ---- Maine split EVs (Path mode only) ----
    let PATH_ME_DEM = 0;   // 0..2
    let PATH_ME_REP = 0;   // 0..2
    const ME_MAX_CDS = 2;
    const ME_PRESET  = { DEM:1, REP:1 };  // adjust later if you want a default

    function clampMeTotals(){
      PATH_ME_DEM = Math.max(0, Math.min(ME_MAX_CDS, PATH_ME_DEM));
      PATH_ME_REP = Math.max(0, Math.min(ME_MAX_CDS, PATH_ME_REP));
      if (PATH_ME_DEM + PATH_ME_REP > ME_MAX_CDS){
        const overflow = PATH_ME_DEM + PATH_ME_REP - ME_MAX_CDS;
        if (clampMeTotals._last === 'DEM') PATH_ME_DEM -= overflow;
        else PATH_ME_REP -= overflow;
      }
    }
    function meAdjust(party, delta){
      if (delta === +1){
        transferCD(party, ME_MAX_CDS,
          () => ({ dem: PATH_ME_DEM, rep: PATH_ME_REP }),
          (dem, rep) => { PATH_ME_DEM = dem; PATH_ME_REP = rep; }
        );
      } else if (delta === -1){
        if (party === 'DEM') PATH_ME_DEM = Math.max(0, PATH_ME_DEM - 1);
        else                 PATH_ME_REP = Math.max(0, PATH_ME_REP - 1);
      }

      updateMeTickerUI();
      recomputePathEVs();
      updateMaineHatch();
    }

    function updateMeTickerUI(){
      const dem = document.getElementById('meDemCount');
      const rep = document.getElementById('meRepCount');
      if (dem) dem.textContent = PATH_ME_DEM;
      if (rep) rep.textContent = PATH_ME_REP;
    }
    
    function ensureMaineTickers(){
      const legend = document.getElementById('statusLegend');
      if (!legend || document.getElementById('meTickers')) return;

      const right = legend.querySelector('.split-tickers-wrap') || legend;

      const wrap = document.createElement('span');
      wrap.id = 'meTickers';
      wrap.className = 'me-tickers';
      wrap.innerHTML = `
        <span class="me-ticker" id="meDem">
          <span class="lbl">ME</span>
          <button class="btn" type="button" aria-label="DEM minus 1">−</button>
          <span class="count" id="meDemCount">0</span>
          <button class="btn" type="button" aria-label="DEM plus 1">+</button>
        </span>
        <span class="me-ticker" id="meRep">
          <span class="lbl">ME</span>
          <button class="btn" type="button" aria-label="REP minus 1">−</button>
          <span class="count" id="meRepCount">0</span>
          <button class="btn" type="button" aria-label="REP plus 1">+</button>
        </span>
      `;
      right.appendChild(wrap);   // ⟵ right block, row 2

      const [demMinus, demPlus] = wrap.querySelectorAll('#meDem .btn');
      const [repMinus, repPlus] = wrap.querySelectorAll('#meRep .btn');
      demMinus.addEventListener('click', ()=> meAdjust('DEM', -1));
      demPlus .addEventListener('click', ()=> meAdjust('DEM', +1));
      repMinus.addEventListener('click', ()=> meAdjust('REP', -1));
      repPlus .addEventListener('click', ()=> meAdjust('REP', +1));

      updateMeTickerUI();
    }


    function transferCD(party, max, getter, setter){
      // getter() → { dem, rep }, setter(dem, rep) mutates + updates UI/EV/hatch outside
      let { dem, rep } = getter();
      const sum = dem + rep;

      if (party === 'DEM'){
        if (sum < max){ dem += 1; }
        else if (rep > 0){ rep -= 1; dem += 1; } // steal one from REP
      } else { // REP
        if (sum < max){ rep += 1; }
        else if (dem > 0){ dem -= 1; rep += 1; } // steal one from DEM
      }

      // clamp for safety
      dem = Math.max(0, Math.min(max, dem));
      rep = Math.max(0, Math.min(max, rep));
      setter(dem, rep);
    }

    
    function neAdjust(party, delta){
      // +1 uses transfer rule when full; -1 just subtracts from that party
      if (delta === +1){
        transferCD(party, NE_MAX_CDS,
          () => ({ dem: PATH_NE_DEM, rep: PATH_NE_REP }),
          (dem, rep) => { PATH_NE_DEM = dem; PATH_NE_REP = rep; }
        );
      } else if (delta === -1){
        if (party === 'DEM') PATH_NE_DEM = Math.max(0, PATH_NE_DEM - 1);
        else                 PATH_NE_REP = Math.max(0, PATH_NE_REP - 1);
      }

      updateNeTickerUI();
      recomputePathEVs();
      updateNebraskaHatch();
    }


    function updateNeTickerUI(){
      const dem = document.getElementById('neDemCount');
      const rep = document.getElementById('neRepCount');
      if (dem) dem.textContent = PATH_NE_DEM;
      if (rep) rep.textContent = PATH_NE_REP;
    }

    function ensureNebraskaTickers(){
      const legend = document.getElementById('statusLegend');
      if (!legend || document.getElementById('neTickers')) return;

      const right = legend.querySelector('.split-tickers-wrap') || legend;

      const wrap = document.createElement('span');
      wrap.id = 'neTickers';
      wrap.className = 'ne-tickers';
      wrap.innerHTML = `
        <span class="ne-ticker" id="neDem">
          <span class="lbl">NE</span>
          <button class="btn" type="button" aria-label="DEM minus 1">−</button>
          <span class="count" id="neDemCount">0</span>
          <button class="btn" type="button" aria-label="DEM plus 1">+</button>
        </span>
        <span class="ne-ticker" id="neRep">
          <span class="lbl">NE</span>
          <button class="btn" type="button" aria-label="REP minus 1">−</button>
          <span class="count" id="neRepCount">0</span>
          <button class="btn" type="button" aria-label="REP plus 1">+</button>
        </span>
      `;
      right.appendChild(wrap);   // ⟵ right block, row 1

      const [demMinus, demPlus] = wrap.querySelectorAll('#neDem .btn');
      const [repMinus, repPlus] = wrap.querySelectorAll('#neRep .btn');
      demMinus.addEventListener('click', ()=> neAdjust('DEM', -1));
      demPlus .addEventListener('click', ()=> neAdjust('DEM', +1));
      repMinus.addEventListener('click', ()=> neAdjust('REP', -1));
      repPlus .addEventListener('click', ()=> neAdjust('REP', +1));

      updateNeTickerUI();
    }





    // --- PATH: Nebraska hatch overlay ------------------------------------------
    function getStateFeatureByUSPS(usps){
      const U = String(usps).toUpperCase();
      return (statesFeatures || []).find(s => {
        const featureUSPS =
          s.usps ||
          s.properties?.usps ||
          s.properties?.STUSPS ||
          (USPS_BY_STATEFP?.[String(s.id).padStart(2,"0")] || null);
        return String(featureUSPS).toUpperCase() === U;
      });
    }


    function ensurePathHatchDefs(){
      const svg = d3.select('#map');
      let defs = svg.select('defs');
      if (defs.empty()) defs = svg.append('defs');

      function mk(id, color){
        if (!defs.select(`#${id}`).empty()) return;
        const p = defs.append('pattern')
          .attr('id', id)
          .attr('patternUnits', 'userSpaceOnUse')
          .attr('width', 8).attr('height', 8)
          .attr('patternTransform', 'rotate(-45)');
        p.append('rect').attr('width', 8).attr('height', 8)
          .attr('fill', 'transparent');
        p.append('line')
          .attr('x1', 0).attr('y1', 0)
          .attr('x2', 0).attr('y2', 8)
          .attr('stroke', color).attr('stroke-width', 4).attr('opacity', 1);
      }
      mk('pathHatchBlue',   '#2a66ff');  // DEM hatch
      mk('pathHatchRed',    '#e33');     // REP hatch
      mk('pathHatchYellow', '#f2c744');  // Tossup hatch
    }
    
    
    function updateMaineHatch(){
      if (!document.body.classList.contains('path-mode')) return;
      ensurePathHatchDefs();

      const statewide = (PATH_STATE_ASSIGN?.ME || 'TOSSUP').toUpperCase();
      const dem  = +PATH_ME_DEM || 0;
      const rep  = +PATH_ME_REP || 0;
      const toss = Math.max(0, (typeof ME_MAX_CDS === 'number' ? ME_MAX_CDS : 2) - dem - rep);

      let hatchId = null;
      if (statewide === 'REP'){
        if (rep >= 2) hatchId = null;
        else if (dem > 0) hatchId = 'pathHatchBlue';
        else if (toss > 0) hatchId = 'pathHatchYellow';
      } else if (statewide === 'DEM'){
        if (dem >= 2) hatchId = null;
        else if (rep > 0) hatchId = 'pathHatchRed';
        else if (toss > 0) hatchId = 'pathHatchYellow';
      } else {
        // Statewide TOSSUP → keep yellow fill; hatch = who holds any CDs.
        // If both parties hold CDs, prefer DEM hatch; if none, use yellow (leftovers).
        if (dem > 1)           hatchId = 'pathHatchBlue';
        else if (rep > 0)      hatchId = 'pathHatchRed';
        else if (toss > 0)     hatchId = 'pathHatchYellow';
        else                   hatchId = null;
      }



      const layer = d3.select('#pathHatchLayer');
      if (layer.empty()) return;

      const meFeat = getStateFeatureByUSPS('ME');
      const sel = layer.selectAll('#pathMaineHatch').data(hatchId ? [meFeat] : []);
      sel.exit().remove();
      sel.enter().append('path')
          .attr('id','pathMaineHatch')
          .attr('d', d => path(d))
          .attr('fill-opacity', 1);

      layer.select('#pathMaineHatch')
           .attr('fill', hatchId ? `url(#${hatchId})` : 'none');
    }


    function updateNebraskaHatch(){
      if (!document.body.classList.contains('path-mode')) return;

      ensurePathHatchDefs();

      const statewide = (PATH_STATE_ASSIGN?.NE || 'TOSSUP').toUpperCase();
      const dem  = +PATH_NE_DEM || 0;
      const rep  = +PATH_NE_REP || 0;
      const toss = Math.max(0, (typeof NE_MAX_CDS === 'number' ? NE_MAX_CDS : 3) - dem - rep);

      let hatchId = null;
      if (statewide === 'REP'){
        if (rep >= 3) hatchId = null;
        else if (dem > 0) hatchId = 'pathHatchBlue';
        else if (toss > 0) hatchId = 'pathHatchYellow';
      } else if (statewide === 'DEM'){
        if (dem >= 3) hatchId = null;
        else if (rep > 0) hatchId = 'pathHatchRed';
        else if (toss > 0) hatchId = 'pathHatchYellow';
      } else {
        // Statewide TOSSUP → keep yellow fill; hatch = who holds any CDs.
        // If both parties hold CDs, prefer DEM hatch; if none, use yellow (leftovers).
        if (dem > 0)           hatchId = 'pathHatchBlue';
        else if (rep > 0)      hatchId = 'pathHatchRed';
        else if (toss > 0)     hatchId = 'pathHatchYellow';
        else                   hatchId = null;
      }


      const layer = d3.select('#pathHatchLayer');
      if (layer.empty()) return;

      const neFeat = getStateFeatureByUSPS('NE');
      const sel = layer.selectAll('#pathNebraskaHatch').data(hatchId ? [neFeat] : []);
      sel.exit().remove();
      sel.enter().append('path')
          .attr('id','pathNebraskaHatch')
          .attr('d', d => path(d))
          .attr('fill-opacity', 1);

      layer.select('#pathNebraskaHatch')
           .attr('fill', hatchId ? `url(#${hatchId})` : 'none');
    }


    
    function enterPathMode(){
      // If BOP is active, leave it first
      if (window.BOP_MODE || document.body.classList.contains('bop-mode')) {
        try { exitBopMode?.(); } catch {}
        document.body.classList.remove('bop-mode');
      }
      // ✅ Always load preset BEFORE rendering (runs once unless you force it)
      applyPathPreset();   // <-- moved out of the BOP branch

      // UI: button states + body class
      document.querySelectorAll('#allButtons button[data-office], #allButtons button[data-race]')
        .forEach(b => b.classList.remove('active'));
      document.body.classList.add('path-mode');
      pathBtn?.classList.add('active');
      pathBtn?.classList.add('active');

      // Panel + map (do NOT zero EVs; let preset show immediately)
      initPathPanelOnce?.();
      renderPathMap();     // draws and paints using PATH_STATE_ASSIGN
      recomputePathEVs();  // <-- show preset totals now
      setLegendTossupLabel(true);
      wireLegendForPathBrush(true);
      ensureLegendClusters();   // build left/right containers before adding buttons/rows

      updateLegendBrushUI();
      ensureLegendClusters();
      ensurePathResetButton();
      ensureNebraskaTickers();
      // NE preset: REP gets 2 CDs (DEM gets 0)
      PATH_NE_DEM = NE_PRESET.DEM;
      PATH_NE_REP = NE_PRESET.REP;
      updateNeTickerUI();
      ensureMaineTickers();
      PATH_ME_DEM = ME_PRESET.DEM;
      PATH_ME_REP = ME_PRESET.REP;
      updateMeTickerUI();
      recomputePathEVs();
      updateMaineHatch();

      recomputePathEVs();
      updateNeTickerUI();
      updateNebraskaHatch();


      // Lock camera & kill zoom while in Path
      try {
        d3.select('#map').interrupt()
          .transition().duration(0)
          .call(zoom.transform, INITIAL_VIEW);
      } catch {}
      d3.select('#map').on('.zoom', null);
      syncBarrelWidths();
      requestAnimationFrame(() => requestAnimationFrame(repositionReadouts));
      // one-time wiring to keep barrel widths in sync with headshot size
      if (!window.__barrelSyncWired) {
        window.__barrelSyncWired = true;

        // Recompute on window resize
        window.addEventListener('resize', syncBarrelWidths);

        // Recompute once the headshots actually load (or error → fallback)
        ['load','error'].forEach(evt => {
          document.querySelectorAll('#pathPanel .ev-chrome').forEach(img => {
            img.addEventListener(evt, syncBarrelWidths, { once:false });
          });
        });
        window.addEventListener('resize', syncBarrelWidths);
        // React to relayouts (e.g., font/render shifts) in the Path cards
        const ro = new ResizeObserver(syncBarrelWidths);
        document.querySelectorAll('#pathPanel .path-card').forEach(node => ro.observe(node));
        window.__barrelRO = ro; // keep a ref if you ever need to disconnect()
      }

    }


    function exitPathMode(){
      // allow normal painters to run again
      document.body.classList.remove('path-mode');
      pathBtn?.classList.remove('active');
      window._pathPresetApplied = false;
      // re-enable buttons if you disabled them in path mode
      document.querySelectorAll('#allButtons button[data-office], #allButtons button[data-race]')
        .forEach(b => { b.disabled = false; b.removeAttribute('aria-disabled'); });

      // remove the blank path map and restore the layer scaffold
      teardownPathMap();
      wireLegendForPathBrush(false);

      // Restore zoom after leaving Path
      const mapSel = d3.select('#map');
      mapSel.on('.zoom', null);   // clear any leftover nulls
      mapSel.call(zoom);          // rebind d3-zoom

      setLegendTossupLabel(false);
      // jump to P 2026 using your normal routing if available
      if (typeof goToOfficeYear === 'function') {
        goToOfficeYear('P','2026');
        return;
      }

      // fallback: set globals, light the P button, and repaint
      window.OFFICE = 'P';
      window.YEAR   = '2026';
      document.querySelectorAll('#allButtons button[data-office]')
        .forEach(b => b.classList.toggle('active', b.dataset.office === 'P'));

      try { drawShapes?.(); } catch {}
      try { ensureMapRendered?.({ force:true }); } catch {}
      try { renderNationalPanel?.(); } catch {}
      try { syncPercentBolt?.(); } catch {}
      
      // after calling goToOfficeYear('P','2026') or after the fallback draw:
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          try { ensureMapRendered?.({ force:true }); } catch {}
          try { drawShapes?.(); } catch {}
          try { colorizeInstant?.(true); } catch {}
        });
      });

    }



    // Wire the button (toggle behavior)
    const pathBtn = document.getElementById('pathBtn');
    pathBtn?.addEventListener('click', () => {
      const nowOn = !document.body.classList.contains('path-mode');
      if (nowOn) enterPathMode(); else exitPathMode();
    });


    function exitBopMode(){
      BOP_MODE = false;
      setHeaderForBop(false);
      document.body.classList.remove('bop-mode');
      document.getElementById('bopOverlay')?.setAttribute('hidden', '');
      hideBopChart();
      updateHeaderTitle();

      // BELT & SUSPENDERS: after CSS un-hides the map, guarantee a draw.
      // Double-rAF lets layout settle before we inspect/redraw.
      requestAnimationFrame(() => {
        requestAnimationFrame(() => ensureMapRendered({ force: true }));
        syncPercentBolt();
      });

      // Your existing targeted rebuilds by nav level
      if (NAV_LEVEL === 0){
        drawShapes();
        colorizeInstant(true);
        renderNationalPanel?.();
      } else if (NAV_LEVEL === 1 && selectedStateFP){
        renderStatePanel?.(selectedStateFP);
        if (OFFICE !== 'H') showPercentInBoltForState(selectedStateFP);
      } else if (NAV_LEVEL === 2){
        if (OFFICE === 'H' && selectedDistrict){
          showPercentInBoltForDistrict(selectedDistrict);
        } else if (selectedFips){
          showPercentInBoltForCounty(selectedFips);
        }
      }
    }

    // --- Menu: clear panels/map/BOP/header ---
    // --- Menu: clear EVERYTHING (header/logo/lines, legend, stars, map, BOP, left) ---
    // --- Menu: clear EVERYTHING (header/logo/lines, legend, stars, map, BOP, left) ---
    function clearToMenu(){
      // 0) If BOP was on, exit BEFORE toggling menu-mode
      if (document.body.classList.contains('bop-mode') || window.BOP_MODE) {
        try { exitBopMode?.(); } catch(e){}
        document.body.classList.remove('bop-mode');
      }

      // 1) Nuke the horseshoe immediately
      const bc = document.getElementById('bopChart');
      if (bc){
        bc.classList.remove('senate','house');
        bc.innerHTML = '';
        bc.setAttribute('hidden','');
        bc.removeAttribute('style');
      }
      // 2) Hide any BOP overlay text, just in case
      document.getElementById('bopOverlay')?.setAttribute('hidden','');

      // 3) Remove the big DEM/REP ## (left panel tally rows)
      document.querySelectorAll('.party-tally, .party-row').forEach(n => n.remove());

      // 4) Enter MENU MODE (CSS will hide header, legend, stars, map, left panel)
      document.body.classList.add('menu-mode');

      // 5) Show the menu overlay
      showMainMenu();

      // 6) Make the menu button highlight via CSS (already handled by .menu-mode #menuBtn)
    }



    // Wire up the button
    document.getElementById('menuBtn')?.addEventListener('click', clearToMenu);


    
    document.getElementById('bopBtn')?.addEventListener('click', () => {
      const wasBop = BOP_MODE;
      BOP_MODE ? exitBopMode() : enterBopMode();

      // If we just exited BOP, guarantee the map is alive.
      if (wasBop) {
        // Small timeout is fine; double-rAF in exitBopMode also covers it.
        setTimeout(() => ensureMapRendered({ force: true }), 0);
      }
    });
    
    document.querySelectorAll('#allButtons button[data-office]').forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.office;

        // P/G have no BOP → leave bop-mode
        if (BOP_MODE && (target === 'P' || target === 'G')) {
          exitBopMode();
          return;
        }

        // Only handle S/H while in BOP
        if (!BOP_MODE) return;

        const el = document.getElementById('bopChart');
        if (!el) return;

        // ✅ update OFFICE first so downstream logic sees the right office
        if (target === 'H' && YEAR === '2026') {
          OFFICE = 'H';
          setHeaderForBop(true);
          el.removeAttribute('hidden');
          showBopHouseChart();
          renderBopIfActive();    // now safe — OFFICE is 'H'
          startLivePolling?.();
        } else if (target === 'S') {
          OFFICE = 'S';
          setHeaderForBop(true);
          el.removeAttribute('hidden');
          showBopSenateChart();   // use the symmetric Senate reset
          renderBopIfActive();    // now safe — OFFICE is 'S'
          startLivePolling?.();
        } else {
          hideBopChart();
        }
      });
    });



    // Clear ink
    const clearInkBtn = document.getElementById("clearInkBtn");
    clearInkBtn?.addEventListener("click", () => {
      // prefer the dedicated ink/telestration layer if you added it:
      const ink = d3.select("#inkLayer");
      if (!ink.empty()) {
        ink.selectAll(".pen-stroke").remove();
      } else {
        // fallback: wipe any paths on the root if you didn't name a layer
        d3.selectAll(".pen-stroke").remove();
      }
      // reset in-memory stroke stack if you kept one
      if (window.strokes && Array.isArray(window.strokes)) window.strokes.length = 0;
    });

    
    // Call this after code paths that change OFFICE implicitly.
    function ensureBopConsistency(){
      if (BOP_MODE && OFFICE !== 'S' && OFFICE !== 'H') exitBopMode();
    }

    
    function leaderLineHTML(i, total, candidates){
      // only on the leader’s card
      if (i !== 0) return '';

      // Allow in generals (historic + 2026) AND in 2026 primaries (DEM/REP)
      const allowYearRace =
        ((RACE === 'G') && (YEAR === '2026' || HIST_GEN_YEARS.has(String(YEAR)))) ||
        ((YEAR === '2026') && (RACE === 'D' || RACE === 'R'));

      if (!allowYearRace) return '';

      // Offices that can show the line:
      // - P, S, G everywhere
      // - H only when zoomed to a district (kept as-is)
      const officeOK = ['P','S','G'].includes(OFFICE) || (OFFICE === 'H' && NAV_LEVEL === 2);
      if (!officeOK) return '';

      const first  = candidates?.[0];
      const second = candidates?.[1];
      if (!first || !second) return '';

      const leadVotes = (first.votes || 0) - (second.votes || 0);
      if (leadVotes <= 0) return '';

      const leadPct = total ? (100 * leadVotes / total) : 0;
      const fmt = n => Number(n || 0).toLocaleString('en-US');

      return `<div class="leadline">${leadPct.toFixed(1)}% ${fmt(leadVotes)} AHEAD</div>`;
    }



    // replace the old version
    // use party icon for S/G in 2016–2024 and 2026; and for H in 2016–2026
    function shouldUsePartyIcon(year, office){
      const y = String(year);
      const isHist = new Set(["2016","2018","2020","2022","2024"]).has(y);
      const isPPrimary = (office === 'P' && (RACE === 'D' || RACE === 'R'));

      // Always use party icons for S, G, H (all years & levels)
      if (office === 'S' || office === 'G' || office === 'H') return true;

      // Presidential: primaries use party icons, general uses headshots
      if (office === 'P') return isPPrimary;

      return false;
    }

    function imageSrcFor(cand){
      return shouldUsePartyIcon(YEAR, OFFICE)
        ? imgForParty(cand.party)
        : imgForCandidate(cand.name);
    }
    function imageMetaFor(cand){
      const useParty = shouldUsePartyIcon(YEAR, OFFICE);
      const alt =
        (OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H')
          ? 'Candidate'
          : (useParty ? (cand.party || 'Party') : cand.name);
      return {
        src: useParty ? imgForParty(cand.party) : imgForCandidate(cand.name),
        alt
      };
    }


    // Round to whole %; return "—" if missing
    function formatPI(raw){
      if (raw == null) return "—";
      const n = +raw;
      return Number.isFinite(n) ? String(Math.round(n)) : "—";
    }

    
    function syncPercentBolt(){
      if (BOP_MODE) return hidePercentInBolt();

      if (NAV_LEVEL === 1 && ['P','S','G'].includes(OFFICE) && selectedStateFP){
        return showPercentInBoltForState(selectedStateFP);
      }

      if (NAV_LEVEL === 2){
        if (OFFICE === 'H' && YEAR === '2026' && selectedDistrict){
          return showPercentInBoltForDistrict(selectedDistrict);
        }
        if (['P','S','G'].includes(OFFICE) && selectedFips){
          return showPercentInBoltForCounty(selectedFips);
        }
      }

      hidePercentInBolt();
    }

    function setPercentInBolt(raw){
      const el = document.getElementById('percentInBolt');
      if (!el) return;

      const n = formatPI(raw); // you already have formatPI()
      // If missing data, hide the bolt
      if (n === "—"){
        el.classList.add('hidden');
        el.innerHTML = "";
        return;
      }

      el.innerHTML = `
        <span class="wrap">
          <span class="big">${n}<span class="pct-sign">%</span></span>
          <span class="label">VOTES IN</span>
        </span>`;
      el.classList.remove('hidden');
    }

    function hidePercentInBolt(){
      const el = document.getElementById('percentInBolt');
      if (el) el.classList.add('hidden');
    }


    function showPercentInBoltForState(statefp){
        if (BOP_MODE) return hidePercentInBolt();
      const el = document.getElementById('percentInBolt');
      if (!el) return;

      if (['P','S','G'].includes(OFFICE) && NAV_LEVEL === 1){
        // Your existing logic to get the statewide % in
        const spi = findStatePercentIn(statefp);           // from the XML top line
        setPercentInBolt(spi);
      }else{
        hidePercentInBolt();
      }
    }
    function showPercentInBoltForCounty(fips){
        if (BOP_MODE) return hidePercentInBolt();
      const el = document.getElementById('percentInBolt');
      if (!el) return;

      if (['P','S','G'].includes(OFFICE) && NAV_LEVEL === 2){
        const row = countyData?.[fips];
        // Accept either `percent_in` or `PercentIn` depending on feed casing
        const rawPI = row?.percent_in ?? row?.PercentIn;
        setPercentInBolt(rawPI);
      }else{
        hidePercentInBolt();
      }
    }

    function showPercentInBoltForDistrict(did){
        if (BOP_MODE) return hidePercentInBolt();
      const el = document.getElementById('percentInBolt');
      if (!el) return;

      // Only for House districts while zoomed into a district (NAV_LEVEL === 2)
      if (OFFICE === 'H' && YEAR === '2026' && NAV_LEVEL === 2){
        // District rows live alongside county rows; find by district_id
        const row = Object.values(countyData || {}).find(x => x && x.district_id === did);
        // Accept either feed casing
        const rawPI = row?.percent_in ?? row?.PercentIn;
        setPercentInBolt(rawPI);
      } else {
        hidePercentInBolt();
      }
    }



    function splitName(full){
      const parts = String(full||"").trim().split(/\s+/);
      const last  = parts.pop() || "";
      const first = parts.join(" ");
      return { first, last };
    }
    function partyClass(p){
      const P = String(p||"IND").toUpperCase();
      return (P==="REP"||P==="R") ? "party-REP"
           : (P==="DEM"||P==="D") ? "party-DEM"
           : "party-IND";
    }


    function updateRaceAvailability(){
      const demBtn = document.querySelector('#allButtons button[data-race="D"]');
      const gopBtn = document.querySelector('#allButtons button[data-race="R"]');
      const genBtn = document.querySelector('#allButtons button[data-race="G"]');

      const isHistoricYear = HIST_YEARS_SET.has(YEAR);

      // Toggle engraved/disabled for primary buttons
      [demBtn, gopBtn].forEach(btn => {
        if (!btn) return;
        btn.disabled = isHistoricYear;
        btn.title = isHistoricYear ? "Primaries are unavailable for historic years (2016–2024)." : "";
        if (!isHistoricYear) btn.removeAttribute("title");
      });

      // If we’re in a historic year and a primary is currently active, bump to GEN
      if (isHistoricYear && (RACE === "D" || RACE === "R")) {
        RACE = "G";
        // swap active classes
        document.querySelectorAll('#allButtons button[data-race]').forEach(b=>b.classList.remove('active'));
        genBtn?.classList.add('active');
        updateHeaderTitle();
      }
    }


    function normalizeParty(p){
      if (!p) return 'IND';
      const s = String(p).trim().toUpperCase();
      if (s === 'D' || s === 'DEM' || s === 'DEMOCRAT' || s === 'DEMOCRATIC' || s === 'DFL') return 'DEM';
      if (s === 'R' || s === 'REP' || s === 'REPUBLICAN' || s === 'GOP') return 'REP';
      if (s === 'I' || s === 'IND' || s === 'NPA' || s === 'NP' || s === 'NPP' || s === 'UNA' || s === 'UNAFFILIATED') return 'IND';
      return 'IND';
    }

    
    
    function isNoData(rec){
      if (!rec) return true;
      const t = rec.total || 0;
      if (t > 0) return false;
      const cs = rec.candidates || [];
      return cs.length === 0 || cs.every(c => (c.votes || 0) === 0);
    }
    
    
    // Active selection (defaults)
    let OFFICE = document.querySelector("#allButtons button.active[data-office]")?.dataset.office || "S";
    let RACE   = document.querySelector("#allButtons button.active[data-race]")?.dataset.race || "D";
    let YEAR = document.querySelector("#yearButtons button.active")?.dataset.year || "2026";
    
    
    // Preload House geometries *after* YEAR exists
    (async () => {
      if (OFFICE === 'H') {
        await loadDistrictMapForYear(YEAR);
      }
    })();

    
    const OFFICE_TITLES = {
      P: "Presidential Race",
      G: "Gubernatorial Races",
      S: "Senate Elections",
      H: "House Elections"
    };
    const RACE_LABELS = {
      G: "General",
      D: "Democratic Primary",
      R: "Republican Primary"
    };
    
    // put these near the top of your script (before updateHeaderTitle is defined or called)
    let NAV_LEVEL = 0;             // 0=national, 1=state, 2=county
    let selectedStateFP = null;    // "PA" as "42" etc.
    let selectedFips = null;       // 5-digit county FIPS when zoomed to county


    function updateHeaderTitle(){
      // Top line
      const yearEl = document.getElementById('headerYear');
      const raceEl = document.getElementById('headerRace');
      const locEl  = document.getElementById('headerLocation');
      if (!yearEl || !raceEl || !locEl) return;

      // Map office to display label
      const OFFICE_SHORT = { P:'Presidential', G:'Gubernatorial', S:'Senate', H:'House' };

      // BOP override text (keeps your current behavior)
      // BOP: top line shows just the office; the line between the bands shows “Balance of Power”
      if (BOP_MODE && (OFFICE === 'S' || OFFICE === 'H')) {
        yearEl.textContent = YEAR || '';
        raceEl.textContent = (OFFICE === 'H' ? 'House' : 'Senate');
        locEl.textContent  = 'Balance of Power';
        return;
      }

      yearEl.textContent = YEAR || '';
      raceEl.textContent = OFFICE_SHORT[OFFICE] || 'Elections';

      // Location line: state OR state | county
      let locationText = '';
      if (NAV_LEVEL === 2 && selectedFips) {
        const st = selectedStateFP ? stateNameFromFP(selectedStateFP) : '';
        const co = countyNameFromFips(selectedFips) || '';
        locationText = st && co ? `${st} | ${co}` : (st || co);
      } else if (NAV_LEVEL === 1 && selectedStateFP) {
        locationText = stateNameFromFP(selectedStateFP) || '';
      } else {
        locationText = 'National'; // optional: set '' if you want it blank at national
      }
      locEl.textContent = locationText;
    }




    updateHeaderTitle();


    
    function getDistrictCall(did){
      const r = Object.values(countyData || {}).find(x => x && x.district_id === did);
      if (!r) return { status:null, winnerName:null, winnerParty:null, hasWinnerFlag:false };

      const status = r.race_call_status || r.RaceCallStatus || null;
      let winnerName  = r.race_called_winner_name || null;
      let winnerParty = r.race_called_winner_party || null;
      winnerParty = winnerParty ? String(winnerParty).toUpperCase() : null;

      // Only fall back to a candidate-level flag if the race is CALLED
      // and the row-level winner fields are missing.
      if (isRaceCalled(status) && (!winnerParty || !winnerName) && Array.isArray(r.candidates)) {
        const w = r.candidates.find(c => c && (c.winner === true || String(c.Winner||'').toUpperCase()==='X'));
        if (w) {
          if (!winnerName)  winnerName  = w.name || null;
          if (!winnerParty) winnerParty = String(w.party || '').toUpperCase() || null;
        }
      }

      // "Called" is decided by status, not by candidate flags.
      const hasWinnerFlag = isRaceCalled(status) && !!winnerParty;
      return { status, winnerName, winnerParty, hasWinnerFlag };
    }


    
    function getStateCall(statefp){
      for (const [key, row] of Object.entries(countyData)) {
        if (String(key).length === 5 && String(key).startsWith(statefp)) {
          const status = row.race_call_status || null;
          const winnerName  = row.race_called_winner_name || null;
          const winnerParty = row.race_called_winner_party || null;
          return { status, winnerName, winnerParty };
        }
      }
      return { status: null, winnerName: null, winnerParty: null };
    }



    function buildNationwideDistrictBackdrop(){
      if (OFFICE !== "H" || !districtShapes) return;

      // Render ALL districts (including the selected state's) behind everything
      neighborDistrictLayer
        .selectAll("path.cd-backdrop")
        .data(districtShapes, d => {
          const n = String(
            d.properties.CD119FP ||
            d.properties.CD118FP ||
            d.properties.CD116FP ||
            d.properties.CD115FP ||
            d.id
          ).padStart(2,"0");
          return `${d.properties.STATEFP}${n}`;
        })
        .join(enter => enter.append("path")
          .attr("class","cd-backdrop")
          .attr("d", path)
          .attr("fill", d => fillForFeature(d))
          .attr("stroke", "#fff")
          .attr("stroke-width", 0.35)
          .attr("vector-effect", "non-scaling-stroke")
          .style("pointer-events","none")
        )
        .attr("d", path)
        .attr("fill", d => fillForFeature(d));

      neighborDistrictLayer.lower();   // keep it behind the state outlines
    }


    
    updateOfficeAvailability();
    updateYearAvailability();
    updateHeaderTitle();
    updateRaceAvailability();

    function updateOfficeAvailability(){
      const pBtn = document.querySelector('#allButtons button[data-office="P"]');
      const disallowP = (YEAR === "2018" || YEAR === "2022"); // midterms: no presidential race

      // apply disabled state + tooltip
      pBtn.disabled = disallowP;
      pBtn.title = disallowP ? "Presidential race isn’t available for 2018 or 2022." : "";

      // if P is currently active in a disallowed year, bump to S
      if (disallowP && OFFICE === "P") {
        OFFICE = "S";
        document
          .querySelectorAll('#allButtons button[data-office]')
          .forEach(b => b.classList.remove('active'));
        document
          .querySelector('#allButtons button[data-office="S"]')
          ?.classList.add('active');
      }
    }

    function updateYearAvailability(){
      const disallowedYears = (OFFICE === "P") ? new Set(["2018","2022"]) : null;

      // Enable/disable the visible buttons
      document.querySelectorAll('#yearButtons button').forEach(btn=>{
        if (disallowedYears && disallowedYears.has(btn.dataset.year)) {
          btn.disabled = true;
          btn.title = "No Presidential race in midterm years.";
        } else {
          btn.disabled = false;
          btn.title = "";
        }
      });

      // If current YEAR is now illegal, jump to a nearby allowed year (prefer 2024 → 2020 → 2016 → 2026)
      if (disallowedYears && disallowedYears.has(YEAR)) {
        const fallbackOrder = ["2024","2020","2016","2026"];
        const target = fallbackOrder.find(y => !disallowedYears.has(y));
        const targetBtn = document.querySelector(`#yearButtons button[data-year="${target}"]`);
        if (targetBtn) targetBtn.click(); // triggers your existing year-switch logic
      }
    }

const statusEl = document.getElementById("status") || { textContent: "" };
const callsEl = document.getElementById("calls") || { textContent: "" };
const errsEl  = document.getElementById("errs")  || { textContent: "" };
const logBody = document.getElementById("logBody") || { insertAdjacentHTML(){}, innerHTML:"" };
const countyInfo = document.getElementById("countyInfo");
let projection, path, countyShapes, countyData = {}, lastLogSeq = 0;
let districtShapes;


let REQ_TOKEN = 0; // bump per load to ignore stale responses



let statesFeatures = null;
let statesSel = null;
// what is currently drawn in the map pane: 'states' | 'counties' | 'districts'
let CURRENT_GEOM = 'states';

let IS_ZOOMING = false;
let PAINT_DEFERRED = false;


const svg = d3.select("#map"); // add this
const underlay = svg.insert("rect", ":first-child")
  .attr("class", "map-underlay")
  .attr("x", 0).attr("y", 0)
  .attr("width", 1).attr("height", 1)
  .attr("fill", "transparent");
  underlay
    .style("cursor", "default")
    .on("click", (event) => {
      // Clicking anywhere that isn't a path (i.e., ocean/whitespace) hits this rect
      zoomOutOne();
      event.stopPropagation();
    });

const rootG = svg.append("g"); // add this
const nationalStateLayer = rootG.append("g"); // add this
const countyLayer        = rootG.append("g"); // add this
const neighborStateLayer = rootG.append("g"); // add this
const stateShadowLayer   = rootG.append("g").attr("pointer-events","none"); // add this
const activeStateOutline = rootG.append("g").attr("pointer-events","none"); // add this
const stateLayer         = rootG.append("g"); // add this

const neighborDistrictLayer = rootG.append("g"); // overlay only for H

const cityLayer = rootG.append("g").attr("id","cityLayer");

function bringCitiesToFront(){
  const n = cityLayer.node();
  if (n && n.parentNode) n.parentNode.appendChild(n); // move to top
  bringInkToFront?.(); // keep ink above everything
}


// lon/lat, plus optional pixel nudges (dx, dy) to avoid county borders
const CITY_INDEX = {
  NY: [
    { name: "New York City", lon: -74.0060, lat: 40.7128, dx: 0, dy: 0 },
    { name: "Buffalo",       lon: -78.8784, lat: 42.8864, dx: 0, dy: 0 },
    { name: "Rochester",     lon: -77.6088, lat: 43.1566, dx: 0, dy: 0 },
    { name: "Albany",        lon: -73.7562, lat: 42.6526, dx: 0, dy: 0 },
  ],
  IL: [
    { name: "Chicago",     lon: -87.6298, lat: 41.8781, dx: 0, dy: 0 },
    { name: "Springfield", lon: -89.6440, lat: 39.7980, dx: 0, dy: 0 },
    { name: "Rockford",    lon: -89.0937, lat: 42.2711, dx: 0, dy: 0 },
  ],
  CA: [
    { name: "Los Angeles",   lon: -118.2437, lat: 34.0522, dx: 0, dy: 0 },
    { name: "San Francisco", lon: -122.4194, lat: 37.7749, dx: 0, dy: 0 },
    { name: "San Diego",     lon: -117.1611, lat: 32.7157, dx: 0, dy: 0 },
    { name: "Sacramento",    lon: -121.4944, lat: 38.5816, dx: 0, dy: 0 },
    { name: "San Jose",      lon: -121.8863, lat: 37.3382, dx: 0, dy: 0 },
  ],
  TX: [
    { name: "Houston",     lon: -95.3698,  lat: 29.7604, dx: 0, dy: 0 },
    { name: "Dallas",      lon: -96.7970,  lat: 32.7767, dx: 0, dy: 0 },
    { name: "San Antonio", lon: -98.4936,  lat: 29.4241, dx: 0, dy: 0 },
    { name: "Austin",      lon: -97.7431,  lat: 30.2672, dx: 0, dy: 0 },
    { name: "El Paso",     lon: -106.4850, lat: 31.7619, dx: 0, dy: 0 },
  ],
  FL: [
    { name: "Miami",       lon: -80.1918, lat: 25.7617, dx: 0, dy: 0 },
    { name: "Tampa",       lon: -82.4572, lat: 27.9506, dx: 0, dy: 0 },
    { name: "Orlando",     lon: -81.3792, lat: 28.5383, dx: 0, dy: 0 },
    { name: "Jacksonville",lon: -81.6557, lat: 30.3322, dx: 0, dy: 0 },
    { name: "Tallahassee", lon: -84.2807, lat: 30.4383, dx: 0, dy: 0 },
  ],
  PA: [
    { name: "Philadelphia", lon: -75.1652, lat: 39.9526, dx: 0, dy: 0 },
    { name: "Pittsburgh",  lon: -79.9959, lat: 40.4406, dx: 0, dy: 0 },
    { name: "Harrisburg",  lon: -76.8867, lat: 40.2732, dx: 0, dy: 0 },
  ],
  OH: [
    { name: "Columbus",   lon: -82.9988, lat: 39.9612, dx: 0, dy: 0 },
    { name: "Cleveland",  lon: -81.6944, lat: 41.4993, dx: 0, dy: 0 },
    { name: "Cincinnati", lon: -84.5120, lat: 39.1031, dx: 0, dy: 0 },
  ],
  MI: [
    { name: "Detroit",      lon: -83.0458, lat: 42.3314, dx: 0, dy: 0 },
    { name: "Grand Rapids", lon: -85.6681, lat: 42.9634, dx: 0, dy: 0 },
    { name: "Lansing",      lon: -84.5555, lat: 42.7325, dx: 0, dy: 0 },
  ],
  GA: [
    { name: "Atlanta",  lon: -84.3880, lat: 33.7490, dx: 0, dy: 0 },
    { name: "Augusta",  lon: -82.0105, lat: 33.4735, dx: 0, dy: 0 },
    { name: "Columbus", lon: -84.9877, lat: 32.4610, dx: 0, dy: 0 },
    { name: "Savannah", lon: -81.0912, lat: 32.0809, dx: 0, dy: 0 },
  ],
  NC: [
    { name: "Charlotte", lon: -80.8431, lat: 35.2271, dx: 0, dy: 0 },
    { name: "Raleigh",   lon: -78.6382, lat: 35.7796, dx: 0, dy: 0 },
    { name: "Greensboro",lon: -79.7920, lat: 36.0726, dx: 0, dy: 0 },
  ],
  VA: [
    { name: "Virginia Beach", lon: -75.9780, lat: 36.8529, dx: 0, dy: 0 },
    { name: "Richmond",       lon: -77.4360, lat: 37.5407, dx: 0, dy: 0 },
    { name: "Norfolk",        lon: -76.2859, lat: 36.8508, dx: 0, dy: 0 },
  ],
  AZ: [
    { name: "Phoenix", lon: -112.0740, lat: 33.4484, dx: 0, dy: 0 },
    { name: "Tucson",  lon: -110.9747, lat: 32.2226, dx: 0, dy: 0 },
  ],
  NV: [
    { name: "Las Vegas",   lon: -115.1398, lat: 36.1699, dx: 0, dy: 0 },
    { name: "Reno",        lon: -119.8138, lat: 39.5296, dx: 0, dy: 0 },
    { name: "Carson City", lon: -119.7674, lat: 39.1638, dx: 0, dy: 0 },
  ],
  WA: [
    { name: "Seattle",  lon: -122.3321, lat: 47.6062, dx: 0, dy: 0 },
    { name: "Spokane",  lon: -117.4260, lat: 47.6588, dx: 0, dy: 0 },
    { name: "Olympia",  lon: -122.9007, lat: 47.0379, dx: 0, dy: 0 },
  ],
  OR: [
    { name: "Portland", lon: -122.6784, lat: 45.5152, dx: 0, dy: 0 },
    { name: "Eugene",   lon: -123.0868, lat: 44.0521, dx: 0, dy: 0 },
    { name: "Salem",    lon: -123.0351, lat: 44.9429, dx: 0, dy: 0 },
  ],
  CO: [
    { name: "Denver",           lon: -104.9903, lat: 39.7392, dx: 0, dy: 0 },
    { name: "Colorado Springs", lon: -104.8214, lat: 38.8339, dx: 0, dy: 0 },
  ],
  MN: [
    { name: "Minneapolis", lon: -93.2650, lat: 44.9778, dx: 0, dy: 0 },
    { name: "St. Paul",    lon: -93.0900, lat: 44.9537, dx: 0, dy: 0 },
  ],
  WI: [
    { name: "Milwaukee", lon: -87.9065, lat: 43.0389, dx: 0, dy: 0 },
    { name: "Madison",   lon: -89.4012, lat: 43.0731, dx: 0, dy: 0 },
  ],
  MO: [
    { name: "St. Louis",       lon: -90.1994, lat: 38.6270, dx: 0, dy: 0 },
    { name: "Kansas City",     lon: -94.5786, lat: 39.0997, dx: 0, dy: 0 },
    { name: "Jefferson City",  lon: -92.1735, lat: 38.5767, dx: 0, dy: 0 },
  ],
  MA: [
    { name: "Boston",     lon: -71.0589, lat: 42.3601, dx: 0, dy: 0 },
    { name: "Worcester",  lon: -71.8023, lat: 42.2626, dx: 0, dy: 0 },
    { name: "Springfield",lon: -72.5898, lat: 42.1015, dx: 0, dy: 0 },
  ],
  ME: [
    { name: "Portland", lon: -70.2568, lat: 43.6591, dx: 0, dy: 0 },
    { name: "Augusta",  lon: -69.7795, lat: 44.3106, dx: 0, dy: 0 },
  ],
  NH: [
    { name: "Manchester", lon: -71.4548, lat: 42.9956, dx: 0, dy: 0 },
    { name: "Concord",    lon: -71.5376, lat: 43.2081, dx: 0, dy: 0 },
  ],
  VT: [
    { name: "Burlington", lon: -73.2121, lat: 44.4759, dx: 0, dy: 0 },
    { name: "Montpelier", lon: -72.5754, lat: 44.2601, dx: 0, dy: 0 },
  ],
  RI: [
    { name: "Providence", lon: -71.4128, lat: 41.8240, dx: 0, dy: 0 },
  ],
  CT: [
    { name: "Hartford",   lon: -72.6734, lat: 41.7658, dx: 0, dy: 0 },
    { name: "New Haven",  lon: -72.9279, lat: 41.3083, dx: 0, dy: 0 },
    { name: "Bridgeport", lon: -73.1894, lat: 41.1792, dx: 0, dy: 0 },
  ],
  NJ: [
    { name: "Newark",  lon: -74.1724, lat: 40.7357, dx: 0, dy: 0 },
    { name: "Trenton", lon: -74.7429, lat: 40.2171, dx: 0, dy: 0 },
  ],
  DE: [
    { name: "Wilmington", lon: -75.5398, lat: 39.7391, dx: 0, dy: 0 },
    { name: "Dover",      lon: -75.5244, lat: 39.1582, dx: 0, dy: 0 },
  ],
  MD: [
    { name: "Baltimore", lon: -76.6122, lat: 39.2904, dx: 0, dy: 0 },
    { name: "Annapolis", lon: -76.4922, lat: 38.9784, dx: 0, dy: 0 },
  ],
  DC: [
    { name: "Washington", lon: -77.0369, lat: 38.9072, dx: 0, dy: 0 },
  ],
  AL: [
    { name: "Birmingham", lon: -86.8104, lat: 33.5186, dx: 0, dy: 0 },
    { name: "Montgomery", lon: -86.3077, lat: 32.3792, dx: 0, dy: 0 },
    { name: "Mobile",     lon: -88.0399, lat: 30.6954, dx: 0, dy: 0 },
  ],
  MS: [
    { name: "Jackson", lon: -90.1848, lat: 32.2988, dx: 0, dy: 0 },
  ],
  TN: [
    { name: "Nashville", lon: -86.7816, lat: 36.1627, dx: 0, dy: 0 },
    { name: "Memphis",   lon: -90.0490, lat: 35.1495, dx: 0, dy: 0 },
    { name: "Knoxville", lon: -83.9207, lat: 35.9606, dx: 0, dy: 0 },
  ],
  KY: [
    { name: "Louisville", lon: -85.7585, lat: 38.2527, dx: 0, dy: 0 },
    { name: "Lexington",  lon: -84.5037, lat: 38.0406, dx: 0, dy: 0 },
    { name: "Frankfort",  lon: -84.8733, lat: 38.2009, dx: 0, dy: 0 },
  ],
  WV: [
    { name: "Charleston", lon: -81.6326, lat: 38.3498, dx: 0, dy: 0 },
  ],
  IA: [
    { name: "Des Moines", lon: -93.6250, lat: 41.5868, dx: 0, dy: 0 },
  ],
  ND: [
    { name: "Fargo",    lon: -96.7898,  lat: 46.8772, dx: 0, dy: 0 },
    { name: "Bismarck", lon: -100.7837, lat: 46.8083, dx: 0, dy: 0 },
  ],
  SD: [
    { name: "Sioux Falls", lon: -96.7311,  lat: 43.5446, dx: 0, dy: 0 },
    { name: "Pierre",      lon: -100.3510, lat: 44.3683, dx: 0, dy: 0 },
  ],
  NE: [
    { name: "Omaha",  lon: -95.9345, lat: 41.2565, dx: 0, dy: 0 },
    { name: "Lincoln",lon: -96.7026, lat: 40.8136, dx: 0, dy: 0 },
  ],
  KS: [
    { name: "Wichita", lon: -97.3301, lat: 37.6872, dx: 0, dy: 0 },
    { name: "Topeka",  lon: -95.6752, lat: 39.0473, dx: 0, dy: 0 },
  ],
  OK: [
    { name: "Oklahoma City", lon: -97.5164, lat: 35.4676, dx: 0, dy: 0 },
    { name: "Tulsa",         lon: -95.9928, lat: 36.1540, dx: 0, dy: 0 },
  ],
  NM: [
    { name: "Albuquerque", lon: -106.6504, lat: 35.0844, dx: 0, dy: 0 },
    { name: "Santa Fe",    lon: -105.9378, lat: 35.6870, dx: 0, dy: 0 },
  ],
  UT: [
    { name: "Salt Lake City", lon: -111.8910, lat: 40.7608, dx: 0, dy: 0 },
  ],
  MT: [
    { name: "Billings", lon: -108.5007, lat: 45.7833, dx: 0, dy: 0 },
    { name: "Helena",   lon: -112.0391, lat: 46.5891, dx: 0, dy: 0 },
  ],
  AR: [
    { name: "Little Rock", lon: -92.2896, lat: 34.7465, dx: 0, dy: 0 },
  ],
  IN: [
    { name: "Indianapolis", lon: -86.1581, lat: 39.7684, dx: 0, dy: 0 },
  ],
  WY: [
    { name: "Cheyenne", lon: -104.8202, lat: 41.1400, dx: 0, dy: 0 },
  ],
  LA: [
    { name: "New Orleans", lon: -90.0715, lat: 29.9511, dx: 0, dy: 0 },
  ],
  ID: [
    { name: "Boise", lon: -116.2023, lat: 43.6150, dx: 0, dy: 0 },
  ],
  AK: [
    { name: "Anchorage", lon: -149.9003, lat: 61.2181, dx: 0, dy: 0 },
    { name: "Juneau",    lon: -134.4197, lat: 58.3019, dx: 0, dy: 0 },
  ],
  HI: [
    { name: "Honolulu", lon: -157.8581, lat: 21.3099, dx: 0, dy: 0 },
  ],
};


    const CITY_MIN_K = 2.2;   // hide labels below this zoom (tweak to taste)


const inkLayer = rootG.append("g")
  .attr("id","inkLayer")
  .attr("class","ink-layer");

function bringInkToFront(){
  const n = inkLayer.node();
  if (n && n.parentNode) n.parentNode.appendChild(n);
}
bringInkToFront();
bringCitiesToFront();


// Read core colors from CSS vars (falls back to hex if vars missing)
const CSS_VARS = getComputedStyle(document.documentElement);
const COLOR_GOP = (CSS_VARS.getPropertyValue('--gop') || '#ec1d19').trim();
const COLOR_DEM = (CSS_VARS.getPropertyValue('--dem') || '#0067cb').trim();
const COLOR_IND = '#8e44ad'; // fallback for others/IND
const COLOR_BG  = '#ffffff'; // your map's neutral


// NEW: light versions for neighbor overlay
const COLOR_GOP_LIGHT = (CSS_VARS.getPropertyValue('--gop-light') || '#f7938f').trim();
const COLOR_DEM_LIGHT = (CSS_VARS.getPropertyValue('--dem-light') || '#8bb0e2').trim();
const COLOR_IND_LIGHT = (CSS_VARS.getPropertyValue('--ind-light') || '#d2b8ff').trim();


// === BOP header presentation ===
let __savedHeader = { race: null, location: null };

function setHeaderForBop(on){
  const raceEl = document.getElementById('headerRace');
  const locEl  = document.getElementById('headerLocation');
  if (!raceEl || !locEl) return;

  if (on){
    // remember current labels so we can restore later
    if (__savedHeader.race === null)     __savedHeader.race     = raceEl.textContent;
    if (__savedHeader.location === null) __savedHeader.location = locEl.textContent;

    // top line: just the office (no “— Balance of Power”)
    raceEl.textContent = (OFFICE === 'H' ? 'HOUSE' : 'SENATE');

    // location row (between blue/red lines): show “Balance of Power”
    locEl.textContent = 'BALANCE OF POWER';
  } else {
    // restore whatever was showing before BOP (e.g., “UNITED STATES”, a state, county, etc.)
    if (__savedHeader.race !== null)     raceEl.textContent     = __savedHeader.race;
    if (__savedHeader.location !== null) locEl.textContent      = __savedHeader.location;
    __savedHeader = { race: null, location: null };
  }
}

    
    
    
    // ---------- menu helpers ----------
    function unhide(el){ if(el){ el.removeAttribute('hidden'); el.style.removeProperty('display'); } }
    function hide(el){ if(el){ el.setAttribute('hidden',''); el.style.display = 'none'; } }

    function leaveMenuMode(){
      // remove the overlay
      document.getElementById('mainMenu')?.remove();

      // drop the CSS state that hides the UI
      document.body.classList.remove('menu-mode');

      // belt & suspenders: clear any inline display:none/hidden we may have set earlier
      const unhideAll = (sel) => {
        document.querySelectorAll(sel).forEach(el => {
          el.removeAttribute('hidden');
          el.style.removeProperty('display');
          el.style.removeProperty('visibility');
        });
      };
      unhideAll('header, #statusLegend, #zoomBox, .map-shell, .left-panel, .right-panel');

      // after layout is visible again, ensure the map/panel paint
      requestAnimationFrame(() => {
        try { ensureMapRendered?.({ force:true }); } catch(e){}
        try { renderNationalPanel?.(); } catch(e){}
        try { syncPercentBolt?.(); } catch(e){}
      });
    }


    function goToOfficeYear(targetOffice, targetYear){
      // leave menu first so buttons exist/are visible
      leaveMenuMode();

      // 1) Click YEAR = 2026 (or whatever you pass)
      const ybtn = document.querySelector(`#yearButtons button[data-year="${targetYear}"]`);
      if (ybtn) ybtn.click();

      // 2) Click OFFICE (P/S/G/H)
      const obtn = document.querySelector(`#allButtons button[data-office="${targetOffice}"]`);
      if (obtn) obtn.click();

      // optional: ensure header/location text is sane when returning from menu
      const HL = document.getElementById('headerLocation');
      if (HL && !HL.textContent) HL.textContent = 'UNITED STATES';

      // nudge render loops in case nothing else fires
      try { ensureMapRendered?.({ force:true }); } catch(e){}
      try { startLivePolling?.(); } catch(e){}
    }


    function ensureMapScaffold(){
      const svg = d3.select('.map-shell svg');
      if (svg.empty()) return null;

      // idempotent creator
      const ensure = (id) => {
        let g = svg.select(`g#${id}`);
        if (g.empty()) g = svg.append('g').attr('id', id);
        return g;
      };

      // Recreate the groups your app expects (names match your code)
      window.nationalStateLayer   = ensure('nationalStateLayer');
      window.countyLayer          = ensure('countyLayer');
      window.neighborStateLayer   = ensure('neighborStateLayer');
      window.neighborDistrictLayer= ensure('neighborDistrictLayer');
      window.stateShadowLayer     = ensure('stateShadowLayer');
      window.activeStateOutline   = ensure('activeStateOutline');
      window.stateLayer           = ensure('stateLayer');

      return svg;
    }

    
// Small helpers for party → color
function partySolid(p){
  const P = String(p||'IND').toUpperCase();
  if (P === 'REP') return COLOR_GOP;
  if (P === 'DEM') return COLOR_DEM;
  return COLOR_IND;
}
function partyDim(p){
  const P = String(p||'IND').toUpperCase();
  if (P === 'REP') return COLOR_GOP_LIGHT;
  if (P === 'DEM') return COLOR_DEM_LIGHT;
  return COLOR_IND_LIGHT;
}

function slugifyCandidateName(name){
  return String(name || "")
    .toLowerCase()
    .replace(/\./g,"")        // remove dots like “J.R.”
    .replace(/[^a-z0-9]+/g,"-")
    .replace(/^-+|-+$/g,"");
}
function imgForCandidate(name){
  const slug = slugifyCandidateName(name).replace(/-/g,""); // “donald-trump” → “donaldtrump”
  return `../images/${slug}.png`;
}
    
    
    // Robust fallback for missing headshots → party icon (no console spam)
    (function installImageFallback(){
      if (window.__installedImageFallback) return;
      window.__installedImageFallback = true;

      document.addEventListener('error', (ev) => {
        const img = ev.target;
        if (!(img instanceof HTMLImageElement)) return;
        if (img.dataset?.fallbackApplied === '1') return;

        // If it's not one of the known party badges (dem/rep/ind/lib/grn/npa), treat as a headshot
        const isHeadshot = /\/images\/(?!dem|rep|ind|lib|grn|npa)[a-z0-9_-]+\.png$/i.test(img.src);

        if (isHeadshot) {
          const party = (img.dataset?.party || 'IND').toUpperCase();
          img.dataset.fallbackApplied = '1';     // avoid loops
          try { img.src = imgForParty(party); }  // swap to party icon
          catch { img.src = imgForParty('IND'); }
        }
      }, true); // capture phase catches resource errors
    })();

    
    
    function isNoSenate2026(usps) {
      if (!usps) return false;
      const yearOK  = (typeof YEAR !== 'undefined') && YEAR === '2026';
      const officeOK= (typeof OFFICE !== 'undefined') && OFFICE === 'S';
      const raceOK  = (typeof RACE !== 'undefined') && (RACE === 'G' || RACE === 'D' || RACE === 'R');
      return yearOK && officeOK && raceOK && SENATE_2026_NO_RACE.has(usps);
    }

    
    function resolveImageFor(year, office, cand){
      // party icons for H historic years (your earlier logic), else headshots
      const useParty =
        shouldUsePartyIcon(year, office) || (office === "H" && HOUSE_HIST_YEARS.has(year));
      return useParty ? imgForParty(cand.party) : imgForCandidate(cand.name);
    }

    function preloadImages(urls){
      const seen = new Set();
      urls.forEach(u => {
        if (!u || seen.has(u)) return;
        seen.add(u);
        const im = new Image();
        im.decoding = "async";
        im.loading  = "eager";
        im.src = u;
      });
    }


    preloadImages(['../images/dem.png','../images/rep.png','../images/ind.png','../images/grn.png','../images/lib.png']);

    
    function imgForParty(party){
      const P = String(party || 'IND').toUpperCase();
      // allow common alternates to land on sensible filenames
      const map = { DEM:'dem', D:'dem', REP:'rep', R:'rep', IND:'ind', I:'ind', LIB:'lib', L:'lib', GRN:'grn', G:'grn', NPA:'npa' };
      const base = map[P] || P.toLowerCase(); // fallback to lowercased party code
      return `../images/${base}.png`;
    }


// Build a district id like your data rows (e.g. "0601")
function districtIdFromFeature(d){
  const s = String(d.properties.STATEFP).padStart(2,'0');
  const n = String(
    d.properties.CD119FP ||
    d.properties.CD118FP ||
    d.properties.CD116FP ||
    d.properties.CD115FP ||
    d.id
  ).padStart(2,'0');
  return `${s}${n}`;
}

// Find leader party for a district row
function leaderPartyForDistrictRow(row){
  if (!row || !Array.isArray(row.candidates) || row.candidates.length === 0) return null;
  const top = [...row.candidates].sort((a,b)=>(b.votes||0)-(a.votes||0))[0];
  return top?.party || 'IND';
}

// Unified district fill used both in national view (backdrop) and inside a drilled state
// options: { insideSelected: boolean }  → when true, respect "called → solid, else dimmed" rule
function fillForDistrictFeature(d, { insideSelected=false } = {}){
  const did = districtIdFromFeature(d);
  const row = Object.values(countyData).find(x => x.district_id === did);
  const total = row?.total || 0;
  if (!row || total === 0) return COLOR_NO_DATA;

  const { status, winnerParty } = getDistrictCall(did);
  const leaderParty = winnerParty || leaderPartyForDistrictRow(row) || 'IND';

  if (insideSelected){
    // drilled-in state: full color if called, otherwise dimmed leader color
    return isRaceCalled(status) ? partySolid(leaderParty) : partyDim(leaderParty);
  }
  // other states (or national backdrop): always dimmed (keeps your current look)
  return partyDim(leaderParty);
}



const paintEl = document.getElementById("paintProgressRight") || { textContent: "" };
let painting = false, restartAfterPaint = false;
let countiesSel = null;
const HIST_CACHE = Object.create(null);
// Historic years supported for Senate (GEN)
const SEN_HIST_YEARS = new Set(["2016","2018","2020","2022","2024"]);
// keep this near the other HIST_* flags
const HOUSE_HIST_YEARS = new Set(["2016","2018","2020","2022","2024"]);
const DISTRICT_TOPO_CACHE = Object.create(null);
const GOV_HIST_YEARS = new Set(["2016","2018","2020","2022","2024"]);
// put this near your HIST_* sets
const HIST_BASE = window.HIST_BASE || '../HistoricData'; // adjust '../' as needed





// add this (so we can reset zoom from the button)
let zoom;
let zoomToFeature = () => {};
let focusStateByPrefix = () => {};

let focusHouseStateByPrefix = () => {};


// add this
function zoomOutOne(){
  // If we’re at district level, go up to the *state* view
  if (NAV_LEVEL === 2 && selectedStateFP){
    NAV_LEVEL = 1;
    updateHeaderTitle();
    hidePercentInBolt();    
    const sf = statesFeatures.find(s => String(s.id).padStart(2,"0") === selectedStateFP);

    // House: return to the *state's districts* view (not national)
    if (OFFICE === "H"){
      selectedDistrict = null;                 // clear the clicked CD
      countyLayer.selectAll("path.district").classed("highlight", false);
      if (sf){
        focusHouseStateByPrefix(selectedStateFP, sf); // rebuild that state's districts
        colorizeInstant(true);
        zoomToFeature(sf, 8);                  // frame the state
        renderStatePanel(selectedStateFP);
      }
      syncPercentBolt();
      return;                                  // ✅ stop here (don’t fall through to national)
    }

    // P/S/G: go back to the state's counties view (existing behavior)
    selectedFips = null;
    if (sf){
      focusStateByPrefix(selectedStateFP, sf);
      colorizeInstant(true);
      zoomToFeature(sf, 8);
      renderStatePanel(selectedStateFP);
    }
    return;
  }

  // If we’re at state level, go up to national view
  if (NAV_LEVEL === 1){
    selectedStateFP = null;
    selectedFips = null;
    selectedDistrict = null;
    NAV_LEVEL = 0;
    updateHeaderTitle();
    hidePercentInBolt();

    stateLayer.style("pointer-events","auto");
    if (OFFICE === "P" || OFFICE === "G" || OFFICE === "S") {
         drawShapes();            // builds national state polygons right away
         colorizeInstant(true);   // paints states in winner color
         // (optional) make sure states sit above anything lingering
         nationalStateLayer.style("pointer-events", "none"); // or comment this out and do the next line
          stateLayer.raise();
          bringInkToFront();
          bringCitiesToFront();
       }

    // Smooth zoom + cross-fade
    if (OFFICE === "H") buildNationwideDistrictBackdrop();
    d3.select("#map")
      .transition("zoomOutToNational")
      .duration(900)
      .ease(d3.easeCubicInOut)
      .on("start", () => {
        // fade current state view (districts + outlines) so it doesn’t “pop”
        countyLayer.transition().duration(200).style("opacity", 0);
        activeStateOutline.transition().duration(250).style("opacity", 0);
        stateShadowLayer.transition().duration(250).style("opacity", 0);
      })
      .call(zoom.transform, INITIAL_VIEW)
      .on("end", () => {
        // rebuild national view after camera lands
        if (OFFICE !== "P") {
                drawShapes();
                colorizeInstant(true);
              }
        // restore opacities for future drill-ins
        countyLayer.style("opacity", 1);
        neighborDistrictLayer.selectAll("path.cd-backdrop").remove();
        activeStateOutline.style("opacity", 1);
        stateShadowLayer.style("opacity", 1);
        if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
            }
        syncPercentBolt(); 
      });

    return;
  }

  // already at national; nothing to do
}


    // add this
    document.getElementById("zoomOutBtn").onclick = zoomOutOne;

    function getCitiesForView(){
      // hide labels when zoomed out or at national
      if (currentZoomK < CITY_MIN_K || NAV_LEVEL === 0) return [];
      if (!(NAV_LEVEL === 1 || NAV_LEVEL === 2)) return [];
      const usps = USPS_BY_STATEFP?.[selectedStateFP] || null;
      return (usps && CITY_INDEX[usps]) ? CITY_INDEX[usps] : [];
    }


    function updateCityLabels(){
      const data = getCitiesForView();
      const join = cityLayer.selectAll("g.city-label").data(data, d => d.name);
      join.exit().remove();

      const ent = join.enter().append("g").attr("class","city-label");
      ent.append("rect");
      ent.append("text");

      const sel = ent.merge(join);

      sel.each(function(d){
        const p = projection([d.lon, d.lat]);
        const g = d3.select(this);
        if (!p) { g.attr("display","none"); return; }
        g.attr("display", null);

        // 1) position with no scale so measurements are in CSS px
        g.attr("transform", `translate(${p[0] + (d.dx||0)}, ${p[1] + (d.dy||0)})`);

        const t = g.select("text")
          .text(d.name)
          .attr("text-anchor","middle")
          .attr("dy",".35em");

        const bb = t.node().getBBox();
        g.select("rect")
          .attr("x", bb.x - 8)
          .attr("y", bb.y - 4)
          .attr("width",  bb.width + 16)
          .attr("height", bb.height + 8);

        // 2) apply inverse zoom so on-screen size stays constant
        const s = 1 / (currentZoomK || 1);
        g.attr("transform",
          `translate(${p[0] + (d.dx||0)}, ${p[1] + (d.dy||0)}) scale(${s})`);
      });
    }



function isHistoricMode() {
  // P: 2016/2020/2024 GEN
  if (OFFICE === "P" && RACE === "G" && (YEAR === "2016" || YEAR === "2020" || YEAR === "2024")) return true;
  // G: 2016–2024 GEN (per your GOV_HIST_YEARS)
  if (OFFICE === "G" && RACE === "G" && GOV_HIST_YEARS.has(YEAR)) return true;
  // S: 2016–2024 GEN (per your SEN_HIST_YEARS)
  if (OFFICE === "S" && RACE === "G" && SEN_HIST_YEARS.has(YEAR)) return true;
  // H: 2024 GEN (you’ll load district data when you add the parser)
  if (OFFICE === "H" && RACE === "G" && HOUSE_HIST_YEARS.has(YEAR)) return true;
  return false;
}


// Postal abbreviations to try for historic 2024 Presidential (GEN) XML
const HIST_STATES = [
  "AL","AK","AZ","AR","CA","CO","CT","DC","DE","FL","GA","HI","IA","ID","IL","IN","KS",
  "KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV",
  "NY","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VA","VT","WA","WI","WV","WY"
];

let pollId = null;
function startLivePolling(){
  if (pollId) return;
  pollId = setInterval(pollAndRefresh, 5_000);   // call our wrapper
}
function stopLivePolling(){
  if (!pollId) return;
  clearInterval(pollId);
  pollId = null;
}


    // Which district map to use per *election* year
    const CD_MAP_BY_YEAR = {
      "2016": "/topojson/tl_2017_us_cd115.json",       // 115th
      "2018": "/topojson/tl_2019_us_cd116.json",       // 116th
      "2020": "/topojson/tl_2019_us_cd116.json",       // 117th uses same geometry
      "2022": "/topojson/cb_2023_us_cd118_5m.json",    // 118th
      "2024": "/topojson/cb_2024_us_cd119_500k.json",   // 119th
      "2026": "/topojson/cb_2024_us_cd119_500k.json"    // 120th
    };

    async function loadDistrictMapForYear(year){
      const file = CD_MAP_BY_YEAR[year] || CD_MAP_BY_YEAR["2024"];
      if (DISTRICT_TOPO_CACHE[file]) {
        districtShapes = DISTRICT_TOPO_CACHE[file];
        return;
      }
      const topo = await d3.json(file);
      const objKey = Object.keys(topo.objects)[0];
      const feats = topojson.feature(topo, topo.objects[objKey]).features;
      DISTRICT_TOPO_CACHE[file] = feats;   // memoize
      districtShapes = feats;
    }

    
    function aggregateHouseUncalledLeaderCountsNational(){
      const seen = new Set();                                       // de-dupe districts
      let called   = { DEM:0, REP:0, IND:0 };
      let uncalled = { DEM:0, REP:0, IND:0 };
      let noData   = 0;

      for (const row of Object.values(countyData || {})){
        const did = row?.district_id;
        if (!did || seen.has(did)) continue;
        seen.add(did);

        // treat “no data / all-zero” as its own bucket
        if (!row || isNoData(row) || (row.total || 0) === 0){
          noData++;
          continue;
        }
        
        const { status, winnerParty } = getDistrictCall(did);
        if (isRaceCalled(status) && winnerParty){
          const p = normalizeParty(winnerParty);
          if (p === 'DEM') called.DEM++;
          else if (p === 'REP') called.REP++;
          else called.IND++;
        } else {
          const leader = normalizeParty(leaderPartyForDistrictRow(row) || 'IND');
          if (leader === 'DEM') uncalled.DEM++;
          else if (leader === 'REP') uncalled.REP++;
          else uncalled.IND++;
        }
      }
      
      const total =
        called.DEM + called.REP + called.IND +
        uncalled.DEM + uncalled.REP + uncalled.IND +
        noData;

      return { called, uncalled, noData, total };
    }


    
    // === NATIONAL roll-up (all rows currently in countyData) ===
    // === NATIONAL roll-up (filtered to current office) ===
    function aggregateNationalCandidates(){
      const tally = new Map();
      let total = 0;

      for (const [key, row] of Object.entries(countyData)) {
        // Only include rows for the *current* office
        if (OFFICE === "H") {
          // district-level rows only
          if (!row.district_id) continue;
        } else {
          // P/S/G: county-level rows only (5-digit FIPS keys)
          if (String(key).length !== 5) continue;
        }

        // Optional safety: skip mismatched race types if present on the row
        if (row.raceTypeId && row.raceTypeId !== RACE) continue;
        if (row.raceType && row.raceType !== RACE) continue;

        for (const c of (row.candidates || [])) {
          const k = (c.name || "") + "|" + (c.party || "");
          tally.set(k, (tally.get(k) || 0) + (c.votes || 0));
        }
        total += (row.total || 0);
      }

      const candidates = [...tally.entries()]
        .map(([k, votes]) => { const [name, party] = k.split("|"); return { name, party, votes }; })
        .sort((a,b) => b.votes - a.votes);

      return { total, candidates };
    }
    
    
    function partyLabel(p){
      const P = String(p||"IND").toUpperCase();
      if (P === "DEM") return "Democrats";
      if (P === "REP") return "Republicans";
      if (P === "IND") return "Independents";
      return P; // fall back to showing the party code (LIB, GRN, etc.)
    }

    
    
    function aggregateHouseCalledWinnersNational(){
      const counts = new Map();         // party → seats called
      const seen   = new Set();         // district_id de-dupe (belt & suspenders)

      for (const row of Object.values(countyData || {})){
        const did = row?.district_id;
        if (!did || seen.has(did)) continue;
        seen.add(did);

        const { status, winnerParty } = getDistrictCall(did);  // you already have this helper
        if (isRaceCalled(status) && winnerParty){
          const key = String(winnerParty).toUpperCase();
          counts.set(key, (counts.get(key) || 0) + 1);
        }
      }

      // return sorted array of { party, label, count }
      return Array.from(counts.entries())
        .map(([party, count]) => ({ party, label: partyLabel(party), count }))
        .sort((a,b) => b.count - a.count);
    }

    function aggregateHouseCalledWinnersForState(statefp){
      const counts = new Map();   // party → seats called (in this state only)
      const seen   = new Set();   // de-dupe district_ids just in case

      for (const row of Object.values(countyData || {})){
        const did = row?.district_id;
        if (!did || seen.has(did)) continue;
        if (!String(did).startsWith(statefp)) continue;   // only this state’s CDs
        seen.add(did);

        const { status, winnerParty } = getDistrictCall(did);
        if (isRaceCalled(status) && winnerParty){
          const key = String(winnerParty).toUpperCase();
          counts.set(key, (counts.get(key) || 0) + 1);
        }
      }

      return Array.from(counts.entries())
        .map(([party, count]) => ({ party, label: partyLabel(party), count }))
        .sort((a,b) => b.count - a.count);
    }

    
    // Replace your current aggregateSenateCalledWinnersNational with this version
    // drop-in replacement
    function aggregateSenateCalledWinnersNational(){
      const counts = new Map(); // party → seats called

      for (const s of (statesFeatures || [])){
        const statefp = String(s.id).padStart(2,"0");
        if (!VALID_SENATE_STATEFPS.has(statefp)) continue;   // 50 states only
        const usps = USPS_BY_STATEFP?.[statefp];
        if (isNoRace2026(usps)) continue;                  // ⟵ exclude no-race states


        // Prefer the topline cache for S 2026 GEN
        
        const tl   = usps ? getSenate2026Topline(usps) : null;

        if (tl && isRaceCalled(tl.status) && tl.winnerParty){
          const key = String(tl.winnerParty).toUpperCase();  // DEM / REP / IND
          counts.set(key, (counts.get(key) || 0) + 1);
          continue;
        }

        // Fallback (rare): if no topline, fall back to the legacy per-state agg
        const { status, winnerParty } = getStateCall(statefp);
        if (isRaceCalled(status) && winnerParty){
          const key = String(winnerParty).toUpperCase();
          counts.set(key, (counts.get(key) || 0) + 1);
        }
      }

      // Return [{party,label,count}] in descending order
      return Array.from(counts.entries())
        .map(([party, count]) => ({ party, label: partyLabel(party), count }))
        .sort((a,b) => b.count - a.count);
    }




    function clampLeftPanelToTwoCards(){
      const panel = document.querySelector('.left-panel .body');
      if (!panel) return;

      // Prefer the most specific card node you use:
      const cards = panel.querySelectorAll('.cand-item, .cand-card');
      if (cards.length < 3) {
        // fewer than 3 → no clamp
        panel.style.maxHeight = '';
        return;
      }

      // Height from top to just before the 3rd card
      const thirdTop = cards[2].offsetTop;
      // small cushion for the gap under the 2nd card
      const cushion = 8;
      panel.style.maxHeight = `${thirdTop - cushion}px`;
      panel.style.overflow = 'auto';
    }
    function renderNationalPanel(){
      // Force S @ national to General in 2026 so we show the rollup (not candidate cards)

      if (YEAR === '2026' && OFFICE === 'G') {
        // Clear out any left-panel or tally DOM
        const countyInfo = document.getElementById('countyInfo');
        if (countyInfo) countyInfo.innerHTML = '';
        hidePercentInBolt?.();
        return;  // skip the rest of the rollup rendering
      }

      if (YEAR === '2026' && OFFICE === 'H' && (RACE === 'D' || RACE === 'R')) {
        countyInfo.innerHTML = '';
        hidePercentInBolt();
        return;
      }
      if (YEAR === '2026' && NAV_LEVEL === 0 && OFFICE === 'P' && (RACE === 'D' || RACE === 'R')) {
        countyInfo.innerHTML = '';
        return;
      }
      if (YEAR === '2026' && NAV_LEVEL === 0 && OFFICE === 'S' && (RACE === 'D' || RACE === 'R')) {
        countyInfo.innerHTML = '';
        return;
      }
      if (YEAR === '2026' && NAV_LEVEL === 0 && OFFICE === 'G' && (RACE === 'D' || RACE === 'R')) {
        countyInfo.innerHTML = '';
        return;
      }

      const agg = aggregateNationalCandidates();
      const fmt = n => Number(n || 0).toLocaleString('en-US');

      const first  = agg.candidates?.[0] || {};
      const second = agg.candidates?.[1] || null;
      const leadVotes = (first.votes || 0) - (second?.votes || 0);
      const leadPct   = agg.total ? (100 * leadVotes / agg.total) : 0;
      const leadText  = `${leadPct >= 0 ? '' : ''}${leadPct.toFixed(1)}% ${fmt(leadVotes)} AHEAD`;

      // GOVERNOR @ national level (2026): tally rollup
      if (OFFICE === 'G' && NAV_LEVEL === 0){
        const rows = aggregateGovernorCalledWinnersNational();
        const fmt  = n => Number(n || 0).toLocaleString('en-US');
        const html = rows.length
          ? rows.map(r => `
              <div class="party-row party-${String(r.party).toUpperCase()}">
                <div class="party-name">${r.label.toUpperCase()}</div>
                <div class="party-count">${fmt(r.count)}</div>
              </div>`).join("")
          : `<div class="party-row"><div class="party-name">No calls yet</div></div>`;

        // no-flash in-place tally update
        const tally = countyInfo.querySelector('.party-tally');
        if (tally) {
          rows.forEach(r => {
            const row = tally.querySelector(`.party-${String(r.party).toUpperCase()} .party-count`);
            if (row) row.textContent = fmt(r.count);
          });
          if (tally.querySelectorAll('.party-row').length !== rows.length) {
            tally.innerHTML = rows.length
              ? rows.map(r => `
                  <div class="party-row party-${String(r.party).toUpperCase()}">
                    <div class="party-name">${r.label.toUpperCase()}</div>
                    <div class="party-count">${fmt(r.count)}</div>
                  </div>`).join("")
              : `<div class="party-row"><div class="party-name">No calls yet</div></div>`;
          }
        } else {
          countyInfo.innerHTML = `<div class="party-tally">${html}</div>`;
        }
        return;
      }

      // Keep content on transient no-data to avoid flash
      if (!agg.total) {
        const hasContent = countyInfo.querySelector('.cand-list, .party-tally');
        if (!hasContent) countyInfo.innerHTML = `<p>No national data loaded.</p>`;
        return;
      }

      // SENATE @ national level: tally rollup (ALWAYS rollup; no cand-list here)
      if (OFFICE === 'S' && NAV_LEVEL === 0){
        const rows = aggregateSenateCalledWinnersNational();  // [{party,label,count}]
        const fmt  = n => Number(n || 0).toLocaleString('en-US');

        const html = rows.length
          ? rows.map(r => `
              <div class="party-row party-${String(r.party).toUpperCase()}">
                <div class="party-name">${String(r.label || r.party).toUpperCase()}</div>
                <div class="party-count">${fmt(r.count)}</div>
              </div>`).join("")
          : `<div class="party-row">
               <div class="party-name">No calls yet</div>
               <div class="party-count">0</div>
             </div>`;

        // Per-state readout (2026 only)
        let stateListHTML = "";
        if (YEAR === '2026') {
          const statefps = Array.from(VALID_SENATE_STATEFPS).sort((a,b) => {
            const ua = USPS_BY_STATEFP[a], ub = USPS_BY_STATEFP[b];
            return String(ua).localeCompare(String(ub));
          });

          const items = statefps.map(fp => {
             const postal = USPS_BY_STATEFP[fp];
            const { status, winnerName, winnerParty } = getStateCall(fp);
            const called    = isRaceCalled(status);
            const statusTxt = status ? status : 'No Decision';
            const party     = winnerParty ? normalizeParty(winnerParty) : null;
            const winnerTxt = called
              ? (winnerName
                  ? `${winnerName}${party ? `, ${party}` : ''}`
                  : (party ? `${party}` : ''))
              : '';
              return `<div class="kv"><strong>${postal}</strong>, ${statusTxt}${winnerTxt ? `, ${winnerTxt}` : ''}</div>`;
          });


        }

        // Debug (optional)
        let toplineDebugHTML = "";
        if (YEAR === '2026') {
          const statefps = Array.from(VALID_SENATE_STATEFPS).sort((a,b) => {
            const ua = USPS_BY_STATEFP[a], ub = USPS_BY_STATEFP[b];
            return String(ua).localeCompare(String(ub));
          });

          const debugItems = statefps.map(fp => {
            const postal = USPS_BY_STATEFP[fp];
            const tl = getSenate2026Topline(postal);
            const summary = tl
              ? `status=${tl.status || 'null'}, winnerParty=${tl.winnerParty || 'null'}, percentIn=${tl.percentIn ?? 'null'}, epoch=${tl.epoch || 'null'}`
              : 'null';

          });

         
        }

        // No-flash in-place tally update for S @ national
        const tally = countyInfo.querySelector('.party-tally');
        if (tally) {
          rows.forEach(r => {
            const row = tally.querySelector(`.party-${String(r.party).toUpperCase()} .party-count`);
            if (row) row.textContent = fmt(r.count);
          });
          if (tally.querySelectorAll('.party-row').length !== rows.length) {
            tally.innerHTML = html;
          }
          const calls = document.getElementById('senateStateCalls');
          if (calls && stateListHTML) {
            calls.outerHTML = stateListHTML.match(/<div id="senateStateCalls">[\s\S]*<\/div>/)[0];
          }
          const dbg = document.getElementById('toplineDebug');
          if (dbg && toplineDebugHTML) {
            dbg.outerHTML = toplineDebugHTML.match(/<details[\s\S]*<\/details>/)[0];
          }
        } else {
          countyInfo.innerHTML = `<div class="party-tally">${html}</div>${stateListHTML}${toplineDebugHTML}`;
        }
        return;
      }

      // HOUSE @ national level (2026): tally rollup
      if (OFFICE === 'H' && NAV_LEVEL === 0){
        const rows = aggregateHouseCalledWinnersNational();  // [{party,label,count}]
        const fmt  = n => Number(n || 0).toLocaleString('en-US');

        const html = rows.length
          ? rows.map(r => `
              <div class="party-row party-${String(r.party).toUpperCase()}">
                <div class="party-name">${String(r.label || r.party).toUpperCase()}</div>
                <div class="party-count">${fmt(r.count)}</div>
              </div>`).join("")
          : `<div class="party-row">
               <div class="party-name">No calls yet</div>
               <div class="party-count">0</div>
             </div>`;

        // no-flash in-place tally update
        const tally = countyInfo.querySelector('.party-tally');
        if (tally) {
          rows.forEach(r => {
            const row = tally.querySelector(`.party-${String(r.party).toUpperCase()} .party-count`);
            if (row) row.textContent = fmt(r.count);
          });
          if (tally.querySelectorAll('.party-row').length !== rows.length) {
            tally.innerHTML = rows.length
              ? rows.map(r => `
                  <div class="party-row party-${String(r.party).toUpperCase()}">
                    <div class="party-name">${String(r.label || r.party).toUpperCase()}</div>
                    <div class="party-count">${fmt(r.count)}</div>
                  </div>`).join("")
              : `<div class="party-row">
                   <div class="party-name">No calls yet</div>
                   <div class="party-count">0</div>
                 </div>`;
          }
        } else {
          countyInfo.innerHTML = `<div class="party-tally">${html}</div>`;
        }
        return; // skip the candidate-by-votes UI
      }

      // Candidate cards (non-tally path)
      const stack = agg.candidates.map((c, i) => {
        const pct = agg.total ? (100 * (c.votes || 0) / agg.total) : 0;
        const img = (OFFICE === 'S') ? imgForParty(c.party)
          : (OFFICE === 'G') ? imgForParty(c.party)
          : (OFFICE === 'H') ? imgForParty(c.party)
          : (shouldUsePartyIcon(YEAR, OFFICE) ? imgForParty(c.party) : imgForCandidate(c.name));

        const alt = (OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H') ? 'Candidate'
          : (shouldUsePartyIcon(YEAR, OFFICE) ? (c.party || 'Party') : c.name);

        const card = `
          <div class="cand-item">
            <div class="cand-card">
              ${(() => { const {src, alt} = imageMetaFor(c); return `
                <img src="${src}" alt="${alt}" data-party="${c.party || ''}">
              `; })()}
              ${ (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H')
                  ? (() => {
                      const {first,last} = splitName(c.name);
                      const pClass = partyClass(c.party);
                      return `
                        <div class="cand-name ${pClass}">
                          <div class="first">${first}</div>
                          <div class="last">${last}</div>
                        </div>`;
                    })()
                  : ''
              }
              <div class="cand-overlay">
                <div class="pct">
                  <span class="num">${pct.toFixed(2)}</span>
                  <span class="pct-sign">%</span>
                </div>
                <div class="votes">${fmt(c.votes)}</div>
              </div>
            </div>
            ${ leaderLineHTML(i, agg.total, agg.candidates) }
          </div>`;
        return card;
      }).join("");

      const winner = agg.candidates[0];
      const leaderLine = winner
        ? `<div style="margin-bottom:6px;"><strong>Leader:</strong> ${winner.name} (${winner.party}) — ${fmt(winner.votes)}</div>`
        : "";

      // No-flash in-place update for national candidate cards (when using card UI)
      if (YEAR === '2026' && NAV_LEVEL === 0) {
        const list = countyInfo.querySelector('.cand-list');
        if (list && list.children.length) {
          const ensureItem = (idx) => {
            let item = list.children[idx];
            if (!item) {
              const wrap = document.createElement('div');
              wrap.innerHTML = `
                <div class="cand-item">
                  <div class="cand-card">
                    <img src="" alt="" data-party="">
                    <div class="cand-overlay">
                      <div class="pct">
                        <span class="num"></span><span class="pct-sign">%</span>
                      </div>
                      <div class="votes"></div>
                    </div>
                  </div>
                  <div class="leadline"></div>
                </div>`;
              item = wrap.firstElementChild;
              list.appendChild(item);
            }
            return item;
          };

          for (let i = 0; i < agg.candidates.length; i++) {
            const c = agg.candidates[i];
            const pct = agg.total ? (100 * (c.votes || 0) / agg.total) : 0;
            const item = ensureItem(i);
            const card = item.querySelector('.cand-card');

            const meta = imageMetaFor(c);
            const imgEl = card.querySelector('img');
            if (imgEl) {
              const cur = imgEl.getAttribute('src');
              if (cur !== meta.src) imgEl.setAttribute('src', meta.src);
              imgEl.alt = meta.alt;
              imgEl.dataset.party = c.party || '';
            }

            let nameEl = card.querySelector('.cand-name');
            const { first, last } = splitName(c.name || '');
            const pClass = partyClass(c.party);
            if (!nameEl) {
              nameEl = document.createElement('div');
              nameEl.className = `cand-name ${pClass}`;
              nameEl.innerHTML = `<div class="first">${first}</div><div class="last">${last}</div>`;
              card.appendChild(nameEl);
            } else {
              nameEl.className = `cand-name ${pClass}`;
              const fEl = nameEl.querySelector('.first'); if (fEl) fEl.textContent = first;
              const lEl = nameEl.querySelector('.last');  if (lEl) lEl.textContent = last;
            }

            const numEl = card.querySelector('.cand-overlay .pct .num');
            if (numEl) numEl.textContent = pct.toFixed(2);
            const votesEl = card.querySelector('.cand-overlay .votes');
            if (votesEl) votesEl.textContent = Number(c.votes || 0).toLocaleString('en-US');

            const newLeadHTML = leaderLineHTML(i, agg.total, agg.candidates);
            const existingLead = item.querySelector('.leadline');
            if (existingLead) {
              existingLead.outerHTML = newLeadHTML;
            } else {
              item.insertAdjacentHTML('beforeend', newLeadHTML);
            }
          }
          while (list.children.length > agg.candidates.length) {
            list.removeChild(list.lastElementChild);
          }
          return;
        }
      }

      countyInfo.innerHTML = `
        <div class="cand-list">${stack}</div>
      `;
    }


    function aggregateGovernorCalledWinnersNational(){
      const counts = new Map(); // party → states called

      for (const s of (statesFeatures || [])){
        const statefp = String(s.id).padStart(2,"0");
        if (!VALID_SENATE_STATEFPS.has(statefp)) continue; // 50 states only (reuse same set)

        // Prefer the topline cache for G 2026 GEN
        const usps = USPS_BY_STATEFP?.[statefp];
        if (isNoRace2026(usps)) continue;
        const tl   = usps ? getGovernor2026Topline(usps) : null;

        if (tl && isRaceCalled(tl.status) && tl.winnerParty){
          const key = String(tl.winnerParty).toUpperCase();
          counts.set(key, (counts.get(key) || 0) + 1);
          continue;
        }

        // Fallback: legacy per-state call (if topline missing)
        const { status, winnerParty } = getStateCall(statefp);
        if (isRaceCalled(status) && winnerParty){
          const key = String(winnerParty).toUpperCase();
          counts.set(key, (counts.get(key) || 0) + 1);
        }
      }

      return Array.from(counts.entries())
        .map(([party, count]) => ({ party, label: partyLabel(party), count }))
        .sort((a,b) => b.count - a.count);
    }



    function aggregateStateCandidatesHouse(statefp){
      const tally = new Map();
      let total = 0;

      for (const row of Object.values(countyData)) {
        const did = row.district_id || "";
        if (!did.startsWith(statefp)) continue;          // statefp is the 2-digit FIPS prefix
        for (const c of (row.candidates || [])) {
          const k = (c.name || "") + "|" + (c.party || "");
          tally.set(k, (tally.get(k) || 0) + (c.votes || 0));
          total += (c.votes || 0);
        }
      }

      const candidates = [...tally.entries()]
        .map(([k, votes]) => { const [name, party] = k.split("|"); return { name, party, votes }; })
        .sort((a,b)=> b.votes - a.votes);

      return { total, candidates };
    }

    
    function aggregateByStatePrefix(prefix2){
      // countyData is an object keyed by FIPS (string) for P/S/G, and by district_id for H.
      // We only aggregate when keys look like 5-digit FIPS (county-level rows).
      const tally = new Map();
      let total = 0;

      for (const [key, row] of Object.entries(countyData)) {
        if (key.length === 5 && key.startsWith(prefix2)) {
          (row.candidates || []).forEach(c => {
            const k = c.party || c.name || 'IND';
            tally.set(k, (tally.get(k) || 0) + (c.votes || 0));
          });
          total += (row.total || 0);
        }
      }
      const leaders = [...tally.entries()].map(([party, votes]) => ({ party, votes }))
                                          .sort((a,b)=>b.votes-a.votes);
      return { total, leaders };
    }
    
    
    function aggregateStateCandidates(prefix2){
      // Sum by candidate (name+party) across all counties in this state
      const tally = new Map();
      let total = 0;

      for (const [key, row] of Object.entries(countyData)) {
        // only 5-digit county FIPS keys
        if (key.length === 5 && key.startsWith(prefix2)) {
          (row.candidates || []).forEach(c => {
            const k = (c.name || "") + "|" + (c.party || "");
            tally.set(k, (tally.get(k) || 0) + (c.votes || 0));
          });
          total += (row.total || 0);
        }
      }

      const candidates = [...tally.entries()]
        .map(([k, votes]) => {
          const [name, party] = k.split("|");
          return { name, party, votes };
        })
        .sort((a,b)=> b.votes - a.votes);

      return { total, candidates };
    }


    function fillForState(sf){
      const prefix = String(sf.id).padStart(2, "0");

      // Unified statewide logic for P, G, S on NATIONAL view:
      // - SOLID full color if the *state race* is Called
      // - DIMMED leader color if not Called (but votes exist)
      // - GREY if all votes are zero
      if (OFFICE === "P" || OFFICE === "G" || OFFICE === "S") {
        const { status, winnerParty } = getStateCall(prefix);
        const agg = aggregateStateCandidates(prefix);
        const hasVotes = (agg.total || 0) > 0 && (agg.candidates?.length || 0) > 0;

        // ⬇️ Replace your current "if (isRaceCalled(status)) { ... }" block with this:
        if (isRaceCalled(status)) {
                 const topSingleParty = (agg?.candidates?.[0]?.party || "").toUpperCase();
                  const p = (OFFICE === "S" && YEAR === "2026")
                    ? (String(winnerParty || "").toUpperCase() || topSingleParty || "IND")
                    : (String(winnerParty || topSingleParty || "").toUpperCase() || "IND");
        
                  if (p === "REP") return COLOR_GOP;
                  if (p === "DEM") return COLOR_DEM;
                  return COLOR_IND;
                }

        // NOT called:
        if (!hasVotes) return COLOR_NO_DATA; // grey
        const leaderP = (agg.candidates[0].party || "IND").toUpperCase(); // dimmed
        if (leaderP === "REP") return COLOR_GOP_LIGHT;
        if (leaderP === "DEM") return COLOR_DEM_LIGHT;
        return COLOR_IND_LIGHT;
      }

      // Fallback (e.g., H): leader-based color or grey if zero
      const agg = aggregateStateCandidates(prefix);
      if ((agg.total || 0) === 0 || !agg.candidates?.length) return COLOR_NO_DATA;
      const winner = agg.candidates[0];
      const p = (winner.party || "IND").toUpperCase();
      if (p === "REP") return COLOR_GOP;
      if (p === "DEM") return COLOR_DEM;
      return COLOR_IND;
    }





    // 👇 your preferred starting view (use your values)
    const INITIAL_VIEW = d3.zoomIdentity
      .translate(-60, -125)
      .scale(1.2);
    
    
// TopoJSON from CDN (static)
// TopoJSON from CDN (static)
Promise.all([
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json"),
  d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-10m.json")
]).then(async ([stTopo, ctTopo])=>{
  updateActiveBadge();

  const mapShell = document.querySelector(".map-shell");
  projection = d3.geoAlbersUsa();
  path = d3.geoPath().projection(projection);

  // keep these -- we throttle updates to them below
  const feBlur = d3.select("#outerShadow").select("feGaussianBlur");
  const feGrow = d3.select("#outerShadow").select("feMorphology");

  // ⬇️ REPLACE your existing zoom setup with everything from here...
  let rafId = null;
  let rafCity = null;

  // Build zoom that still allows wheel/dblclick/pinch while in pen mode
  zoom = d3.zoom()
    .scaleExtent([1, 24])
    .filter((event) => {
        if (document.body.classList.contains('path-mode')) return false;

      // Allow everything when not drawing
      if (inkMode !== "pen") return true;

      // In pen mode: allow zoom gestures, block drag-to-pan
      const t = event?.type;
      if (t === "wheel") return true;        // wheel/touchpad zoom
      if (t === "dblclick") return true;     // double-click zoom
      if (event && event.touches && event.touches.length > 1) return true; // pinch
      return false;                           // block mousedown drag pan
    })
    .on("zoom", (event) => {
      currentZoomK = event.transform.k;
      rootG.attr("transform", event.transform);

      cityLayer.attr("display", (currentZoomK < CITY_MIN_K || NAV_LEVEL === 0) ? "none" : null);
      
      // keep any effects inverse-scaled (your blur/grow pattern)
      if (rafId == null) {
        const k = event.transform.k;
        rafId = requestAnimationFrame(() => {
          feBlur.attr("stdDeviation", 18 / k);
          feGrow.attr("radius", 4 / k);
          rafId = null;
        });
      }
      if (rafCity == null){
        rafCity = requestAnimationFrame(() => {
          updateCityLabels();
          rafCity = null;
        });
      }
      // keep pen strokes constant width on screen
      d3.select("#inkLayer").selectAll(".pen-stroke")
        .attr("stroke-width", function(){ return this.baseWidth / currentZoomK; });
    })
    .on("start", () => { IS_ZOOMING = true; })
    .on("end",   () => {
      IS_ZOOMING = false;
      if (PAINT_DEFERRED) { PAINT_DEFERRED = false; colorizeInstant(); }
      updateCityLabels();
    });

  d3.select("#map")
    .call(zoom)
    .call(zoom.transform, INITIAL_VIEW);

    let __suppressNextClick = false;
    document.getElementById('map')?.addEventListener('click', (e) => {
      if (inkMode === 'pen' || __suppressNextClick) {
        e.preventDefault();
        e.stopPropagation();
        __suppressNextClick = false;  // consume one click
      }
    }, true); // capture phase

    
    // tap-vs-drag threshold for pen
    const MIN_DRAG_PX = 4;
    let startX = 0, startY = 0, didDrag = false;

    
    
      // Start / move / end drawing only when inkMode === "pen"
      svg.on("pointerdown.ink", (e) => {
        if (inkMode !== "pen") return;
        startInk(e);
      });

      // pointerdown → startInk (REPLACE your current startInk)
      function startInk(e){
        if (inkMode !== 'pen') return;
        e.preventDefault(); e.stopPropagation();

        drawing = true;
        didDrag = false;

        const [sx, sy] = d3.pointer(e, svg.node());
        startX = sx; startY = sy;

        const t = d3.zoomTransform(svg.node());
        const [x, y] = t.invert([sx, sy]);

        currentPoints = [[x, y]];
        currentStroke = inkLayer.append("path")
          .attr("class", "pen-stroke")
          .attr("fill", "none")
          .attr("stroke", "#ff2d55")
          .attr("stroke-linecap", "round")
          .attr("stroke-linejoin", "round")
          .datum(currentPoints);

        // baseWidth stays constant; rendered width = baseWidth / currentZoomK
        currentStroke.node().baseWidth = 3.5;
        currentStroke
          .attr("stroke-width", 3.5 / currentZoomK)
          .attr("d", lineGen(currentPoints));

        strokes.push(currentStroke);
        svg.on("pointermove.ink", inkMove);
        svg.on("pointerup.ink pointerleave.ink", endInk);
      }

      // pointermove → inkMove (ADD/REPLACE to include threshold)
      function inkMove(e){
        if (!drawing || inkMode !== 'pen') return;
        const [sx, sy] = d3.pointer(e, svg.node());
        const dx = sx - startX, dy = sy - startY;
        if (!didDrag && (dx*dx + dy*dy) >= (MIN_DRAG_PX*MIN_DRAG_PX)) {
          didDrag = true;
        }

        const t = d3.zoomTransform(svg.node());
        const [x, y] = t.invert([sx, sy]);

        currentPoints.push([x, y]);
        currentStroke.attr("d", lineGen(currentPoints));

        e.preventDefault(); e.stopPropagation();
      }

      // pointerup → endInk (REPLACE to swallow “tap” clicks)
      function endInk(e){
        if (inkMode !== 'pen') return;

        if (!didDrag) {
          // It was a tap: optionally remove the dot…
          try { currentStroke?.remove(); } catch {}
          // …and swallow the very next click so the map/state doesn’t fire.
          __suppressNextClick = true;
          setTimeout(() => { __suppressNextClick = false; }, 0);
        }

        drawing = false;
        currentStroke = null;
        currentPoints = [];
        svg.on("pointermove.ink", null);
        svg.on("pointerup.ink pointerleave.ink", null);

        e.preventDefault(); e.stopPropagation();
      }

      
  zoomToFeature = function(feature, cap = 8){
    const b = path.bounds(feature),
          dx = b[1][0] - b[0][0],
          dy = b[1][1] - b[0][1],
          x  = (b[0][0] + b[1][0]) / 2,
          y  = (b[0][1] + b[1][1]) / 2,
          scale = Math.min(cap, 0.9 / Math.max(dx / (+svg.attr("width")||1),
                                               dy / (+svg.attr("height")||1))),
          translate = [(+svg.attr("width")/2) - scale * x,
                       (+svg.attr("height")/2) - scale * y];

    const target = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);

    // cancel any existing zoom transition so county→county feels snappy
    svg.interrupt();
    svg.transition("zoom")
       .duration(600)                 // make it more gradual
       .ease(d3.easeCubicInOut)       // smoother ease
       .call(zoom.transform, target)
       .on("end", () => {
         if (PAINT_DEFERRED) { PAINT_DEFERRED = false; colorizeInstant(); }
         updateCityLabels();
       });
};




  function resizeMap(){
    const w = mapShell.clientWidth, h = mapShell.clientHeight;
    svg.attr("width", w).attr("height", h);
    svg.select("rect.map-underlay").attr("width", w).attr("height", h);
    projection.translate([w/2, h/2]).scale(Math.min(w,h)*1.25);
    svg.selectAll("path").attr("d", path);
  }
  
  function resizeMap(){
    const w = mapShell.clientWidth, h = mapShell.clientHeight;
    svg.attr("width", w).attr("height", h);
    svg.select("rect.map-underlay").attr("width", w).attr("height", h);
    projection.translate([w/2, h/2]).scale(Math.min(w,h)*1.25);
    svg.selectAll("path").attr("d", path);
    updateCityLabels();  // <— add
  }

  window.addEventListener("resize", ()=>{ resizeMap(); if (countiesSel) colorizeInstant(); });
  resizeMap();

  countyShapes = topojson.feature(ctTopo, ctTopo.objects.counties).features;
  
  statesFeatures = topojson.feature(stTopo, stTopo.objects.states).features;

  // --- Topology-based neighbors for states (exact shared borders) ---
  const stateGeoms    = stTopo.objects.states.geometries;
  const neighborLists = topojson.neighbors(stateGeoms); // arrays of geometry-index neighbors
  const idByIdx = stateGeoms.map(g => g.id);
  const idxById = new Map(idByIdx.map((id,i)=>[id,i]));

  function adjacentStateIdsOf(id, hops = 1){
    const seen = new Set([id]);
    let frontier = [id];
    for (let h = 0; h < hops; h++){
      const next = [];
      for (const cur of frontier){
        const idx = idxById.get(cur);
        if (idx == null) continue;
        for (const j of neighborLists[idx]){
          const nid = idByIdx[j];
          if (!seen.has(nid)){ seen.add(nid); next.push(nid); }
        }
      }
      frontier = next;
    }
    seen.delete(id);
    return Array.from(seen);
  }

  
  function drawNeighborDistrictsOverlay(selectedFeature){
    if (OFFICE !== "H" || !selectedFeature) {
      neighborDistrictLayer.selectAll("path").remove();
      return;
    }

    // show every other state's districts (nationwide), not just neighbors
    const selectedStatefp = String(selectedFeature.id).padStart(2,"0");
    const otherDistricts = (districtShapes || []).filter(
      d => String(d.properties.STATEFP).padStart(2,"0") !== selectedStatefp
    );

    function lightFillForNeighbor(d){
      const did = `${d.properties.STATEFP}${String(
        d.properties.CD119FP ||
        d.properties.CD118FP ||
        d.properties.CD116FP ||
        d.properties.CD115FP ||
        d.id
      ).padStart(2,"0")}`;
      const r = Object.values(countyData).find(x => x.district_id === did);
      if (isNoData(r)) return COLOR_NO_DATA;
      if ((r.total || 0) === 0) return COLOR_NO_DATA;  // Fallback grey (redundant but belt-and-suspenders)
      if (!r || !r.candidates?.length) return COLOR_BG;  // Neutral white for missing rows
      const lead = r.candidates.slice().sort((a,b)=>b.votes-a.votes)[0].party;
      return lead === "REP" ? COLOR_GOP_LIGHT :
             lead === "DEM" ? COLOR_DEM_LIGHT : COLOR_IND_LIGHT;
    }

    neighborDistrictLayer
      .selectAll("path.neighbor-cd")
      .data(otherDistricts, d => `${d.properties.STATEFP}-${d.properties.CD119FP||d.properties.CD118FP||d.properties.CD116FP||d.properties.CD115FP||d.id}`)
      .join(
        enter => enter.append("path")
          .attr("class","neighbor-cd")
          .attr("d", path)
          .attr("fill", d => fillForDistrictFeature(d))
          .attr("fill-opacity", 1)
          .attr("stroke", "#fff")
          .attr("stroke-width", 0.5)
          .attr("vector-effect","non-scaling-stroke")
          .style("cursor","pointer")
          .on("click", function(event, d){
            const pref = String(d.properties.STATEFP).padStart(2,"0");
            const sd = statesFeatures?.find(s => String(s.id).padStart(2,"0") === pref);
            if (sd) clickedState(event, sd);
            event.stopPropagation();
          }),
            update => update
              .attr("d", path)
              .attr("fill", d => fillForDistrictFeature(d))
              .attr("opacity", 1),
        exit => exit.remove()
      );
  }

  window.drawNeighborDistrictsOverlay = drawNeighborDistrictsOverlay;

  


  // Return 1-hop (or N-hop) adjacent state ids
  function adjacentStateIdsOf(id, hops = 1){
    const seen = new Set([id]);
    let frontier = [id];
    for (let h = 0; h < hops; h++){
      const next = [];
      for (const cur of frontier){
        const idx = idxById.get(cur);
        if (idx == null) continue;
        for (const j of neighborLists[idx]){
          const nid = idByIdx[j];
          if (!seen.has(nid)){
            seen.add(nid);
            next.push(nid);
          }
        }
      }
      frontier = next;
    }
    seen.delete(id);
    return Array.from(seen);
  }

  
  // initial district layer for the current YEAR
  (async () => {
     try { await loadDistrictMapForYear(YEAR); } catch (e) { console.warn(e); }
   })();

  
  
  function aggregateStateByPrefix(prefix2){
    const agg = {}; let total = 0;
    for (const [key, row] of Object.entries(countyData)) {
      const f = String(key).padStart(5,"0");
      if (f.length === 5 && f.startsWith(prefix2)) {
        (row.candidates || []).forEach(c=>{
          const k = c.name || "Unknown";
          if(!agg[k]) agg[k] = { votes:0, party:c.party };
          agg[k].votes += (c.votes || 0);
        });
        total += (row.total || 0);
      }
    }
    return {candidates: agg, total};
  }
  function drawNeighborStatesOverlay(selectedFeature){
    // Only show the overlay in P/S/G races
    if (!["P","S","G"].includes(OFFICE)) {
      neighborStateLayer.selectAll("path").remove();
      return;
    }
    window.drawNeighborStatesOverlay = drawNeighborStatesOverlay;  // make it visible outside the Promise callback

    const selId = selectedFeature.id;
    const isSen2026 = (OFFICE === "S" && String(YEAR) === "2026");
    const isGov2026 = (OFFICE === "G" && String(YEAR) === "2026");

    neighborStateLayer
      .selectAll("path.neighbor-state")
      .data(statesFeatures, d => d.id)
      .join("path")
        .attr("class", "neighbor-state")
        .attr("d", path)
        .attr("fill", d => {
          if (d.id === selId) return "none";

          const usps =
            d.usps || d.properties?.usps || d.properties?.STUSPS ||
            USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];

          // Grey neighbors with no election (S-2026 or G-2026)
          if ((isSen2026 && isNoSenate2026(usps)) ||
              (isGov2026 && isNoGovernor2026(usps))) {
            return NO_RACE_GREY;
          }

          // otherwise fall back to your existing “winner tint” logic
          const pref = String(d.id).padStart(2, "0");
          const agg  = aggregateStateCandidates(pref);
          if (!agg.total || !agg.candidates.length) return COLOR_NO_DATA;

          const winner = agg.candidates[0];
          const p = (winner.party || "IND").toUpperCase();
          if (p === "REP") return COLOR_GOP_LIGHT;
          if (p === "DEM") return COLOR_DEM_LIGHT;
          return COLOR_IND_LIGHT;
        })
        .attr("stroke", "none")
        // make S/G-2026 no-race neighbors (and the selected state) inert
        .style("pointer-events", d => {
          if (d.id === selId) return "none";
          const usps =
            d.usps || d.properties?.usps || d.properties?.STUSPS ||
            USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
          const block = (isSen2026 && isNoSenate2026(usps)) ||
                        (isGov2026 && isNoGovernor2026(usps));
          return block ? "none" : "auto";
        })
        .style("cursor", d => {
          if (d.id === selId) return "default";
          const usps =
            d.usps || d.properties?.usps || d.properties?.STUSPS ||
            USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
          const block = (isSen2026 && isNoSenate2026(usps)) ||
                        (isGov2026 && isNoGovernor2026(usps));
          return block ? "default" : "pointer";
        })
        .on("click", function (event, d) {
          if (d.id === selId) return;

          const usps =
            d.usps || d.properties?.usps || d.properties?.STUSPS ||
            USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
          // block drill for S/G-2026 no-election neighbors
          if ((isSen2026 && isNoSenate2026(usps)) ||
              (isGov2026 && isNoGovernor2026(usps))) return;

          // behave like clicking a state: drill into that state's counties
          clickedState(event, d);
          event.stopPropagation();
        });
  }

  // Guarantees the map is rendered after leaving BOP.
  // Safe to call any time; it only redraws when needed (or when force=true).
  async function ensureMapRendered({ force = false } = {}) {
    // If we’re still in BOP, do nothing; caller should try again later.
    if (document.body.classList.contains('bop-mode')) return;

    const svgEl = document.getElementById('map');
    if (!svgEl) return;

    // If House is active, make sure the right district geometry is present.
    if (OFFICE === 'H') {
      if (!Array.isArray(districtShapes) || districtShapes.length === 0) {
        await (typeof loadDistrictMapForYear === 'function' ? loadDistrictMapForYear(YEAR) : Promise.resolve());
      }
    }

    // Decide if the scene looks “empty” (no map paths at all).
    const hasAnyPath = svgEl.querySelector('path') != null;

    if (force || !hasAnyPath) {
      // Full rebuild + instant paint.
      drawShapes?.();
      colorizeInstant?.(true);
    }

    // Restore the panel in national view.
    if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
      renderNationalPanel?.();
    }

    // If you show %IN bolts, keep them quiet at national.
    hidePercentInBolt?.();
  }
  window.ensureMapRendered = ensureMapRendered;
  
  
  function drawShapes(){
    // clear layers
    nationalStateLayer.selectAll("*").remove();
    countyLayer.selectAll("*").remove();
    neighborStateLayer.selectAll("*").remove();
    neighborDistrictLayer.selectAll("*").remove();
    stateShadowLayer.selectAll("*").remove();
    activeStateOutline.selectAll("*").remove();
    stateLayer.selectAll("*").remove(); // also clear hitboxes

    // --- national STATES view for H (House) ---
    if (OFFICE === "H") {
      CURRENT_GEOM = 'states';
      districtsSel = null;

      stateLayer.style("pointer-events","auto");

      // Paint neutral (or keep your state color logic once you add H aggregation)
      // new code (use this)
      statesSel = nationalStateLayer
        .selectAll("path")
        .data(statesFeatures, d=>d.id)
        .join("path")
          .attr("d", path)
          .attr("fill", d => {
            const usps = d.usps || d.properties?.usps || d.properties?.STUSPS || USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
            if (isNoSenate2026(usps)) return NO_RACE_GREY;
            return fillForState(d);
          })
          .attr("stroke", "none");


      // Clickable hitboxes for drill-in
      // Clickable hitboxes for drill-in (gated for S 2026 no-election states)
      stateLayer.selectAll("path.state-hit")
        .data(statesFeatures, d=>d.id)
        .join("path")
          .attr("class","state-hit")
          .attr("d", path)
          .attr("fill", "#fff")
          .attr("fill-opacity", 0)
          .attr("stroke", "#fff")                 // was "#fff"
          .attr("stroke-width", 0.5)               // was 0.5
          .attr("vector-effect", "non-scaling-stroke")
          .style("pointer-events", sd => isStateClickable(sd) ? "auto" : "none")
          .style("cursor",        sd => isStateClickable(sd) ? "pointer" : "default")
          // REMOVE these two lines entirely to prevent focus ring:
          // .attr("tabindex",       sd => isStateClickable(sd) ? 0 : -1)
          // .attr("aria-disabled",  sd => isStateClickable(sd) ? "false" : "true")
          .on("click", (ev, sd) => {
            if (!isStateClickable(sd)) return;
            clickedState(ev, sd);
          });



          districtsSel = countyLayer
              .selectAll("path.district")
              .data(districtShapes || [], d => {
                const n = String(
                  d.properties.CD119FP ||
                  d.properties.CD118FP ||
                  d.properties.CD116FP ||
                  d.properties.CD115FP ||
                  d.id
                ).padStart(2,"0");
                return `${d.properties.STATEFP}${n}`;
              })
              .join("path")
                .attr("class","district")
                .attr("d", path)
                .attr("fill", d => fillForFeature(d))
                .attr("stroke", "#fff")
                .attr("stroke-width", 0.35)
                .attr("vector-effect", "non-scaling-stroke")
                .style("pointer-events","none");  // let states capture clicks for drill-in
                stateLayer.raise();
                bringInkToFront();
                bringCitiesToFront();

            // keep view centered
            svg.call(zoom.transform, INITIAL_VIEW);
            return;
          }

    // --- default national STATES view for P/S/G ---
    CURRENT_GEOM = 'states';
    districtsSel = null;

    stateLayer.style("pointer-events","auto");   // re-enable state clicks after returning from H
    
    statesSel = nationalStateLayer
      .selectAll("path")
      .data(statesFeatures, d=>d.id)
      .join("path")
        .attr("d", path)
        .attr("fill", d => {
          const usps = d.usps || d.properties?.usps || d.properties?.STUSPS || USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
          if (isNoSenate2026(usps)) return NO_RACE_GREY;   // force grey for S 2026 no-race states
          if (OFFICE === 'S' && YEAR === '2026' && isNoSenate2026(usps)) return NO_RACE_GREY;
           if (OFFICE === 'G' && YEAR === '2026' && isNoGovernor2026(usps)) return NO_RACE_GREY;

          return fillForState(d);                           // existing logic
        })
        .attr("stroke", "none");
        
        
        stateLayer?.selectAll("path.state-hit") .style("pointer-events", sd => isStateClickable(sd) ? "auto" : "none") .style("cursor", sd => isStateClickable(sd) ? "pointer" : "default") .attr("tabindex", sd => isStateClickable(sd) ? 0 : -1);
        
        stateLayer.selectAll("path.state-hit")
          .data(statesFeatures, d=>d.id)
          .join("path")
            .attr("class","state-hit")
            .attr("d", path)
            .attr("fill", "#fff")
            .attr("fill-opacity", 0)
            .attr("stroke", "#fff")                 // was "#fff"
            .attr("stroke-width", 0.5)               // was 0.5
            .attr("vector-effect", "non-scaling-stroke")
            .style("pointer-events", sd => isStateClickable(sd) ? "auto" : "none")
            .style("cursor",        sd => isStateClickable(sd) ? "pointer" : "default")
            // REMOVE these two lines entirely to prevent focus ring:
            // .attr("tabindex",       sd => isStateClickable(sd) ? 0 : -1)
            // .attr("aria-disabled",  sd => isStateClickable(sd) ? "false" : "true")
            .on("click", (ev, sd) => {
              if (!isStateClickable(sd)) return;
              clickedState(ev, sd);
            });


  }

  (function guardAgainstRepaints(){
    if (window._patchedDrawShapes) return;           // idempotent
    if (typeof window.drawShapes === "function") {
      const orig = window.drawShapes;
      window.drawShapes = function(...args){
        if (document.body.classList.contains('path-mode')) return;  // block any repaint
        return orig.apply(this, args);
      };
      window._patchedDrawShapes = true;
    }
  })();

  
  // add this
  focusStateByPrefix = function(prefix, sdOpt){
    const sd = sdOpt || statesFeatures.find(s => String(s.id).padStart(2,"0") === prefix);
    if (!sd) return;

    CURRENT_GEOM = 'counties';

    stateLayer.style("pointer-events","none");
    countyLayer.raise();
    bringInkToFront();
    bringCitiesToFront();

    // remove national fills
    nationalStateLayer.selectAll("path").remove();

   // 🔧 Belt & suspenders: clear any lingering counties from prior state
   countyLayer.selectAll("path.county").remove();

    const stateCounties = (countyShapes || []).filter(c =>
      String(c.id).padStart(5,"0").startsWith(prefix)
    );

    const sel = countyLayer

      .selectAll("path.county")
       .data(stateCounties, d => d.id);

    sel.exit().remove();

    const enter = sel.enter().append("path")
      .attr("class","county")               // ✅ Correct for P/S/G
      .attr("id", d => `c${String(d.id).padStart(5,"0")}`)
       .attr("stroke","#fff")
       .attr("stroke-width", .35)
       .attr("vector-effect","non-scaling-stroke")
       .style("cursor","pointer");

    const paths = enter.merge(sel);

    paths
      .on("click", onCountyClick)
      .attr("d", path)
      .attr("fill", d => fillForFeature(d))
      .classed("no-race", d => {
        const f = String(d.id).padStart(5,"0");
        const usps = (countyData[f]?.state) || USPS_BY_STATEFP?.[f.slice(0,2)];
        return (OFFICE === "S" && YEAR === "2026" && isNoSenate2026(usps));
      })
      .style("pointer-events","auto");

       
       countiesSel = countyLayer.selectAll("path.county");

    // Keep your overlay logic as-is, but make sure it redraws:
    if (["P","S","G"].includes(OFFICE)) {
      drawNeighborStatesOverlay(sd);
    } else {
      neighborStateLayer.selectAll("path").remove();
    }

    stateShadowLayer.selectAll("path")
      .data([sd]).join("path")
        .attr("d", path)
        .attr("fill", "#fff")
        .attr("filter", "url(#outerShadow)");

    activeStateOutline.selectAll("path")
      .data([sd]).join("path")
        .attr("d", path)
        .attr("fill","none")
        .attr("stroke","#fff")
        .attr("stroke-width",1.5)
        .attr("vector-effect","non-scaling-stroke");
  }

  focusHouseStateByPrefix = function(prefix, sdOpt){
      countyLayer.selectAll("path.district").interrupt().remove();
        neighborDistrictLayer.selectAll("path.neighbor-cd, path.cd-backdrop").interrupt().remove();
        const sd = sdOpt || statesFeatures.find(s => String(s.id).padStart(2,"0") === prefix);
    if (!sd) return;

    CURRENT_GEOM = 'districts';
    stateLayer.style("pointer-events","none");
    countyLayer.raise();
    bringInkToFront();
    bringCitiesToFront();

    // remove national fills
    nationalStateLayer.selectAll("path").remove();

    // Only districts for this state
    const stateDistricts = (districtShapes || []).filter(
       d => String(d.properties.STATEFP).padStart(2, "0") === String(prefix)
     );

    const sel = countyLayer
      .selectAll("path.district")
      .data(stateDistricts, d => {
        const n = String(
          d.properties.CD119FP ||
          d.properties.CD118FP ||
          d.properties.CD116FP ||
          d.properties.CD115FP ||
          d.id
        ).padStart(2,"0");
        return `${d.properties.STATEFP}${n}`;
      });

    sel.exit().remove();

    const entered = sel.enter().append("path")
        .attr("class","district")
        .attr("stroke","#fff")
        .attr("stroke-width", .35)
        .attr("vector-effect","non-scaling-stroke")
        .style("cursor","pointer")
        .attr("fill", d => fillForDistrictFeature(d, { insideSelected:true }));
        
    const paths = sel.merge(entered);
    paths
      .on("click", showDistrict)
      .attr("d", path)
      .attr("fill", d => fillForDistrictFeature(d, { insideSelected:true }))
      .style("pointer-events","auto");   // ✅ re-enable clicks once zoomed into a state

    districtsSel = countyLayer.selectAll("path.district");

    // optional: clear neighbor overlay in H for now
    neighborStateLayer.selectAll("path").remove();        // keep P/S/G overlay off in H
     drawNeighborDistrictsOverlay(sd);
     colorizeInstant(true);
     countyLayer.raise();
     districtsSel.raise();
     bringInkToFront();
     bringCitiesToFront();

    // shadow + active outline (mirrors your county focus helper)
    stateShadowLayer.selectAll("path")
      .data([sd]).join("path")
        .attr("d", path)
        .attr("fill", "#fff")
        .attr("filter", "url(#outerShadow)");

    activeStateOutline.selectAll("path")
      .data([sd]).join("path")
        .attr("d", path)
        .attr("fill","none")
        .attr("stroke","#fff")
        .attr("stroke-width",1.5)
        .attr("vector-effect","non-scaling-stroke");
  }

  
  
  function clickedState(event, sd){
    const prefix = String(sd.id).padStart(2,"0");
    const usps   = sd.usps || sd.properties?.STUSPS || USPS_BY_STATEFP?.[prefix];
    
    if (OFFICE === 'S' && String(YEAR) === '2026' && isNoSenate2026(usps)) {
       return;
     }

    // ← add this line: remember if the *current* drill-in is S/2026 and has no race
    window.NO_RACE_VIEW = (OFFICE === 'S' && String(YEAR) === '2026' && isNoSenate2026(usps));

    // proceed with normal drill-in
    NAV_LEVEL = 1;
    selectedFips = null;
    selectedDistrict = null;
    selectedStateFP = prefix;

    if (OFFICE === "H") {
      focusHouseStateByPrefix(prefix, sd);
    } else {
      focusStateByPrefix(prefix, sd);
    }

    zoomToFeature(sd, 8);
    renderStatePanel(prefix);
    updateHeaderTitle();
    syncPercentBolt();
  }

  

  window.drawShapes = drawShapes; // <-- add this line


  // When Office or Race buttons are clicked, you already call drawShapes();
  // ensure we also reload the district map if switching years or to House.
  // ... starts around line 985
  /* =========================
     BEGIN REPLACEMENT: Office/Race handler
     (Put this exactly where your existing handler block is.)
     ========================= */
  document
    .querySelectorAll('#allButtons button[data-office], #allButtons button[data-race]')
    .forEach(btn => {
      btn.onclick = async () => {
          const prevOffice = OFFICE;   // ← take a snapshot BEFORE we change OFFICE
          const prevRace   = RACE;     // ← optional but symmetrical



        // Update OFFICE / RACE and active button classes
        if (btn.dataset.office) {
          OFFICE = btn.dataset.office;
          document.querySelectorAll('#allButtons button[data-office]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        }
        if (btn.dataset.race) {
          RACE = btn.dataset.race;

          // Toggle the active class immediately so the button "lights" even if we return early
          document.querySelectorAll('#allButtons button[data-race]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Optional: ensure nothing auto-flips primaries → GEN at national
          window.__forceSenate2026GenAtNational = false;

          // --- Fast refresh when switching D/R on Senate 2026 at national ---
          if (YEAR === '2026' && OFFICE === 'S' && NAV_LEVEL === 0) {
            // clear any local memo caches if you use them (safe if they don't exist)
            delete window.__senateCalledCache;
            delete window.__senateLeadersCache;

            // refresh the panel now; cache fetch is cheap and keeps things consistent
            await getDataFromCache();
            renderNationalPanel();
            syncPercentBolt?.();   // if you use the %in bolt
            return;                // prevent old flow from skipping this update
          }
        }


        // Availability + title
        updateYearAvailability();
        updateOfficeAvailability();
        updateRaceAvailability();
        updateHeaderTitle();
        syncPercentBolt();
        if (
                  ['P','S','G'].includes(OFFICE) &&
                  ['P','S','G'].includes(prevOffice) &&
                  OFFICE !== prevOffice &&
                  NAV_LEVEL >= 1                      // ⟵ was === 2; now includes state AND county
                ) {
                  // clear drill context
                  NAV_LEVEL = 0;
                  selectedStateFP  = null;
                  selectedFips     = null;
                  selectedDistrict = null;
                  hidePercentInBolt?.();

                  // snap back to national and rebuild
                  d3.select("#map").call(zoom.transform, INITIAL_VIEW);
                  drawShapes();
                  colorizeInstant(true);
                  await getDataFromCache?.();
                  updateActiveBadge?.();
                  renderNationalPanel?.();
                  updateHeaderTitle();
                  syncPercentBolt?.();
                  return; // stop here so we don't fall into stay-zoomed logic
                }

        /* --- ENTERING HOUSE: make sure CD geometry is loaded and reset nav --- */
        if (OFFICE === 'H') {
          await loadDistrictMapForYear(YEAR);   // ensure correct Congress map is in memory
          NAV_LEVEL = 0;
          hidePercentInBolt?.();
          selectedStateFP = null;
          selectedFips = null;
          selectedDistrict = null;

          // Rebuild national House view
          countyData = {};
          d3.select("#map").call(zoom.transform, INITIAL_VIEW);
          drawShapes();
          colorizeInstant(true);
          await getDataFromCache?.();
          updateActiveBadge?.();
          if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
            renderNationalPanel?.();
          }
          updateHeaderTitle();
          return;   // ← done (don’t fall through)
        }

        /* --- LEAVING HOUSE → P/S/G: zoom out and rebuild national --- */
        if (prevOffice === 'H' && ['P','S','G'].includes(OFFICE)) {
          NAV_LEVEL = 0;
          selectedStateFP = null;
          selectedFips = null;
          selectedDistrict = null;
          hidePercentInBolt();

          d3.select("#map").transition().duration(0)
            .call(zoom.transform, INITIAL_VIEW);

          drawShapes();              // national states view
          colorizeInstant(true);     // paint immediately
          await getDataFromCache?.();
          updateActiveBadge?.();
          if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
            renderNationalPanel?.();
          }
          updateHeaderTitle();
          syncPercentBolt();
          return;   // ← done
        }

        /* --- STAY-ZOOMED branch for P/S/G (keep current state/county zoom) --- */
        if (['P','S','G'].includes(OFFICE) && selectedStateFP && NAV_LEVEL >= 1) {
          const prevFips = selectedFips;    // remember county if at level 2
          countyData = {};                  // clear old office/race data
          await getDataFromCache?.();       // load new data

          const sd = statesFeatures.find(s => String(s.id).padStart(2,'0') === selectedStateFP);
          if (sd) {
            // Rebuild this state's counties without changing the zoom/transform
            focusStateByPrefix(selectedStateFP, sd);

            // If we were on a specific county, re-highlight & refresh panel
            if (NAV_LEVEL === 2 && prevFips) {
              selectedFips = prevFips;
              countyLayer.selectAll("path.county").classed("highlight", false);
              countyLayer.select(`#c${selectedFips}`).classed("highlight", true);
              renderCountyPanel(selectedFips);
              showPercentInBoltForCounty(selectedFips);
            } else {
              renderStatePanel(selectedStateFP);
            }
            colorizeInstant(true);
          }
          updateActiveBadge?.();
          return;   // ← done
        }

        /* --- Default: not zoomed into a state --- */
        d3.select("#map").call(zoom.transform, INITIAL_VIEW);
        drawShapes();
        colorizeInstant(true);
        await getDataFromCache?.();
        updateActiveBadge?.();
        if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
          renderNationalPanel?.();
        }
        updateHeaderTitle();
      };
    });
  /* =========================
     END REPLACEMENT
     ========================= */

  
  const penBtn = document.getElementById("penBtn");
  penBtn.addEventListener("click", () => {
    inkMode = (inkMode === "pen") ? "pan" : "pen";
    penBtn.classList.toggle("active", inkMode === "pen");
    svg.style("cursor", inkMode === "pen" ? "crosshair" : "grab");
  });

  
  
  // ...
  // Year button handler: switch years and refresh national rollup (incl. G/S 2026 toplines)
  document.querySelectorAll('#yearButtons button').forEach(btn => {
    btn.onclick = async () => {
      if (btn.disabled) return;

      // Active state
      document.querySelectorAll('#yearButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      const prevYear = YEAR;
      YEAR = btn.dataset.year;

      // Keep availability in sync
      updateYearAvailability();
      updateOfficeAvailability();
      updateRaceAvailability();
      ensureBopConsistency?.();
      updateHeaderTitle();

      // House needs correct district geometry
      if (OFFICE === "H") {
        await loadDistrictMapForYear(YEAR);
      }

      // Reset to national on year switch
      NAV_LEVEL = 0;
      selectedStateFP = null;
      selectedFips = null;
      selectedDistrict = null;
      hidePercentInBolt();

      // Rebuild, recolor, and load data
      drawShapes();
      colorizeInstant(true);
      await getDataFromCache();
      updateActiveBadge();

      // National rollup refresh (+ 2026 caches)
      if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
        renderNationalPanel();
      }

      // Optional: keep/stop polling based on year
      if (YEAR === "2026") startLivePolling?.(); else stopLivePolling?.();
    };
  });


  
  
  drawShapes();
  setTimeout(() => { warmHistoricPreload(); }, 0);
  getDataFromCache().finally(() => {
    if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
      renderNationalPanel();
    }
  });
  if (YEAR === "2026") startLivePolling();

  // Force menu mode on startup (we're already inside DOMContentLoaded)
  clearToMenu();

  });

    function showDistrict(event, d){
      // highlight the clicked district
      svg.selectAll("path.district").classed("highlight", false);
      d3.select(this).classed("highlight", true);

      // compute the stable district id
      const did = `${d.properties.STATEFP}${String(
        d.properties.CD119FP ||
        d.properties.CD118FP ||
        d.properties.CD116FP ||
        d.properties.CD115FP ||
        d.id
      ).padStart(2,"0")}`;

      selectedDistrict = did;
      NAV_LEVEL = 2;
      updateHeaderTitle();
      renderDistrictPanel(did);
      showPercentInBoltForDistrict(did);
      // NEW: zoom smoothly to the clicked district
      zoomToFeature(d, 12);
      colorizeInstant(true);
      syncPercentBolt();
      // prevent stray handlers from seeing this click
      event.stopPropagation();
    }


    function renderDistrictPanel(did){
      const r = Object.values(countyData).find(x => x.district_id === did);
      if (!r) {
        countyInfo.innerHTML = `<p>No cached data for district ${did}</p>`;
        return;
      }

      // Optional: show call status (kept but not inserted below; add to DOM if you want)
      const { status, winnerName, winnerParty } = getDistrictCall(did);

      const sorted = (r.candidates || []).slice().sort((a,b)=>(b.votes||0)-(a.votes||0));

      const stack = sorted.map((c, i) => {
        const pct = r.total ? (100 * (c.votes || 0) / r.total) : 0;

        // House uses party icon; mirrors your other builders
        const img = (OFFICE === 'H') ? imgForParty(c.party)
          : (shouldUsePartyIcon(YEAR, OFFICE) ? imgForParty(c.party) : imgForCandidate(c.name));

        const alt = (OFFICE === 'H') ? 'Candidate'
          : (shouldUsePartyIcon(YEAR, OFFICE) ? (c.party || 'Party') : c.name);

        const nameOverlay =
          (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H')
            ? (() => {
                const { first, last } = splitName(c.name);
                const pClass = partyClass(c.party);
                return `
                  <div class="cand-name ${pClass}">
                    <div class="first">${first}</div>
                    <div class="last">${last}</div>
                  </div>`;
              })()
            : '';

        return `
          <div class="cand-item">
            <div class="cand-card">
              <img src="${img}" alt="${alt}" data-party="${c.party || ''}">
              ${nameOverlay}
              <div class="cand-overlay">
                <div class="pct">
                  <span class="num">${pct.toFixed(2)}</span>
                  <span class="pct-sign">%</span>
                </div>
                <div class="votes">${fmt(c.votes)}</div>
              </div>
            </div>
            ${ leaderLineHTML(i, r.total, sorted) }
          </div>`;
      }).join("");

      
      // === 2026 House district-level: update existing DOM in place (no flash) ===
      if (YEAR === '2026' && OFFICE === 'H') {
          const list = countyInfo.querySelector('.cand-list');
        if (list && list.children.length) {

          const ensureItem = (idx) => {
            let item = list.children[idx];
            if (!item) {
              const wrap = document.createElement('div');
              wrap.innerHTML = `
                <div class="cand-item">
                  <div class="cand-card">
                    <img src="" alt="" data-party="">
                    <div class="cand-overlay">
                      <div class="pct">
                        <span class="num"></span><span class="pct-sign">%</span>
                      </div>
                      <div class="votes"></div>
                    </div>
                  </div>
                  <div class="leadline"></div>
                </div>`;
              item = wrap.firstElementChild;
              list.appendChild(item);
            }
            return item;
          };

          // Use the same variables you already compute in this function:
          // - 'sorted' (array of candidates in order)
          // - 'r' (rollup with r.total for vote sum)
          for (let i = 0; i < sorted.length; i++) {
            const c = sorted[i];
            const pct = r.total ? (100 * (c.votes || 0) / r.total) : 0;
            const item = ensureItem(i);
            const card = item.querySelector('.cand-card');

            // Image and attrs (reuse your existing helpers)
            const meta = imageMetaFor(c);
            const imgEl = card.querySelector('img');
            if (imgEl) {
                const cur = imgEl.getAttribute('src');
                if (cur !== meta.src) imgEl.setAttribute('src', meta.src);

              imgEl.alt = meta.alt;
              imgEl.dataset.party = c.party || '';
            }

            // Name overlay (reuse your helpers)
            let nameEl = card.querySelector('.cand-name');
            const { first, last } = splitName(c.name);
            const pClass = partyClass(c.party);
            if (!nameEl) {
              nameEl = document.createElement('div');
              nameEl.className = `cand-name ${pClass}`;
              nameEl.innerHTML = `<div class="first">${first}</div><div class="last">${last}</div>`;
              card.appendChild(nameEl);
            } else {
              nameEl.className = `cand-name ${pClass}`;
              const fEl = nameEl.querySelector('.first'); if (fEl) fEl.textContent = first;
              const lEl = nameEl.querySelector('.last');  if (lEl) lEl.textContent = last;
            }

            // Overlay numbers
            const numEl = card.querySelector('.cand-overlay .pct .num');
            if (numEl) numEl.textContent = pct.toFixed(2);
            const votesEl = card.querySelector('.cand-overlay .votes');
            if (votesEl) votesEl.textContent = Number(c.votes || 0).toLocaleString('en-US');

            // Leader line (use your existing markup generator)
            const newLeadHTML = leaderLineHTML(i, r.total, sorted);
            const existingLead = item.querySelector('.leadline');
            if (existingLead) {
              existingLead.outerHTML = newLeadHTML;
            } else {
              item.insertAdjacentHTML('beforeend', newLeadHTML);
            }
          }

          // Trim any surplus items
          while (list.children.length > sorted.length) {
            list.removeChild(list.lastElementChild);
          }

          // Skip the innerHTML rebuild for H 2026
          return;
        }
      }

      countyInfo.innerHTML = `<div class="cand-list">${stack}</div>`;
    }



    
async function getJSON(url){
  try {
    const r = await fetch(url, { cache: "no-store" });
    if(!r.ok) return null;
    return await r.json();
  } catch { return null; }
}
    
    // Parse one state's historic XML into rows compatible with countyData
    function parseHistoricCountyXML(xmlText) {
      const doc = new DOMParser().parseFromString(xmlText, "application/xml");
      const root = doc.querySelector("ElectionResults");
      if (!root) return [];

      const statePostal = root.getAttribute("StatePostal") || "";
      const office = root.getAttribute("Office") || "";
      const raceType = root.getAttribute("RaceTypeID") || "";

      const rows = [];
      doc.querySelectorAll("ReportingUnit").forEach(ru => {
        const name = ru.getAttribute("Name") || "";
        const fips = (ru.getAttribute("FIPS") || "").padStart(5, "0");

        const candidates = [];
        let total = 0;

        ru.querySelectorAll("Candidate").forEach(c => {
          const first = c.getAttribute("First") || "";
          const last  = c.getAttribute("Last") || "";
          const party = c.getAttribute("Party") || "";
          const votes = parseInt(c.getAttribute("VoteCount") || "0", 10) || 0;
          candidates.push({ name: `${first} ${last}`.trim(), party, votes });
          total += votes;
        });

        rows.push({
          office, raceType,
          state: statePostal,
          name,            // county name
          fips,            // 5-digit
          candidates, total
        });
      });

      return rows;
    }

    // --- House (district-level) historic parser ---
    // map USPS -> 2-digit FIPS
    const STATEFP_BY_USPS = {
      AL:"01", AK:"02", AZ:"04", AR:"05", CA:"06", CO:"08", CT:"09", DC:"11", DE:"10",
      FL:"12", GA:"13", HI:"15", IA:"19", ID:"16", IL:"17", IN:"18", KS:"20", KY:"21",
      LA:"22", MA:"25", MD:"24", ME:"23", MI:"26", MN:"27", MO:"29", MS:"28", MT:"30",
      NC:"37", ND:"38", NE:"31", NH:"33", NJ:"34", NM:"35", NV:"32", NY:"36", OH:"39",
      OK:"40", OR:"41", PA:"42", RI:"44", SC:"45", SD:"46", TN:"47", TX:"48", UT:"49",
      VA:"51", VT:"50", WA:"53", WI:"55", WV:"54", WY:"56"
    };
    
    
    // 50-state whitelist for Senate (exclude DC "11" and any territories)
    const VALID_SENATE_STATEFPS = new Set(
      Object.values(STATEFP_BY_USPS).filter(fp => fp !== "11")
    );


    
    const USPS_BY_STATEFP = Object.fromEntries(Object.entries(STATEFP_BY_USPS).map(([k,v])=>[v,k]));

    
    function parseHistoricHouseXML(xmlText, usps) {
      const statefp = STATEFP_BY_USPS[usps];
      if (!statefp) return [];

      const doc = new DOMParser().parseFromString(xmlText, "application/xml");
      const ds = [...doc.querySelectorAll("District, ReportingUnit")];
      const rows = [];

      for (const d of ds) {
        let dn = (d.getAttribute("District") || d.getAttribute("Id") || d.getAttribute("Number") || "00").padStart(2, "0");
        const nm = (d.getAttribute("Name") || "");
        if (/at[- ]?large/i.test(nm)) dn = "00";

        const district_id = statefp + dn;

        // NEW: try multiple attrs for district call status
        const dStatus = d.getAttribute("RaceCallStatus") || d.getAttribute("CallStatus") || d.getAttribute("race_call_status") || null;

        let total = 0, winnerName = null, winnerParty = null, anyWinnerFlag = false;
        const candidates = [...d.querySelectorAll("Candidate")].map(c => {
          const first = c.getAttribute("First") || "";
          const last  = c.getAttribute("Last")  || "";
          const party = c.getAttribute("Party") || "";
          const votes = parseInt(c.getAttribute("VoteCount") || "0", 10) || 0;

          // NEW: normalize winner flag(s)
          const winAttr = (c.getAttribute("Winner") || c.getAttribute("IsWinner") || "").toString().toLowerCase();
          const winner = winAttr === "x" || winAttr === "true";

          if (winner) { anyWinnerFlag = true; winnerName = `${first} ${last}`.trim(); winnerParty = party; }
          total += votes;
          return { name: `${first} ${last}`.trim(), party, votes, Winner: winner ? "X" : "", winner };
        });

        // Top candidate (fallback if needed)
        const top = candidates.slice().sort((a,b)=>b.votes-a.votes)[0];

        const row = {
          office: "H",
          raceType: "G",
          state: usps,
          name: `CD ${dn === "00" ? "At-Large" : parseInt(dn,10)}`,
          district_id,
          candidates,
          total
        };

        // NEW: propagate call + called winner only when truly called
        if (dStatus) row.race_call_status = dStatus;
        if ((dStatus && isRaceCalled(dStatus)) || anyWinnerFlag) {
          row.race_call_status = dStatus || "Called";
          row.race_called_winner_name  = winnerName || top?.name || null;
          row.race_called_winner_party = winnerParty || top?.party || null;
        }

        rows.push(row);
      }
      return rows;
    }


    
    
    // Load all available states for a given historic (year, office, race) into countyData (memoized)
    async function loadHistoricXML(year, office, race) {
      const key = `${year}-${office}-${race}`;
      if (HIST_CACHE[key]) { countyData = HIST_CACHE[key]; return; }

      const localData = {};
      const tasks = HIST_STATES.map(async (st) => {
        try {
          const url = `${HIST_BASE}/${year}/${office}/${st}.xml`;
          const res = await fetch(url, { cache: "force-cache" });
          if (!res.ok) return;
          const txt  = await res.text();

          if (office === "H") {
            // district-level
            const rows = parseHistoricHouseXML(txt, st);
            rows.forEach(r => { localData[r.district_id] = r; });
          } else {
            // county-level (P/S/G)
            const rows = parseHistoricCountyXML(txt);
            rows.forEach(r => { localData[r.fips] = r; });

            if (["P","G","S"].includes(office)) {
              const doc  = new DOMParser().parseFromString(txt, "application/xml");
              const root = doc.querySelector("ElectionResults");
              const rootStatus = root?.getAttribute("RaceCallStatus") || null;
              const percentIn  = parseFloat(root?.getAttribute("PercentIn") || "");

              const tally = new Map();
              rows.forEach(r => {
                (r.candidates || []).forEach(c => {
                  const k = (c.party || "IND") + "|" + (c.name || "");
                  tally.set(k, (tally.get(k) || 0) + (c.votes || 0));
                });
              });
              const top = [...tally.entries()].sort((a,b)=>b[1]-a[1])[0];
              const [topParty, topName] = top ? top[0].split("|") : [null, null];

              rows.forEach(r => {
                if (!Number.isNaN(percentIn)) r.state_percent_in = percentIn;
                if (rootStatus)               r.race_call_status = rootStatus;
                if (rootStatus && isRaceCalled(rootStatus) && top) {            // only when truly called
                  r.race_called_winner_party = topParty;
                  r.race_called_winner_name  = topName;
                }
              });
            }

          }
        } catch (_) { /* ignore missing/failed states */ }
      });

      await Promise.all(tasks);
      HIST_CACHE[key] = JSON.parse(JSON.stringify(localData));
      countyData = HIST_CACHE[key];
    }

    let WARMED = false;
    async function warmHistoricPreload(){
      if (WARMED) return;        // prevent duplicate runs
      WARMED = true;

      try {
        const combos = [
          ["P","G",["2016","2020","2024"]],
          ["G","G",Array.from(GOV_HIST_YEARS)],
          ["S","G",Array.from(SEN_HIST_YEARS)],
          ["H","G",Array.from(HOUSE_HIST_YEARS)],
        ];

        const tasks = [];
        for (const y of HOUSE_HIST_YEARS) tasks.push(loadDistrictMapForYear(y));
        for (const [o,r,years] of combos) {
          for (const y of years) tasks.push(loadHistoricXML(y, o, r));
        }
        await Promise.allSettled(tasks);

        try {
          const urls = new Set();

          // party badges always
          ["dem","rep","ind","lib","grn","npa"].forEach(p => urls.add(`../images/${p}.png`));

          // collect real images the UI will use (party icon vs headshot)
          for (const [key, rows] of Object.entries(HIST_CACHE)) {
            const [year, office] = key.split("-");
            for (const row of Object.values(rows)) {
              for (const c of (row.candidates || [])) {
                urls.add(resolveImageFor(year, office, c));
              }
            }
          }

          preloadImages([...urls]);
        } catch {} // inner preload try
      } catch {}   // <-- add this to close the OUTER try
    }





// Single action: read cache (no upstream hit)
async function getDataFromCache(){
      const token = ++REQ_TOKEN;
      const ctx = { year: YEAR, office: OFFICE, race: RACE };
  // Historic XML: P (2016/2020/2024) GEN + G (2016/2018/2020/2022/2024) GEN + S (2024) GEN
  const isHistoric = isHistoricMode();

  if (isHistoric) {

    stopLivePolling();
    statusEl.textContent = `loading historic XML… year=${YEAR} • office=${OFFICE} • raceTypeId=${RACE}`;
    await loadHistoricXML(ctx.year, ctx.office, ctx.race);
        if (token !== REQ_TOKEN || YEAR!==ctx.year || OFFICE!==ctx.office || RACE!==ctx.race) return; // stale, bail
    colorizeInstant();
    if (["P","S","G"].includes(OFFICE) && selectedStateFP && NAV_LEVEL >= 1) {
        renderStatePanel(selectedStateFP);
        }
    if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
        renderNationalPanel();
      }
    if (OFFICE === "H" && selectedDistrict) {
      renderDistrictPanel(selectedDistrict);
    } else if (selectedFips) {
      renderCountyPanel(selectedFips);
      showPercentInBoltForCounty(selectedFips);
    }

    
    return;
  }


  // Default rule: non-2026 years show a blank map (until sources are connected)
  if (YEAR !== "2026") {
    stopLivePolling();
    countyData = {};
    colorizeInstant(true);
    if (OFFICE === "H" && selectedDistrict) {
      countyInfo.innerHTML = `<p>No data for ${YEAR} House district ${selectedDistrict}</p>`;
    } else if (selectedFips) {
      countyInfo.innerHTML = `<p>No data for ${YEAR} (FIPS ${selectedFips})</p>`;
    } else {
      countyInfo.innerHTML = `<p>No data for ${YEAR} yet.</p>`;
    }

    return;
  }

  


  // fetch rows for the current selection
  const d = await getJSON(`/cache/ru?office=${OFFICE}&raceTypeId=${encodeURIComponent(RACE)}`);

  if (d && d.rows && token === REQ_TOKEN && YEAR===ctx.year && OFFICE===ctx.office && RACE===ctx.race) {
    if (OFFICE === "H") {
      d.rows.forEach(row => { countyData[row.district_id] = row; });
    } else {
      d.rows.forEach(row => { countyData[row.fips] = row; });
    }
    colorizeInstant(true);   // incremental repaint + HUD progress
    if (["P","S","G"].includes(OFFICE) && selectedStateFP && NAV_LEVEL >= 1) {
        renderStatePanel(selectedStateFP);
       }
       if (selectedFips) {
         renderCountyPanel(selectedFips);
         showPercentInBoltForCounty(selectedFips);
       } else if (selectedDistrict) {
         renderDistrictPanel(selectedDistrict);
         showPercentInBoltForDistrict(selectedDistrict);
       } else if (selectedStateFP) {
         renderStatePanel(selectedStateFP);
       } else if (NAV_LEVEL === 0 && !selectedStateFP && !selectedFips && !selectedDistrict) {
         renderNationalPanel();
       }


  }

  // refresh details panel if something is selected
  if (OFFICE === "H" && selectedDistrict) {
    renderDistrictPanel(selectedDistrict);
    showPercentInBoltForDistrict(selectedDistrict);
  } else if (selectedFips) {
    renderCountyPanel(selectedFips);
  }

  // append-only log read (also cached)
  
}

    

    
    // Year buttons: 2026 = live (poll), others = historic (no poll)
    // Year buttons: 2026 = live (poll), others = historic (no poll)
    document.querySelectorAll("#yearButtons button").forEach(btn => {
      btn.onclick = async () => {
        // toggle active class
        document.querySelectorAll("#yearButtons button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");

        // capture current year BEFORE changing it
        const prevYear = YEAR;

        // set year
        YEAR = btn.dataset.year;
        if (BOP_MODE) renderBopIfActive();
        updateOfficeAvailability();
        updateHeaderTitle();
        updateRaceAvailability();
        
        // If we’re in House, coming from a historic year into 2026, and were drilled to a district,
        // reset to national and rebuild the 2026 national House view.
        if (OFFICE === "H" && NAV_LEVEL === 2) {
          // clear selection + nav
          selectedStateFP = null;
          selectedFips = null;
          selectedDistrict = null;
          NAV_LEVEL = 0;
          hidePercentInBolt();

          // make sure 2026 CD geometries are loaded and camera is at national
          await loadDistrictMapForYear(YEAR);
          d3.select("#map").interrupt().transition().duration(0).call(zoom.transform, INITIAL_VIEW);

          // reload data + repaint national
          countyData = {};
          await getDataFromCache();      // this already repaints and will render the right panel nationally
          drawShapes();
          colorizeInstant(true);
          renderNationalPanel();         // belt-and-suspenders national panel
          updateActiveBadge();
          updateHeaderTitle();
          syncPercentBolt();
          return;                        // IMPORTANT: skip the “stay-zoomed” branch below
        }
        updateHeaderTitle();

        // 🚩 Stay-zoomed across ALL years (live + historic) for P/S/G.
        if (["P","S","G"].includes(OFFICE) && selectedStateFP && NAV_LEVEL >= 1) {
          const prevFips = selectedFips;

          // 1) Ensure the correct state's counties are bound before painting
          const sd = statesFeatures.find(s => String(s.id).padStart(2,"0") === selectedStateFP);
          if (sd) {
            focusStateByPrefix(selectedStateFP, sd); // sets CURRENT_GEOM='counties' and countiesSel
          }

          // 2) Load the data for the new YEAR/OFFICE/RACE
          countyData = {};
          if (YEAR === "2026") startLivePolling(); else stopLivePolling();
          await getDataFromCache();   // will now call colorizeInstant(true) (change #1)

          // 3) Force a repaint (belt-and-suspenders) and restore selection/panel
          colorizeInstant(true);
          if (sd) drawNeighborStatesOverlay(sd);
          if (NAV_LEVEL === 2 && prevFips) {
            selectedFips = prevFips;
            countyLayer.selectAll("path.county").classed("highlight", false);
            countyLayer.select(`#c${selectedFips}`).classed("highlight", true);
            renderCountyPanel(selectedFips);
            showPercentInBoltForCounty(selectedFips);
          } else {
            renderStatePanel(selectedStateFP);
          }

          updateActiveBadge();
          syncPercentBolt();
          return; // IMPORTANT: skip national reset
        }

        // 🚩 Stay-zoomed across years for H districts (district view only)
        if (OFFICE === "H" && selectedDistrict && NAV_LEVEL === 2) {
          // Make sure we're on the right live/historic polling
          if (YEAR === "2026") startLivePolling(); else stopLivePolling();

          // Ensure district geometries for this year are loaded
          await loadDistrictMapForYear(YEAR);
          drawShapes();

          // Refresh data for this year/office/race and repaint
          countyData = {};
          await getDataFromCache();

          // Keep the state focused so district paths exist and zoom stays stable
          const statefp = selectedDistrict.slice(0, 2);
          const sd = statesFeatures.find(s => String(s.id).padStart(2,"0") === statefp);
          if (sd) {
            focusHouseStateByPrefix(statefp, sd);   // <-- use the HOUSE version
          }

          // Rebuild right panel and update %IN bolt for the district
          renderDistrictPanel(selectedDistrict);
          showPercentInBoltForDistrict(selectedDistrict);

          colorizeInstant(true);
          updateActiveBadge();
          return; // IMPORTANT: skip national reset
        }

        // normal path (no stay-zoomed)
        selectedFips = null;
        selectedDistrict = null;
        countyInfo.innerHTML = "";
        hidePercentInBolt();
        
        d3.select("#map").transition().duration(0)
          .call(zoom.transform, INITIAL_VIEW);

        if (OFFICE === "H") {
          await loadDistrictMapForYear(YEAR);
          drawShapes();   // draw the new year's district map
        }

        countyData = {};
        colorizeInstant();
        updateActiveBadge();

        if (YEAR === "2026") {
          startLivePolling();
          getDataFromCache();
        } else {
          stopLivePolling();
          getDataFromCache(); // historic branch
        }
      };
    });





    function showCounty(event,d){
      svg.selectAll("path.county").classed("highlight",false);
      d3.select(this).classed("highlight",true);
      const f = String(d.id).padStart(5,"0");
      selectedFips = f;  // remember last selected FIPS
      renderCountyPanel(f);
      showPercentInBoltForCounty(f);
    }

    function renderCountyPanel(f){
      const r = countyData[f];
      if(!r){
        countyInfo.innerHTML = `<p>No cached data for FIPS ${f}</p>`;
        return;
      }

      const sorted = (r.candidates || [])
        .slice()
        .sort((a,b)=>(b.votes||0)-(a.votes||0));

      const stack = sorted.map((c, i) => {
        const pct = r.total ? (100 * (c.votes || 0) / r.total) : 0;
        const useParty = shouldUsePartyIcon(YEAR, OFFICE);
        const img = (OFFICE === 'S') ? imgForParty(c.party)
          : (OFFICE === 'G') ? imgForParty(c.party)
          : (OFFICE === 'H') ? imgForParty(c.party)
          : (shouldUsePartyIcon(YEAR, OFFICE) ? imgForParty(c.party) : imgForCandidate(c.name));

          const alt = (OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H') ? 'Candidate'
             : (shouldUsePartyIcon(YEAR, OFFICE) ? (c.party || 'Party') : c.name);

        // Only show FIRST+LAST name overlay for Presidential (P) to match your other views
        const nameOverlay = (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H')
          ? (() => {
              const { first, last } = splitName(c.name);
              const pClass = partyClass(c.party);
              return `
                <div class="cand-name ${pClass}">
                  <div class="first">${first}</div>
                  <div class="last">${last}</div>
                </div>`;
            })()
          : '';

          return `
            <div class="cand-item">
              <div class="cand-card">
                ${(() => { const {src, alt} = imageMetaFor(c); return `
                  <img src="${src}" alt="${alt}" data-party="${c.party || ''}">
                `; })()}
                ${nameOverlay}
                <div class="cand-overlay">
                  <div class="pct">
                    <span class="num">${pct.toFixed(2)}</span>
                    <span class="pct-sign">%</span>
                  </div>
                  <div class="votes">${fmt(c.votes)}</div>
                </div>
              </div>
              ${ leaderLineHTML(i, r.total, sorted) }
            </div>`;

      }).join("");

      

      if (YEAR === '2026' && (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G')) {
        const list = countyInfo.querySelector('.cand-list');
        if (list && list.children.length) {

          // Ensure a cand-item exists at index idx; create minimal skeleton if missing
          const ensureItem = (idx) => {
            let item = list.children[idx];
            if (!item) {
              const wrap = document.createElement('div');
              wrap.innerHTML = `
                <div class="cand-item">
                  <div class="cand-card">
                    <img src="" alt="" data-party="">
                    <div class="cand-overlay">
                      <div class="pct">
                        <span class="num"></span><span class="pct-sign">%</span>
                      </div>
                      <div class="votes"></div>
                    </div>
                  </div>
                  <div class="leadline"></div>
                </div>`;
              item = wrap.firstElementChild;
              list.appendChild(item);
            }
            return item;
          };

          for (let i = 0; i < sorted.length; i++) {
            const c = sorted[i];
            const pct = r.total ? (100 * (c.votes || 0) / r.total) : 0;
            const item = ensureItem(i);
            const card = item.querySelector('.cand-card');

            // Image (party vs headshot) + attributes
            const meta = imageMetaFor(c);
            const imgEl = card.querySelector('img');
            if (imgEl) {
                const cur = imgEl.getAttribute('src');
                if (cur !== meta.src) imgEl.setAttribute('src', meta.src);

              imgEl.alt = meta.alt;
              imgEl.dataset.party = c.party || '';
            }

            // Candidate name overlay (first/last) with party color class
            let nameEl = card.querySelector('.cand-name');
            const { first, last } = splitName(c.name);
            const pClass = partyClass(c.party);
            if (!nameEl) {
              nameEl = document.createElement('div');
              nameEl.className = `cand-name ${pClass}`;
              nameEl.innerHTML = `<div class="first">${first}</div><div class="last">${last}</div>`;
              card.appendChild(nameEl);
            } else {
              nameEl.className = `cand-name ${pClass}`;
              const fEl = nameEl.querySelector('.first'); if (fEl) fEl.textContent = first;
              const lEl = nameEl.querySelector('.last');  if (lEl) lEl.textContent = last;
            }

            // Overlay numbers (percent & votes)
            const numEl = card.querySelector('.cand-overlay .pct .num');
            if (numEl) numEl.textContent = pct.toFixed(2);
            const votesEl = card.querySelector('.cand-overlay .votes');
            if (votesEl) votesEl.textContent = Number(c.votes || 0).toLocaleString('en-US');

            // Leader line (replace or insert once)
            const newLeadHTML = leaderLineHTML(i, r.total, sorted);
            const existingLead = item.querySelector('.leadline');
            if (existingLead) {
              // replace the whole node to reuse your exact markup/styling
              existingLead.outerHTML = newLeadHTML;
            } else {
              item.insertAdjacentHTML('beforeend', newLeadHTML);
            }
          }

          // Trim any extra old items if the new list is shorter
          while (list.children.length > sorted.length) {
            list.removeChild(list.lastElementChild);
          }

          // Done: we updated in place; skip the innerHTML rebuild
          return;
        }
      }
      // === end no-flash block ===

      
      
      countyInfo.innerHTML = `
        <div class="cand-list">${stack}</div>
      `;
    }


    
    // Pull the first available statewide %in from any county in the state
    function findStatePercentIn(prefix2){
      for (const [key, row] of Object.entries(countyData)) {
        if (key.length === 5 && key.startsWith(prefix2)) {
          const val = Number(row.state_percent_in);
          if (!Number.isNaN(val)) return val;
        }
      }
      return null;
    }


    function renderStatePanel(statefp){
        if (window.NO_RACE_VIEW === true){
          // simple neutral panel
          const usps = USPS_BY_STATEFP?.[prefix] || prefix;
          const name = STATE_NAME_BY_USPS?.[usps] || usps;
          setPanelHTML(`
            <div class="panel panel-neutral">
              <h3>${name}</h3>
              <p>No Senate election in 2026.</p>
            </div>
          `);
          hidePercentInBolt?.();
          return;
        }
        if (YEAR === '2026' && OFFICE === 'H' && (RACE === 'D' || RACE === 'R')) {
          countyInfo.innerHTML = '';
          hidePercentInBolt();   // also hide the %IN bolt so the panel is truly empty
          return;
        }
      const usps = USPS_BY_STATEFP[statefp] || statefp;
      if (OFFICE === 'S' && String(YEAR) === '2026' && isNoSenate2026(usps)) {
        // clear / neutralize any %IN badges, legends, etc.
        hidePercentInBolt?.();

        // show a minimal, neutral message
        const name = STATE_NAME_BY_USPS?.[usps] || usps;
        setPanelHTML?.(`
          <div class="panel panel-neutral">
            <h3>${name}</h3>
            <p>No Senate election in 2026.</p>
          </div>
        `);

        // if your implementation writes directly to a container instead of setPanelHTML:
        // const el = document.getElementById('countyInfo'); if (el) el.innerHTML = `...`;

        return; // ← do not render any data rows
      }
      const agg  = (OFFICE === 'H')
        ? aggregateStateCandidatesHouse(statefp)
        : aggregateStateCandidates(statefp);
      if (!agg.total){
        countyInfo.innerHTML = `<p>No cached data for ${usps}</p>`;
        return;
      }

      // HOUSE @ state level (2026): show called seat counts by party (like national)
      if (OFFICE === 'H') {
        const rows = aggregateHouseCalledWinnersForState(statefp);
        const fmt  = n => Number(n || 0).toLocaleString('en-US');

        const html = rows.length
          ? rows.map(r => `
              <div class="party-row party-${String(r.party).toUpperCase()}">
                <div class="party-name">${r.label.toUpperCase()}</div>
                <div class="party-count">${fmt(r.count)}</div>
              </div>`).join("")
          : `<div class="party-row"><div class="party-name">No calls yet</div></div>`;

        countyInfo.innerHTML = `<div class="party-tally">${html}</div>`;
        return;
      }

      const spi = findStatePercentIn(statefp);
      showPercentInBoltForState(statefp);

      // Call line (unchanged semantics)
      let callLine = "";
      {
        const { status, winnerName, winnerParty } = getStateCall(statefp);
        if (status) {
          const isCalled = isRaceCalled(status);
          let calledVotesTxt = "";
          if (isCalled && (winnerName || winnerParty)) {
            const match = agg.candidates.find(c =>
              (!winnerName || (c.name || "").toLowerCase() === (winnerName || "").toLowerCase()) &&
              (!winnerParty || (c.party || "").toUpperCase() === (winnerParty || "").toUpperCase())
            );
            if (match) calledVotesTxt = ` — ${fmt(match.votes)}`;
          }
          const calledPiece =
            isCalled && (winnerName || winnerParty)
              ? `, <strong>Winner:</strong> ${winnerName || ""}${winnerParty ? ` (${winnerParty})` : ""}${calledVotesTxt}`
              : "";
          callLine = `<div><strong>Call status:</strong> "${status}"${calledPiece}</div>`;
        }
      }

      // ⬇️ Use the SAME card/overlay markup as national
      const stack = agg.candidates.map((c, i) => {
        const pct = agg.total ? (100 * (c.votes || 0) / agg.total) : 0;
        const img = (OFFICE === 'S') ? imgForParty(c.party)
          : (OFFICE === 'G') ? imgForParty(c.party)
          : (OFFICE === 'H') ? imgForParty(c.party)
          : (shouldUsePartyIcon(YEAR, OFFICE) ? imgForParty(c.party) : imgForCandidate(c.name));

          const alt = (OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H') ? 'Candidate'
          : (shouldUsePartyIcon(YEAR, OFFICE) ? (c.party || 'Party') : c.name);
          const nameOverlay = (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H')
          ? (() => {
              const {first,last} = splitName(c.name);
              const pClass = partyClass(c.party);
              return `
                <div class="cand-name ${pClass}">
                  <div class="first">${first}</div>
                  <div class="last">${last}</div>
                </div>`;
            })()
          : '';

          return `
            <div class="cand-item">
              <div class="cand-card">
                ${(() => { const {src, alt} = imageMetaFor(c); return `
                  <img src="${src}" alt="${alt}" data-party="${c.party || ''}">
                `; })()}
                ${
                  (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G' || OFFICE === 'H')
                    ? (() => {
                        const { first, last } = splitName(c.name);
                        const pClass = partyClass(c.party);
                        return `
                          <div class="cand-name ${pClass}">
                            <div class="first">${first}</div>
                            <div class="last">${last}</div>
                          </div>`;
                      })()
                    : ''
                }
                <div class="cand-overlay">
                  <div class="pct">
                    <span class="num">${pct.toFixed(2)}</span>
                    <span class="pct-sign">%</span>
                  </div>
                  <div class="votes">${fmt(c.votes)}</div>
                </div>
              </div>
              ${ leaderLineHTML(i, agg.total, agg.candidates) }
            </div>`;

      }).join("");
      
      // === 2026 state-level (P/S/G): update existing DOM in place (no flash on zoom-out) ===
      if (YEAR === '2026' && (OFFICE === 'P' || OFFICE === 'S' || OFFICE === 'G')) {
        const list = countyInfo.querySelector('.cand-list');
        // Only do in-place if the panel already has cards (i.e., we’re zooming back from county)
        if (list && list.children.length) {
          const ensureItem = (idx) => {
            let item = list.children[idx];
            if (!item) {
              const wrap = document.createElement('div');
              wrap.innerHTML = `
                <div class="cand-item">
                  <div class="cand-card">
                    <img src="" alt="" data-party="">
                    <div class="cand-overlay">
                      <div class="pct">
                        <span class="num"></span><span class="pct-sign">%</span>
                      </div>
                      <div class="votes"></div>
                    </div>
                  </div>
                  <div class="leadline"></div>
                </div>`;
              item = wrap.firstElementChild;
              list.appendChild(item);
            }
            return item;
          };

          // We’re in renderStatePanel: use the already-computed statewide aggregate `agg`
          for (let i = 0; i < agg.candidates.length; i++) {
            const c = agg.candidates[i];
            const pct = agg.total ? (100 * (c.votes || 0) / agg.total) : 0;
            const item = ensureItem(i);
            const card = item.querySelector('.cand-card');

            // Image (party vs headshot) + attrs using your helpers
            const meta = imageMetaFor(c);
            const imgEl = card.querySelector('img');
            if (imgEl) {
                const cur = imgEl.getAttribute('src');
                if (cur !== meta.src) imgEl.setAttribute('src', meta.src);

              imgEl.alt = meta.alt;
              imgEl.dataset.party = c.party || '';
            }

            // Candidate FIRST/LAST overlay with party class
            let nameEl = card.querySelector('.cand-name');
            const { first, last } = splitName(c.name);
            const pClass = partyClass(c.party);
            if (!nameEl) {
              nameEl = document.createElement('div');
              nameEl.className = `cand-name ${pClass}`;
              nameEl.innerHTML = `<div class="first">${first}</div><div class="last">${last}</div>`;
              card.appendChild(nameEl);
            } else {
              nameEl.className = `cand-name ${pClass}`;
              const fEl = nameEl.querySelector('.first'); if (fEl) fEl.textContent = first;
              const lEl = nameEl.querySelector('.last');  if (lEl) lEl.textContent = last;
            }

            // Overlay numbers
            const numEl = card.querySelector('.cand-overlay .pct .num');
            if (numEl) numEl.textContent = pct.toFixed(2);
            const votesEl = card.querySelector('.cand-overlay .votes');
            if (votesEl) votesEl.textContent = Number(c.votes || 0).toLocaleString('en-US');

            // Leader line (your existing generator)
            const newLeadHTML = leaderLineHTML(i, agg.total, agg.candidates);
            const existingLead = item.querySelector('.leadline');
            if (existingLead) {
              existingLead.outerHTML = newLeadHTML;
            } else {
              item.insertAdjacentHTML('beforeend', newLeadHTML);
            }
          }

          // Trim any surplus old items
          while (list.children.length > agg.candidates.length) {
            list.removeChild(list.lastElementChild);
          }

          // Done: we updated in place; skip the innerHTML rebuild
          return;
        }
      }
      // === end no-flash block ===


      countyInfo.innerHTML = `
        <div class="cand-list">${stack}</div>
      `;
    }



    // add this
    function onCountyClick(ev, d){
      zoomToFeature(d, 12);
      const f = String(d.id).padStart(5,"0");
      selectedFips = f;
      renderCountyPanel(f);
      showPercentInBoltForCounty(f);
      syncPercentBolt();
      NAV_LEVEL = 2;
      colorizeInstant();
      ev.stopPropagation();
      updateHeaderTitle();
    }


    function fillForFeature(d){
        if (OFFICE === "H") {
          // Build a stable House district id (STATEFP + CDxxFP with fallback)
          const did = `${d.properties.STATEFP}${String(
            d.properties.CD119FP ||
            d.properties.CD118FP ||
            d.properties.CD116FP ||
            d.properties.CD115FP ||
            d.id
          ).padStart(2,"0")}`;

          const r = Object.values(countyData).find(x => x.district_id === did);

          // GREY if no data or all votes are zero (matches your current convention)
          if (!r || isNoData(r) || (r.total || 0) === 0) return COLOR_NO_DATA;

          // --- NATIONAL VIEW (H 2026): use CALL STATUS for color strength ---
          // --- NATIONAL VIEW (H 2026): use CALL STATUS for color strength ---
          // AFTER — apply in national view for any year
          if (NAV_LEVEL === 0) {
            const { status, winnerParty } = getDistrictCall(did);
            const isCalled = isRaceCalled(status);
            const top = (r.candidates || []).slice().sort((a,b)=>(b.votes||0)-(a.votes||0))[0];

            if (isCalled) {
              const p = (winnerParty || top?.party || "IND").toUpperCase();
              if (p === "REP") return COLOR_GOP;
              if (p === "DEM") return COLOR_DEM;
              return COLOR_IND;
            } else {
              const lead = (top?.party || "IND").toUpperCase();
              return lead === "REP" ? COLOR_GOP_LIGHT :
                     lead === "DEM" ? COLOR_DEM_LIGHT : COLOR_IND_LIGHT;
            }
          }


          // --- ALL OTHER H views (e.g., drilled into a state/district): keep your current logic ---
          if (!r.candidates.length) return '#ffffff';
          const lead = r.candidates.slice().sort((a,b)=>b.votes-a.votes)[0].party;

          const base =
            lead === "REP" ? COLOR_GOP :
            lead === "DEM" ? COLOR_DEM : COLOR_IND;

          if (selectedDistrict && did !== selectedDistrict) {
            return lead === "REP" ? COLOR_GOP_LIGHT :
                   lead === "DEM" ? COLOR_DEM_LIGHT : COLOR_IND_LIGHT;
          }
          return base;
        }
        else {
        // === P / S / G county coloring ===
        // === P / S / G county coloring ===
        const f = String(d.id).padStart(5, "0");
        const r = countyData[f];
        if (!r) return COLOR_BG;

        // ⛔ Senate 2026: force entire state’s counties to grey if no election
        if (OFFICE === "S" && String(YEAR) === "2026" && NAV_LEVEL >= 1) {
          const selectedUSPS =
            USPS_BY_STATEFP?.[String(selectedStateFP).padStart(2,"0")] || null;
          const usps = r.state || USPS_BY_STATEFP?.[f.slice(0,2)];

          // Grey counties only if they belong to a *different* state that has no race
          if (usps && usps !== selectedUSPS && isNoSenate2026(usps)) {
            return NO_RACE_GREY;
          }
        }


        // If no candidate rows or zero votes, keep your existing greys
        if (!r.candidates?.length) return COLOR_BG;
        if ((r.total || 0) === 0) return COLOR_NO_DATA;

        // Normal county coloring (winner/leader)
        const lead = r.candidates.slice().sort((a,b)=>b.votes-a.votes)[0].party;
        let base =
          lead === "REP" ? COLOR_GOP :
          lead === "DEM" ? COLOR_DEM : COLOR_IND;

        // Dim neighbors when drilled into a single county
        if (["P","S","G"].includes(OFFICE) && NAV_LEVEL === 2 && selectedFips) {
          const statefp = selectedFips.slice(0,2);
          const thisStatefp = f.slice(0,2);
          if (thisStatefp === statefp && f !== selectedFips) {
            base =
              lead === "REP" ? COLOR_GOP_LIGHT :
              lead === "DEM" ? COLOR_DEM_LIGHT : COLOR_IND_LIGHT;
          }
        }
        return base;

      }
    }




    function colorizeInstant(force = false){
      if (!force && IS_ZOOMING) { PAINT_DEFERRED = true; return; }

      // H national view: repaint districts using call-aware national logic
      if (OFFICE === "H" && NAV_LEVEL === 0) {
        const total = districtShapes?.length || 0;
        let painted = 0;
        (districtsSel || countyLayer.selectAll("path.district"))
          .attr("fill", d => {
            const fill = fillForFeature(d); // national H logic is inside fillForFeature()
            if (fill !== COLOR_BG) painted++;
            return fill;
          });
        paintEl.textContent = `paint ${painted}/${total}`;
        return;
      }

      // P/S/G national states repaint (or any other 'states' geom case that isn’t House)
      if (CURRENT_GEOM === 'states' && OFFICE !== 'H') {
        const total = statesFeatures ? statesFeatures.length : 0;
        let painted = 0;

        statesSel.attr("fill", d => {
          const usps = d.usps || d.properties?.usps || d.properties?.STUSPS || USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];

          // Use the correct helper name
          if (typeof isNoRace2026 === "function" && isNoRace2026(usps)) {
            if (NO_RACE_GREY !== COLOR_BG) painted++;
            return NO_RACE_GREY;
          }

          const fill = fillForState(d);
          if (fill !== COLOR_BG) painted++;
          return fill;
        });

        paintEl.textContent = `paint ${painted}/${total}`;
        return;
      }

      // Fallback: drilled-in views (districts or counties)
      const isHouse = (OFFICE === "H");
      const total = isHouse ? (districtShapes?.length || 0) : (countyShapes?.length || 0);
      let painted = 0;

      const sel = isHouse
         ? (districtsSel || countyLayer.selectAll("path.district"))
         : (countiesSel  || countyLayer.selectAll("path.county"));

      sel
        ?.attr("fill", d => {
          // If we drilled into an S/2026 no-race state, paint all counties grey
          if (window.NO_RACE_VIEW === true) return NO_RACE_GREY;

          const fill = (isHouse && NAV_LEVEL >= 1)
            ? fillForDistrictFeature(d, { insideSelected:true })
            : fillForFeature(d);
          if (fill !== COLOR_BG) painted++;
          return fill;
        })
        .classed("no-race", d => {
          if (isHouse) return false;
          const f = String(d.id).padStart(5,"0");
          const usps = (countyData[f]?.state) || USPS_BY_STATEFP?.[f.slice(0,2)];
          return (
              YEAR === "2026" &&
              ((OFFICE === "S" && isNoSenate2026(usps)) ||
               (OFFICE === "G" && isNoGovernor2026(usps)))
            );
        });

      paintEl.textContent = `paint ${painted}/${total}`;

      // STATE VIEW backdrop tinting for S 2026:
      // Grey the selected no-race state AND any other no-race states.
      if (NAV_LEVEL >= 1 && OFFICE === 'S' && String(YEAR) === '2026' && statesSel) {
        const selectedUSPS =
          USPS_BY_STATEFP?.[String(selectedStateFP).padStart(2,"0")] || null;

        statesSel
          .attr('fill', d => {
            const usps =
              d.usps ||
              d.properties?.usps ||
              d.properties?.STUSPS ||
              USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];

            // Grey the selected state if it has no race
            if (usps && usps === selectedUSPS && isNoSenate2026(usps)) {
              return NO_RACE_GREY;
            }
            // Grey other states with no race
            if (usps && usps !== selectedUSPS && isNoSenate2026(usps)) {
              return NO_RACE_GREY;
            }
            // Otherwise leave normal backdrop
            return fillForState?.(d) ?? COLOR_BG;
          })
          .classed('no-race', d => {
            const usps =
              d.usps ||
              d.properties?.usps ||
              d.properties?.STUSPS ||
              USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
            return !!usps && isNoSenate2026(usps);
          });
      }
      if (NAV_LEVEL >= 1 && OFFICE === 'G' && String(YEAR) === '2026' && statesSel) {
        const selectedUSPS = USPS_BY_STATEFP?.[String(selectedStateFP).padStart(2,"0")] || null;
        statesSel
          .attr('fill', d => {
            const usps =
              d.usps || d.properties?.usps || d.properties?.STUSPS ||
              USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
            if (usps && isNoGovernor2026(usps)) return NO_RACE_GREY;
            return fillForState?.(d) ?? COLOR_BG;
          })
          .classed('no-race', d => {
            const usps =
              d.usps || d.properties?.usps || d.properties?.STUSPS ||
              USPS_BY_STATEFP?.[String(d.id).padStart(2,"0")];
            return !!usps && isNoGovernor2026(usps);
          });
      }
      // Neighbor overlays (unchanged)
      if (["P","S","G"].includes(OFFICE) &&
          selectedStateFP && NAV_LEVEL >= 1 &&
          typeof window.drawNeighborStatesOverlay === "function") {
        const sd = statesFeatures?.find(s => String(s.id).padStart(2, "0") === selectedStateFP);
        if (sd) window.drawNeighborStatesOverlay(sd);
      }
      if (OFFICE === "H" &&
          selectedStateFP && NAV_LEVEL >= 1 &&
          typeof window.drawNeighborDistrictsOverlay === "function") {
        const sd = statesFeatures?.find(s => String(s.id).padStart(2, "0") === selectedStateFP);
        if (sd) window.drawNeighborDistrictsOverlay(sd);
      }
    }



function fmt(n){return(n||0).toLocaleString("en-US");}


const btnLeft  = document.getElementById("getDataBtn");
if (btnLeft) btnLeft.onclick = getDataFromCache;

const btnRight = document.getElementById("getDataBtnRight");
if (btnRight) btnRight.onclick = getDataFromCache;

// Silent, last-ditch fallback for missing candidate headshots
window.addEventListener('error', (e) => {
  const t = e.target;
  if (t && t.tagName === 'IMG') {
    const party = t.getAttribute('data-party') || 'IND';
    t.src = imgForParty(party);
  }
}, true);
    
    
    // One-time: pick the same SVG your P race uses
    function getMapSvg(){
      // adjust the selector if your map svg lives elsewhere
      const svg = d3.select('.map-shell svg');
      return svg.empty() ? null : svg;
    }

    function renderPathMap(){
      const svg = getMapSvg();
      if (!svg) return;

      [nationalStateLayer, countyLayer, neighborStateLayer, neighborDistrictLayer, stateShadowLayer, activeStateOutline, stateLayer, cityLayer]
          .forEach(g => { try { g.attr("display","none"); } catch {} });
      
        // Clear any previous Path overlay and add it INSIDE the zoomed container
        rootG.select('#pathModeRoot').remove();
        const root = rootG.append("g").attr("id","pathModeRoot");
      const statesG = root.append("g").attr("id","pathStates");
      const hitsG   = root.append("g").attr("id","pathHits");
      const hatchG  = root.append("g").attr("id","pathHatchLayer").style("pointer-events","none"); // NEW
     
      const BORDER = (window.MAP_BORDER_COLOR || "#9aa2a9");

      // Fills only (no stroke here)
      statesG.selectAll("path")
        .data(statesFeatures, d => d.id)
        .join("path")
          .attr("d", path)
          .attr("fill", "#fff")
          .attr("stroke", "none")
          .style("pointer-events", "none");

      // NEW: borders layer that matches the P race hairline
      const bordersG = root.append("g").attr("id", "pathBorders");
      bordersG.selectAll("path")
        .data(statesFeatures, d => d.id)
        .join("path")
          .attr("d", path)
          .attr("fill", "none")
          .attr("stroke", "#fff")
          .attr("stroke-width", 0.5)
          .attr("vector-effect", "non-scaling-stroke")
          .style("pointer-events", "none");


      hitsG.selectAll("path")
        .data(statesFeatures, d => d.id)
        .join("path")
          .attr("d", path)
          .attr("fill", "rgba(0,0,0,0)")
          .style("pointer-events", "auto")
          .style("cursor", "pointer")
          .each(function(d){
                 const usps = uspsFromFeature(d);
                 const pick = PATH_STATE_ASSIGN[usps];
                 if (pick) paintPathState(d3.select(this), pick);
               })
               // ---------- NEW: multi-click cycle handler ----------
          .on('click', onPathStateClick);
          updateNebraskaHatch();
          updateMaineHatch();


    }

    
    function onPathStateClick(event, d){
      if (!document.body.classList.contains('path-mode')) return;

      // No brush armed → do nothing
      if (!PATH_BRUSH) return;

      const usps = uspsFromFeature(d);
      PATH_STATE_ASSIGN[usps] = PATH_BRUSH;

      paintPathState(d3.select(this), PATH_BRUSH);
      recomputePathEVs();
      updateMaineHatch();
      updateNebraskaHatch();

    }


    
    function teardownPathMap(){
      const svg = d3.select('.map-shell svg');
      if (svg.empty()) return;

      // Remove only the Path overlay
        rootG.select('#pathModeRoot').remove();
      
        // Unhide the normal map layers (zoom container never got hidden)
        [nationalStateLayer, countyLayer, neighborStateLayer, neighborDistrictLayer, stateShadowLayer, activeStateOutline, stateLayer, cityLayer]
          .forEach(g => { try { g.attr("display", null); } catch {} });

      // Belt & suspenders: ensure the live layers exist and repaint
      try { ensureMapScaffold?.(); } catch {}
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          try { ensureMapRendered?.({ force:true }); } catch {}
          try { drawShapes?.(); } catch {}
          try { colorizeInstant?.(true); } catch {}
          try { renderNationalPanel?.(); } catch {}
          try { syncPercentBolt?.(); } catch {}
        });
      });
    }



    
    function renderHouseHorseshoe2026(containerEl){
      // accept either casing from callers
      const container = containerEl || containerel;
      if (!container) return;

      // --- 1) Tally national called + uncalled leaders (House 2026) ---
      const tallies    = aggregateHouseUncalledLeaderCountsNational();
      const called     = tallies.called;     // { DEM, REP, IND }
      const uncalled   = tallies.uncalled;   // { DEM, REP, IND }
      const noData     = tallies.noData || 0;
      const totalSeats = Math.max(1, tallies.total || 0);

      // --- 2) Build SVG scaffold (rotated group + arc) ---
      const w = 900, h = 520;
      const outerR = Math.min(w, h) * 0.45;
      const innerR = outerR * 0.58;

      const svg = d3.select(container)
        .html('') // clear previous render
        .append('svg')
          .attr('viewBox', `${-w/2} ${-h/2} ${w} ${h}`)
          .attr('aria-label', 'House Balance of Power');

      // rotate -90° so left→right order maps onto top semicircle
      // shift the horseshoe horizontally (px). negative = left, positive = right
      const HSHIFT = -50;

      const shoeG = svg.append('g')
        .attr('transform', `translate(${HSHIFT}, 0)`);

      const g = shoeG.append('g')
        .attr('transform', `rotate(-90) translate(0, ${h*0.08})`);

      const arc = d3.arc().innerRadius(innerR).outerRadius(outerR);

      // --- 3) Colors (solid for called, dim for uncalled) ---
      const DEM_SOLID = partySolid('DEM');
      const REP_SOLID = partySolid('REP');
      const IND_SOLID = partySolid('IND');
      const DEM_DIM   = partyDim('DEM');
      const REP_DIM   = partyDim('REP');
      const IND_DIM   = partyDim('IND');

      // --- 4) Segments in requested left→right order ---
      let segs = [
        { key:'DEM_CALLED',     value: called.DEM,     color: DEM_SOLID },
        { key:'DEM_UNCALLED',   value: uncalled.DEM,   color: DEM_DIM   },
        { key:'IND_CALLED',     value: called.IND,     color: IND_SOLID },
        { key:'IND_UNCALLED',   value: uncalled.IND,   color: IND_DIM   },
        { key:'NO_DATA',        value: noData,         color: COLOR_NO_DATA }, // neutral wedge
        { key:'REP_UNCALLED',   value: uncalled.REP,   color: REP_DIM   },
        { key:'REP_CALLED',     value: called.REP,     color: REP_SOLID },
      ].filter(s => s.value > 0);

      // placeholder if we have nothing yet (avoids NaNs)
      if (segs.length === 0){
        segs = [
          { key:'DEM_UNCALLED', value: 1, color: DEM_DIM },
          { key:'IND_UNCALLED', value: 1, color: IND_DIM },
          { key:'REP_UNCALLED', value: 1, color: REP_DIM },
        ];
      }

      // --- 5) Angle layout across π radians (top semicircle) ---
      // keep visual order left→right matching the array above
      segs = segs.reverse();

      const startAngle = Math.PI;
      const sumVals = segs.reduce((a,s)=>a+s.value, 0);
      let acc = 0;
      const angles = segs.map(s => {
        const a0 = startAngle - (acc / sumVals) * Math.PI;
        acc += s.value;
        const a1 = startAngle - (acc / sumVals) * Math.PI;
        return { ...s, a0, a1 };
      });

      // --- 6) Draw wedges ---
      g.selectAll('path.seg')
        .data(angles)
        .join('path')
          .attr('class','seg')
          .attr('d', d => arc({ startAngle: d.a0, endAngle: d.a1 }))
          .attr('fill', d => d.color)
          .attr('stroke', '#fff')
          .attr('stroke-width', 0);

      // --- 6.5) Midpoint tick (majority line) ---
      const mid = 0; // halfway between startAngle=π and endAngle=0
      g.append('line')
       .attr('x1', (innerR * 0.91) * Math.cos(mid))
       .attr('y1', (innerR * 0.91) * Math.sin(mid))
       .attr('x2', (outerR * 1.05) * Math.cos(mid))
       .attr('y2', (outerR * 1.05) * Math.sin(mid))
       .attr('stroke', '#000')
       .attr('stroke-width', 3)
       .attr('stroke-linecap', 'round')
       .attr('vector-effect', 'non-scaling-stroke');
       
       // --- 6.7) Majority label inside the horseshoe opening ---
       const majority = 218;  // e.g. 218 of 435
       const centerY  = innerR * 0.22;                   // pushes text into the opening

       const centerG = shoeG.append('g');                // unrotated (same as labelG)

       // big number
       centerG.append('text')
         .attr('x', 42)
         .attr('y', centerY - 80)
         .attr('text-anchor', 'middle')
         .attr('font-family', 'Oswald, system-ui, sans-serif')
         .attr('font-weight', 800)
         .attr('font-size', 44)
         .attr('fill', '#111')
         .text(majority);

       // "FOR MAJORITY"
       centerG.append('text')
         .attr('x', 42)
         .attr('y', centerY - 53)   // space below the number
         .attr('text-anchor', 'middle')
         .attr('font-family', 'Oswald, system-ui, sans-serif')
         .attr('font-weight', 700)
         .attr('font-size', 18)
         .attr('letter-spacing', 0.6)
         .attr('fill', '#111')
         .text('FOR MAJORITY');


      // --- 7) Compact TV-style party labels (upper-left / upper-right) ---
      // Unrotated labels so text is horizontal, using tspans for a manual line break
      const labelG = svg.append('g');
      const topY   = -outerR * 0.55; // vertical position above the arc
      const leftX  = -w/2 + 12;      // inset from left edge
      const rightX =  w/2 - 12;      // inset from right edge

      const DEM_DX = 187.5,  DEM_DY = -113;   // move Dems up & to the right
      const REP_DX = -187.5, REP_DY = -113;   // move Reps up & to the left

      // sizes + vertical gap between lines
      const LINE1_SIZE = 22;   // label size
      const LINE2_SIZE = 46;   // big number size
      const GAP        = 40;   // extra pixels between lines

      const demLine1 = 'DEMOCRATS';
      const repLine1 = 'REPUBLICANS';
      
      const SHOW_DELTA = false;

      const demLine2 = SHOW_DELTA && uncalled.DEM ? `${called.DEM} (+${uncalled.DEM})` : String(called.DEM);
      const repLine2 = SHOW_DELTA && uncalled.REP ? `${called.REP} (+${uncalled.REP})` : String(called.REP);

      // Democrats — upper left
      labelG.append('text')
        .attr('x', leftX + DEM_DX)
        .attr('y', topY  + DEM_DY)
        .attr('text-anchor','start')
        .attr('font-family','Oswald, system-ui, sans-serif')
        .attr('font-weight',700)
        .attr('font-size', LINE1_SIZE)
        .attr('fill', DEM_SOLID)
        .text(demLine1);

      labelG.append('text')
        .attr('x', leftX + DEM_DX)
        .attr('y', topY + DEM_DY + LINE1_SIZE + GAP) // explicit offset below line 1
        .attr('text-anchor','start')
        .attr('font-family','Oswald, system-ui, sans-serif')
        .attr('font-weight',700)
        .attr('font-size', LINE2_SIZE)
        .attr('fill', DEM_SOLID)
        .text(demLine2);

      // Republicans — upper right
      labelG.append('text')
        .attr('x', rightX + REP_DX)
        .attr('y', topY   + REP_DY)
        .attr('text-anchor','end')
        .attr('font-family','Oswald, system-ui, sans-serif')
        .attr('font-weight',700)
        .attr('font-size', LINE1_SIZE)
        .attr('fill', REP_SOLID)
        .text(repLine1);

      labelG.append('text')
        .attr('x', rightX + REP_DX)
        .attr('y', topY + REP_DY + LINE1_SIZE + GAP)
        .attr('text-anchor','end')
        .attr('font-family','Oswald, system-ui, sans-serif')
        .attr('font-weight',700)
        .attr('font-size', LINE2_SIZE)
        .attr('fill', REP_SOLID)
        .text(repLine2);

      }
    

    function addTitleAndLegendForSenate(svg, { called, leaders, cx, cy, innerR, outerR }){
      const labelG = svg.append("g")
        .attr("font-family","Oswald, system-ui, sans-serif")
        .attr("text-anchor","start");
        
        const LINE1_SIZE = 34;   // label size
        const LINE2_SIZE = 76;   // big number size
        const GAP        = 62;   // extra pixels between lines

      const topY   = cy - innerR * 1.62;       // vertical where the labels sit
      const leftX  = cx - outerR * 1.40;       // left block
      const rightX = cx + outerR * 0.85;       // right block

      const DEM_SOLID = getVar('--dem') || '#0067cb';
      const REP_SOLID = getVar('--gop') || '#ec1d19';

      const DEM_DX = 100, REP_DX = 98;            // tweak if you want nudges
      const DEM_DY = -55.5, REP_DY = -55.5;
      const demLine1 = 'DEMOCRATS';
       const repLine1 = 'REPUBLICANS';
       
       const SHOW_DELTA = false;

       const demLine2 = SHOW_DELTA && uncalled.DEM ? `${called.DEM} (+${uncalled.DEM})` : String(called.DEM);
       const repLine2 = SHOW_DELTA && uncalled.REP ? `${called.REP} (+${uncalled.REP})` : String(called.REP);

  // Democrats — upper left
       labelG.append('text')
         .attr('x', leftX + DEM_DX)
         .attr('y', topY  + DEM_DY)
         .attr('text-anchor','start')
         .attr('font-family','Oswald, system-ui, sans-serif')
         .attr('font-weight',700)
         .attr('font-size', LINE1_SIZE)
         .attr('fill', DEM_SOLID)
         .text(demLine1);

       labelG.append('text')
         .attr('x', leftX + DEM_DX)
         .attr('y', topY + DEM_DY + LINE1_SIZE + GAP) // explicit offset below line 1
         .attr('text-anchor','start')
         .attr('font-family','Oswald, system-ui, sans-serif')
         .attr('font-weight',700)
         .attr('font-size', LINE2_SIZE)
         .attr('fill', DEM_SOLID)
         .text(demLine2);

       // Republicans — upper right
       labelG.append('text')
         .attr('x', rightX + REP_DX)
         .attr('y', topY   + REP_DY)
         .attr('text-anchor','end')
         .attr('font-family','Oswald, system-ui, sans-serif')
         .attr('font-weight',700)
         .attr('font-size', LINE1_SIZE)
         .attr('fill', REP_SOLID)
         .text(repLine1);

       labelG.append('text')
         .attr('x', rightX + REP_DX)
         .attr('y', topY + REP_DY + LINE1_SIZE + GAP)
         .attr('text-anchor','end')
         .attr('font-family','Oswald, system-ui, sans-serif')
         .attr('font-weight',700)
         .attr('font-size', LINE2_SIZE)
         .attr('fill', REP_SOLID)
         .text(repLine2);


    }

    
    
    
    
    // Build USPS lists for each seat bucket used by the horseshoe painter
    function buildSenateUSPSBuckets2026(){
      const out = {
        dem_called: [], dem_leading: [],
        ind_called: [], ind_leading: [],
        rep_called: [], rep_leading: []
      };

      for (const usps of USPS_50_STATES){
        const fp = STATEFP_BY_USPS?.[usps];
        if (!fp) continue;

        // Called?
        const { status, winnerParty } = getStateCall(fp) || {};
        if (isRaceCalled(status)) {
          const P = normalizeParty(winnerParty);
          if (P === 'DEM') out.dem_called.push(usps);
          else if (P === 'REP') out.rep_called.push(usps);
          else out.ind_called.push(usps);
          continue;
        }

        // Not called → figure the leader by collapsing county votes to party
        const tallies = { DEM:0, REP:0, IND:0 };
        for (const [fips, row] of Object.entries(countyData || {})) {
          if (String(fips).length !== 5 || !String(fips).startsWith(fp)) continue;
          const cs = Array.isArray(row.candidates) ? row.candidates : [];
          for (const c of cs){
            const P = normalizeParty(c.party);
            const v = Number(c.votes ?? c.VoteCount ?? 0);
            if (Number.isFinite(v) && v > 0) tallies[P] = (tallies[P] || 0) + v;
          }
        }
        // single leader only (ties → no label)
        let leader = null, max = -1;
        for (const [p,v] of Object.entries(tallies)){
          if (v > max){ max = v; leader = p; }
          else if (v === max){ leader = null; }
        }
        if (leader === 'DEM') out.dem_leading.push(usps);
        else if (leader === 'REP') out.rep_leading.push(usps);
        else if (leader === 'IND') out.ind_leading.push(usps);
      }

      // Stabilize order within each bucket
      Object.keys(out).forEach(k => out[k].sort());
      return out;
    }

    
    function renderSenateHorseshoeDiscrete(containerEl){
      const container = containerEl || document.getElementById('bopChart');
      if (!container) return;

      // --- compute counts ---
      const calledBase = countSenateCalled2026();
      const called     = (YEAR === '2026') ? addSenateHoldovers(calledBase) : calledBase;      // {DEM, REP, IND}
      const leaders = countSenateLeaders2026();     // {DEM, REP, IND}

      // Map to the 7.html keys
      const data = {
        dem_called:  called.DEM,
        dem_leading: leaders.DEM,
        ind_called:  called.IND,
        ind_leading: leaders.IND,
        rep_called:  called.REP,
        rep_leading: leaders.REP
      };

      // --- scaffold SVG (same geometry as 7.html) ---
      const cfg = {
        rings: 5,
        spokesPerSide: 10,
        seatR: 15,
        innerR: 200,
        ringGap: 35,
        arcLeft:  { start: 180, end: 90 },
        arcRight: { start:   0, end: 90 },
        cx: 600, cy: 420,
        majorityY: 360,
        halfOffsetX: 18
      };

      // Build the DOM
      const svg = d3.select(container)
        .html('')                     // clear previous render
        .append('svg')
          .attr('viewBox', '0 0 1200 700')
          .attr('aria-label', 'Senate Horseshoe – Single U (100 seats)')
          .node();

          d3.select(svg)
            .append('line')
            .attr('x1', cfg.cx)                     // center X
            .attr('x2', cfg.cx)
            .attr('y1', cfg.cy - cfg.innerR - 150)   // adjust these to taste
            .attr('y2', cfg.cy + cfg.innerR - 392.5)
            .attr('stroke', '#000')
            .attr('stroke-width', 2.5)
            .attr('opacity', 0.9)
            .lower();
          
          
          const outerR = cfg.innerR + (cfg.rings - 1) * cfg.ringGap + cfg.seatR; // compute outer radius

          addTitleAndLegendForSenate(
            d3.select(svg),
            { called, leaders, cx: cfg.cx, cy: cfg.cy, innerR: cfg.innerR, outerR }
          );
          
      // Divider + "FOR MAJORITY"
      svg.appendChild(line(cfg.cx, 120, cfg.cx, 560, "divider"));
      const centerY = cfg.majorityY;           // keep your y baseline
      const maj = text(cfg.cx, centerY - 20, "51", "labels");
      maj.setAttribute("text-anchor", "middle");
      maj.setAttribute("font-family", "Oswald, system-ui, sans-serif");
      maj.setAttribute("font-weight", "800");
      maj.setAttribute("font-size", "64");
      maj.setAttribute("fill", "#111");
      svg.appendChild(maj);

      const maj2 = text(cfg.cx, centerY + 15, "FOR MAJORITY", "labels sub");
      maj2.setAttribute("text-anchor", "middle");
      maj2.setAttribute("font-family", "Oswald, system-ui, sans-serif");
      maj2.setAttribute("font-weight", "700");
      maj2.setAttribute("font-size", "28");
      maj2.setAttribute("letter-spacing", "0.6");
      maj2.setAttribute("fill", "#111");
      svg.appendChild(maj2);

      // Radii
      const radii = Array.from({length: cfg.rings}, (_, i) => cfg.innerR + i*cfg.ringGap);

      // Build both quarters sharing ONE center
      addQuarter(cfg.arcLeft.start,  cfg.arcLeft.end,  -2.7);
      addQuarter(cfg.arcRight.start, cfg.arcRight.end, +2.7);

      // Color constants driven by your CSS variables
      const DEM_DARK = partySolid('DEM');     // called dem
      const DEM_LIGHT= partyDim('DEM');       // leading dem
      const REP_DARK = partySolid('REP');     // called rep
      const REP_LIGHT= partyDim('REP');       // leading rep
      const IND_DARK = partySolid('IND');     // called ind
      const IND_LIGHT= partyDim('IND');       // leading ind
      const REST     = COLOR_NO_DATA || getVar('--rest') || '#cfcfcf';

      // Paint in left→right order using the same algorithm as 7.html
      colorWithData({
        dem_called:  data.dem_called,
        dem_leading: data.dem_leading,
        ind_called:  data.ind_called,
        ind_leading: data.ind_leading,
        rep_called:  data.rep_called,
        rep_leading: data.rep_leading
      })
      
      // after colorWithData({ ... })
      if (YEAR === '2026') {
        const hold = SENATE_HOLDOVERS_2026 || {DEM:0, REP:0, IND:0};

        const seats  = Array.from(svg.querySelectorAll('circle.seat'));
        const left   = seats.slice(0, 50);
        const right  = seats.slice(50);
        const ordered = left.concat(right.slice().reverse()); // left→right order

        // clear any previous outlines
        ordered.forEach(c => {
          c.style.stroke = 'none';
          c.style.strokeWidth = null;
          c.removeAttribute('data-holdover');
        });

        // helper to outline a run of seats
        const outline = (start, count) => {
          const end = Math.min(start + Math.max(0, count), ordered.length);
          for (let i = start; i < end; i++) {
            ordered[i].style.stroke = '#000';
            ordered[i].style.strokeWidth = 2;
            ordered[i].setAttribute('vector-effect', 'non-scaling-stroke'); // keeps width consistent
            ordered[i].setAttribute('data-holdover', '1');
          }
        };

        // segments in the left→right painting order used above
        const demCalledStart = 0;
        const indCalledStart = demCalledStart + data.dem_called + data.dem_leading;
        const repCalledStart = ordered.length - data.rep_called;

        // put the black ring on the *holdover* portion of each called segment
        outline(demCalledStart, Math.min(hold.DEM, data.dem_called));           // DEM holdovers
        outline(indCalledStart, Math.min(hold.IND, data.ind_called));           // IND holdovers
        outline(repCalledStart + (data.rep_called - Math.min(hold.REP, data.rep_called)),
                Math.min(hold.REP, data.rep_called));                            // REP holdovers (take from the right end)
      }
      
      
      // === NEW: per-bucket USPS labels (called/leading by party; alpha within each bucket) ===
      if (YEAR === '2026') {
        const seats  = Array.from(svg.querySelectorAll('circle.seat'));
        const left   = seats.slice(0, 50);
        const right  = seats.slice(50);
        const ordered = left.concat(right.slice().reverse()); // same order as painter

        // Build USPS lists by bucket (alpha inside each)
        const buckets = buildSenateUSPSBuckets2026();

        // Clear any previous labels
        svg.querySelectorAll('text.seat-label').forEach(n => n.remove());

        // Handy ranges that match your paint layout
        const used = data.dem_called + data.dem_leading + data.ind_called + data.ind_leading + data.rep_leading + data.rep_called;
        const greyCount = Math.max(0, 100 - used); // center gap
        const demCalledStart = 0;
        const demLeadingStart = demCalledStart + data.dem_called;
        const indCalledStart = demLeadingStart + data.dem_leading;
        const indLeadingStart = indCalledStart + data.ind_called;
        const repLeadingStart = indLeadingStart + data.ind_leading + greyCount;
        const repCalledStart  = ordered.length - data.rep_called;

        // Label helper: walk a segment, skip holdovers, drop USPS text
        function labelSegment(start, count, list){
          const end = Math.min(start + Math.max(0, count), ordered.length);
          let i = 0;
          for (let k = start; k < end && i < list.length; k++){
            const c = ordered[k];
            if (c.getAttribute('data-holdover') === '1') continue; // never label holdovers
            const cx = parseFloat(c.getAttribute('cx'));
            const cy = parseFloat(c.getAttribute('cy'));

            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('class', 'seat-label');
            t.setAttribute('x', cx);
            t.setAttribute('y', cy + 4);             // optical centering
            t.setAttribute('text-anchor', 'middle');
            t.setAttribute('font-family', 'Oswald, system-ui, sans-serif');
            t.setAttribute('font-weight', '700');
            t.setAttribute('font-size', '11');
            t.setAttribute('pointer-events', 'none');

            // Contrast: white on colored seats, dark on grey
            const fill = c.style.fill || (COLOR_NO_DATA || '#cfcfcf');
            t.setAttribute('fill', (fill === (COLOR_NO_DATA || '#cfcfcf')) ? '#222' : '#fff');

            t.textContent = list[i++];
            svg.appendChild(t);
          }
        }

        // Drop labels into each painted bucket (order matches painter)
        labelSegment(demCalledStart,  data.dem_called,    buckets.dem_called);
        labelSegment(demLeadingStart, data.dem_leading,   buckets.dem_leading);
        labelSegment(indCalledStart,  data.ind_called,    buckets.ind_called);
        labelSegment(indLeadingStart, data.ind_leading,   buckets.ind_leading);
        labelSegment(repLeadingStart, data.rep_leading,   buckets.rep_leading);
        labelSegment(repCalledStart,  data.rep_called,    buckets.rep_called);
      }
      // === END per-bucket USPS labels ===
;

      // ------- helpers (ported from 7.html; DOM-native for speed) -------
      function colorWithData(d){
        const seats = Array.from(svg.querySelectorAll('circle.seat'));
        const left  = seats.slice(0, 50);       // far-left → center
        const right = seats.slice(50);          // far-right → center

        // start all grey
        seats.forEach(c => c.style.fill = REST);

        // one left→right list: left (left→center) + right (center→right)
        const ordered = left.concat(right.slice().reverse());

        // dem_called → dem_leading → ind_called → ind_leading → grey → rep_leading → rep_called
        let i = 0;
        i = paint(ordered, i, d.dem_called,    DEM_DARK);
        i = paint(ordered, i, d.dem_leading,   DEM_LIGHT);
        i = paint(ordered, i, d.ind_called,    IND_DARK);
        i = paint(ordered, i, d.ind_leading,   IND_LIGHT);

        const used = d.dem_called + d.dem_leading + d.ind_called + d.ind_leading + d.rep_leading + d.rep_called;
        const greyCount = Math.max(0, 100 - used);
        i += greyCount; // leave grey

        i = paint(ordered, i, d.rep_leading,   REP_LIGHT);
        i = paint(ordered, i, d.rep_called,    REP_DARK);
      }

      function paint(arr, start, count, color){
        const end = Math.min(start + Math.max(0, count), arr.length);
        for (let k = start; k < end; k++) arr[k].style.fill = color;
        return end;
      }

      // Geometry helpers (same as 7.html)
      function addQuarter(a0, a1, dir){
        const angles = spread(cfg.spokesPerSide, a0, a1);
        angles.forEach(deg => {
          const rad = toRad(deg);
          radii.forEach(r => {
            const x = cfg.cx + Math.cos(rad)*r + (dir||0)*cfg.halfOffsetX;
            const y = cfg.cy - Math.sin(rad)*r;
            svg.appendChild(seat(x, y, cfg.seatR));
          });
        });
      }
      function seat(x,y,r){ const c = ns('circle'); c.setAttribute('class','seat'); c.setAttribute('cx',x.toFixed(2)); c.setAttribute('cy',y.toFixed(2)); c.setAttribute('r',r); return c; }
      function line(x1,y1,x2,y2,cls){ const l = ns('line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2); if(cls) l.setAttribute('class',cls); return l; }
      function text(x,y,str,cls){ const t = ns('text'); t.setAttribute('x',x); t.setAttribute('y',y); if(cls) t.setAttribute('class',cls); t.textContent=str; return t; }
      function spread(n, a, b){ if(n===1) return [(a+b)/2]; const out=[]; for(let i=0;i<n;i++){ out.push(a + (i/(n-1))*(b-a)); } return out; }
      function toRad(d){ return d*Math.PI/180; }
      function ns(tag){ return document.createElementNS("http://www.w3.org/2000/svg", tag); }
    }
    
    
    // Re-render the BOP horseshoe if we are in the right mode
    function renderBopIfActive(){
      if (!BOP_MODE) return;
      const el = document.getElementById('bopChart');
      if (!el) return;

      if (OFFICE === 'H' && YEAR === '2026') {
        el.removeAttribute('hidden');
        renderHouseHorseshoe2026(el);
      } else if (OFFICE === 'S') {
          el.classList.remove('house');
          el.classList.add('senate');  // 👈 tag Senate
        el.removeAttribute('hidden');
        renderSenateHorseshoeDiscrete(el);
      } else {
        hideBopChart();
      }
    }



</script>
</body>
</html>
